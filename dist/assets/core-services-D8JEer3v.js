import{D as le,a as J,A as Ve,S as Ke,b as We,U as Ye,E as ke,c as X,d as Qe,g as Je}from"./data-definitions-BS67O2Yi.js";import{o as I,n as d,a as M,e as R,b as P,s as k,u as fe,l as N,d as Xe,r as _,Z as B}from"./vendor-DevG9r99.js";const K=1,L=4,Ze={STATUS_EFFECTS:0,ACTIONS:7,VICTORY:999,END_TURN:0,QUEUE_ROUND:1e3},et=1e6,z={REVIVE_HP_PERCENTAGE:.5,DEFENSE_MULTIPLIER:.5,PSYNERGY_DEFENSE_MULTIPLIER:.3,ELEMENT_ADVANTAGE_MULTIPLIER:1.5,ELEMENT_DISADVANTAGE_MULTIPLIER:.67,MINIMUM_DAMAGE:1,MINIMUM_HEALING:1};function we(e=L){if(e<K||e>L)throw new Error(`Queue size must be between ${K} and ${L}, got ${e}`);return Array(e).fill(null)}function Gn(e,t,n){const s=typeof n=="number"?n:Ze[n];return e+t*et+s}function Vn(e){if(e.length<K||e.length>L)throw new Error(`Team must have between ${K} and ${L} units, got ${e.length}`);return{equippedDjinn:[],djinnTrackers:{},units:e,collectedDjinn:[],currentTurn:0,activationsThisTurn:{},djinnStates:{}}}function H(e,t){if(t.equippedDjinn!==void 0){if(new Set(t.equippedDjinn).size!==t.equippedDjinn.length)throw new Error(`Cannot equip duplicate Djinn. Equipped: ${t.equippedDjinn.join(", ")}`);if(t.equippedDjinn.length>3)throw new Error(`Cannot equip more than 3 Djinn. Attempted: ${t.equippedDjinn.length}`)}return{...e,...t,djinnTrackers:t.djinnTrackers?{...e.djinnTrackers,...t.djinnTrackers}:e.djinnTrackers,activationsThisTurn:t.activationsThisTurn?{...e.activationsThisTurn,...t.activationsThisTurn}:e.activationsThisTurn,djinnStates:t.djinnStates?{...e.djinnStates,...t.djinnStates}:e.djinnStates}}const tt={1:80,2:150,3:300};function Kn(e){if(e.length===0)return{atk:0,def:0,classChange:"Base",abilitiesUnlocked:[]};const t=new Map;for(const r of e)t.set(r,(t.get(r)||0)+1);const n=t.size,s=Math.max(...Array.from(t.values())),a=Array.from(t.entries()).find(([,r])=>r===s)?.[0];return e.length===1?{atk:4,def:3,classChange:"Adept",abilitiesUnlocked:[]}:e.length===2&&n===1?{atk:8,def:5,classChange:`${a} Warrior`,abilitiesUnlocked:[]}:e.length===2&&n===2?{atk:5,def:5,classChange:"Hybrid",abilitiesUnlocked:[]}:e.length===3&&n===1?{atk:12,def:8,classChange:`${a} Adept`,abilitiesUnlocked:[`${a}-Ultimate`]}:e.length===3&&n===2&&s===2?{atk:8,def:6,classChange:`${a} Knight`,abilitiesUnlocked:["Hybrid-Spell"]}:{atk:4,def:4,spd:4,classChange:"Mystic",abilitiesUnlocked:["Elemental Harmony"]}}function Ae(e){return e.equippedDjinn.filter(t=>e.djinnTrackers[t]?.state==="Set")}function nt(e){return tt[e]}function st(e,t){return e.equippedDjinn.includes(t)?e.djinnTrackers[t]?.state==="Set":!1}const at={Venus:"Jupiter",Jupiter:"Venus",Mars:"Mercury",Mercury:"Mars",Neutral:"Neutral"};function se(e,t){return e===t?"same":at[e]===t?"counter":"neutral"}function xe(e,t){const n=Ae(t),s={};for(const a of n){const r=rt(a);if(!r)continue;const u=se(e.element,r),o=(c,i)=>{s[c]=(s[c]||0)+i};switch(u){case"same":o("atk",4),o("def",3);break;case"counter":o("atk",-3),o("def",-2);break;case"neutral":o("atk",2),o("def",2);break}}return s}function rt(e){return J[e]?.element??null}function it(e){return e.equippedDjinn.filter(t=>e.djinnTrackers[t]?.state==="Standby")}function ot(e,t){const n=Ae(t),s=it(t),a=[];for(const r of n){const u=J[r];if(!u)continue;const o=se(e.element,u.element),c=u.grantedAbilities[e.id];if(!c||o==="counter")continue;let i=[];switch(o){case"same":i=c.same.slice(0,2);break;case"neutral":i=c.neutral.slice(0,1);break}a.push(...i)}for(const r of s){const u=J[r];if(!u)continue;const o=se(e.element,u.element),c=u.grantedAbilities[e.id];if(!c||o!=="counter")continue;const i=c.counter.slice(0,2);a.push(...i)}return[...new Set(a)]}function pe(e,t){const n=ot(e,t),s=new Set(e.abilities.map(i=>i.id)),a=e.abilities.filter(i=>!le[i.id]||n.includes(i.id)),r=e.unlockedAbilityIds.filter(i=>!le[i]||n.includes(i)),u=n.map(i=>le[i]).filter(i=>i!==void 0).filter(i=>!s.has(i.id)),o=[...a,...u],c=Array.from(new Set([...r,...n]));return{...e,abilities:o,unlockedAbilityIds:c}}function ut(e,t,n){const s=t.equippedDjinn,a=new Set,r=[];for(const u of s){const o=J[u];if(!o)continue;const c=o.grantedAbilities[e.id];if(!c)continue;const i=se(e.element,o.element),l=i==="same"?c.same:i==="counter"?c.counter:c.neutral;for(const f of l)a.has(f)||(a.add(f),r.push({abilityId:f,djinnId:u,compatibility:i}))}return r}function Wn(e,t){const n=t.equippedDjinn.filter(a=>t.djinnTrackers[a]?.state!=="Set");if(n.length===0)return[];const s=new Set(n);return ut(e,t).filter(a=>s.has(a.djinnId))}function De(e,t){const n=new Map;for(const s of e)n.set(s.id,{unit:s,isPlayer:!0});for(const s of t)n.set(s.id,{unit:s,isPlayer:!1});return n}function ct(e){return e.units.reduce((t,n)=>t+n.manaContribution,0)}function lt(e,t,n=[]){const s=e.units.map(o=>pe(o,e)),a=H(e,{units:s}),r=ct(a),u=De(a.units,t);return{playerTeam:a,enemies:t,unitById:u,currentTurn:0,roundNumber:1,phase:"planning",turnOrder:n.length>0?n:[],currentActorIndex:0,status:"ongoing",log:[],currentQueueIndex:0,queuedActions:we(e.units.length),queuedDjinn:[],remainingMana:r,maxMana:r,executionIndex:0,djinnRecoveryTimers:{}}}function j(e,t){const n={...e,...t};return(t.playerTeam||t.enemies)&&(n.unitById=De(n.playerTeam.units,n.enemies)),n}function dt(e){return e.meta?.encounterId??e.encounterId}function ne(e){const t=(e.level-1)*e.growthRates.hp;return e.baseStats.hp+t}function E(e){return e.currentHp<=0}function Re(e,t=1,n=0){const s=e.baseStats.hp+(t-1)*e.growthRates.hp,a=e.abilities.filter(r=>t>=(r.unlockLevel??1)).map(r=>r.id);return{id:e.id,name:e.name,element:e.element,role:e.role,baseStats:e.baseStats,growthRates:e.growthRates,description:e.description,autoAttackTiming:e.autoAttackTiming??"same-turn",manaContribution:e.manaContribution,level:t,xp:n,currentHp:s,equipment:{weapon:null,armor:null,helm:null,boots:null,accessory:null},storeUnlocked:!1,djinn:[],djinnStates:{},abilities:e.abilities,unlockedAbilityIds:a,statusEffects:[],actionsTaken:0,battleStats:{damageDealt:0,damageTaken:0}}}function Yn(e,t){return{...e,...t,equipment:t.equipment?{...e.equipment,...t.equipment}:e.equipment,battleStats:t.battleStats?{...e.battleStats,...t.battleStats}:e.battleStats}}function Qn(){return{weapon:null,armor:null,helm:null,boots:null,accessory:null}}function ft(e){const t={};for(const n of Object.values(e))if(n)for(const s of Object.keys(n.statBonus)){const a=n.statBonus[s];a!=null&&typeof a=="number"&&(t[s]=(t[s]??0)+a)}return t}function pt(e){const t=e.level-1;return{hp:t*e.growthRates.hp,pp:t*e.growthRates.pp,atk:t*e.growthRates.atk,def:t*e.growthRates.def,mag:t*e.growthRates.mag,spd:t*e.growthRates.spd}}function mt(e){const t={};for(const n of e.statusEffects)if(n.type==="buff"||n.type==="debuff"){const s=n.stat,a=n.modifier;if(s&&a!==void 0){const r=t[s]??0;t[s]=r+a}}return t}function q(e,t){const n=e.baseStats,s=pt(e),a=ft(e.equipment),r=xe(e,t),u=mt(e);return{hp:Math.max(1,Math.floor(n.hp+(s.hp??0)+(a.hp??0)+(u.hp??0))),pp:Math.max(0,Math.floor(n.pp+(s.pp??0)+(a.pp??0)+(u.pp??0))),atk:Math.max(1,Math.floor(n.atk+(s.atk??0)+(a.atk??0)+(r.atk??0)+(u.atk??0))),def:Math.max(0,Math.floor(n.def+(s.def??0)+(a.def??0)+(r.def??0)+(u.def??0))),mag:Math.max(1,Math.floor(n.mag+(s.mag??0)+(a.mag??0)+(r.mag??0)+(u.mag??0))),spd:Math.max(1,Math.floor(n.spd+(s.spd??0)+(a.spd??0)+(r.spd??0)+(u.spd??0)))}}function F(e,t){return q(e,t).spd}const ve={"Venus→Jupiter":!0,"Mars→Venus":!0,"Mercury→Mars":!0,"Jupiter→Mercury":!0};function ae(e,t){const n=`${e}→${t}`;if(ve[n])return z.ELEMENT_ADVANTAGE_MULTIPLIER;const s=`${t}→${e}`;return ve[s]?z.ELEMENT_DISADVANTAGE_MULTIPLIER:1}function Me(e,t,n){let s=e;if(t&&t!=="Neutral"){const f=1-n.statusEffects.filter(p=>p.type==="elementalResistance"&&p.element===t).map(p=>p.modifier).reduce((p,y)=>p+y,0);s*=f}const u=n.statusEffects.filter(c=>c.type==="damageReduction").map(c=>c.percent).reduce((c,i)=>c+i,0),o=Math.min(1,Math.max(0,u));return s*=1-o,s}function Te(e,t,n,s){const a=q(e,n),r=q(t,n),u=s.basePower>0?s.basePower:a.atk,o=a.atk,c=Math.min(1,Math.max(0,s.ignoreDefensePercent||0)),i=r.def*(1-c),l=u+o-i*z.DEFENSE_MULTIPLIER,f=Me(l,s.element,t);return Math.max(z.MINIMUM_DAMAGE,Math.floor(f))}function Se(e,t,n,s){const a=q(e,n),r=q(t,n),u=s.basePower||0,o=a.mag,c=Math.min(1,Math.max(0,s.ignoreDefensePercent||0)),l=r.def*(1-c)*z.PSYNERGY_DEFENSE_MULTIPLIER,f=s.element?ae(s.element,t.element):1;let p=(u+o-l)*f;const y=t.equipment.armor?.elementalResist||0;s.element&&y>0&&(p=p*(1-y));const h=Me(p,s.element,t);return Math.max(z.MINIMUM_DAMAGE,Math.floor(h))}function ht(e,t,n){const s=n.basePower||0;if(s<0||s===0)return 0;const r=q(e,t).mag,u=s+r;return Math.max(z.MINIMUM_HEALING,Math.floor(u))}function gt(e){return e.statusEffects.some(t=>t.type==="invulnerable")}function yt(e){return e.statusEffects.some(t=>t.type==="shield"&&t.remainingCharges>0)}function vt(e){let t=!1;const n=e.statusEffects.map(s=>s.type==="shield"&&s.remainingCharges>0&&!t?(t=!0,{...s,remainingCharges:s.remainingCharges-1}):s).filter(s=>!(s.type==="shield"&&s.remainingCharges===0));return{...e,statusEffects:n}}function je(e,t){const n=ne(e),s=Math.max(0,Math.min(n,e.currentHp-t));return{...e,currentHp:s,battleStats:{...e.battleStats,damageTaken:e.battleStats.damageTaken+t}}}function Ee(e,t){if(t<=0)return{updatedUnit:e,actualDamage:0};if(gt(e))return{updatedUnit:e,actualDamage:0};if(yt(e))return{updatedUnit:vt(e),actualDamage:0};let n=je(e,t);n={...n,statusEffects:n.statusEffects.filter(r=>!(r.type==="shield"&&r.remainingCharges===0))};const{updatedUnit:s,revived:a}=Tt(n);return a?{updatedUnit:s,actualDamage:t,autoRevived:!0}:{updatedUnit:s,actualDamage:t}}function Tt(e){if(e.currentHp>0){if(e.statusEffects.some(i=>i.type==="autoRevive"&&i.usesRemaining===0)){const i=e.statusEffects.filter(l=>!(l.type==="autoRevive"&&l.usesRemaining===0));return{updatedUnit:{...e,statusEffects:i},revived:!1}}return{updatedUnit:e,revived:!1}}const n=e.statusEffects.filter(c=>c.type==="autoRevive"&&c.usesRemaining>0)[0];if(!n){if(e.statusEffects.some(i=>i.type==="autoRevive"&&i.usesRemaining===0)){const i=e.statusEffects.filter(l=>!(l.type==="autoRevive"&&l.usesRemaining===0));return{updatedUnit:{...e,statusEffects:i},revived:!1}}return{updatedUnit:e,revived:!1}}const s=ne(e),a=Math.floor(s*n.hpPercent);let r=!1;const u=e.statusEffects.map(c=>c.type==="autoRevive"&&c.usesRemaining>0&&!r?(r=!0,{...c,usesRemaining:c.usesRemaining-1}):c).filter(c=>!(c.type==="autoRevive"&&c.usesRemaining===0));return{updatedUnit:{...e,currentHp:a,statusEffects:u},revived:!0}}function St(e,t,n=!1){if(t<0)throw new Error(`Cannot apply negative healing: ${t}`);if(E(e)&&!n)throw new Error("Cannot heal KO'd unit without revivesFallen ability");const s=ne(e),a=Math.min(s,Math.max(0,e.currentHp+t));return{...e,currentHp:a}}function Ue(e,t,n,s=0){const a=e.filter(f=>!E(f)),r=a.filter(f=>f.equipment.boots?.alwaysFirstTurn===!0),u=a.filter(f=>f.equipment.boots?.alwaysFirstTurn!==!0),o=n.clone();for(let f=0;f<s;f++)o.next();const c=[...r].sort((f,p)=>f.id.localeCompare(p.id)).sort((f,p)=>{const y=F(f,t),m=F(p,t)-y;if(m===0){const S=t.units.some(w=>w.id===f.id),v=t.units.some(w=>w.id===p.id);return S!==v?S?-1:1:o.next()-.5}return m}),i=[...u].sort((f,p)=>f.id.localeCompare(p.id)).sort((f,p)=>{const y=F(f,t),m=F(p,t)-y;if(m===0){const S=t.units.some(w=>w.id===f.id),v=t.units.some(w=>w.id===p.id);return S!==v?S?-1:1:o.next()-.5}return m});return[...c,...i].map(f=>f.id)}function $e(e,t){let n=0,s=0;const a=[],r=e.baseStats.hp+(e.level-1)*e.growthRates.hp,u=e.statusEffects.map(i=>{if(i.type==="poison"){const l=Math.floor(r*.08);return n+=l,a.push(`${e.name} takes ${l} poison damage!`),{...i,duration:i.duration-1}}else if(i.type==="burn"){const l=Math.floor(r*.1);return n+=l,a.push(`${e.name} takes ${l} burn damage!`),{...i,duration:i.duration-1}}else if(i.type==="healOverTime"){const l=i.healPerTurn;return s+=l,a.push(`${e.name} recovers ${l} HP!`),{...i,duration:i.duration-1}}else{if(i.type==="freeze")return t.next()<.3?(a.push(`${e.name} broke free from freeze!`),{...i,duration:0}):(a.push(`${e.name} is frozen and cannot act!`),{...i,duration:i.duration-1});if(i.type==="stun")return a.push(`${e.name} is stunned and cannot act!`),{...i,duration:i.duration-1};if(i.type==="autoRevive")return i}return"duration"in i?{...i,duration:i.duration-1}:i}).filter(i=>"duration"in i?i.duration>0:!0);let o=e;if(n>0&&(o=je(o,n)),s>0){const i=Math.min(o.currentHp+s,r);o={...o,currentHp:i}}return{updatedUnit:{...o,statusEffects:u},damage:n,healing:s,messages:a}}function Et(e,t){return!!(e.statusEffects.filter(a=>a.type==="paralyze")[0]&&t.next()<.25)}function bt(e){return e.statusEffects.some(t=>t.type==="freeze"||t.type==="stun")}function It(e,t){const n=e.statusEffects.filter(s=>s.type==="immunity");return n.some(s=>s.all)?!0:n.some(s=>s.types?.some(a=>a===t))}function kt(e){return!!(["poison","burn","freeze","paralyze","stun"].includes(e.type)||e.type==="debuff")}function te(e,t){if(t.type!=="immunity"&&It(e,t.type))return e;let n=e.statusEffects;return t.type==="immunity"&&(n=e.statusEffects.filter(s=>s.type!=="immunity")),{...e,statusEffects:[...n,t]}}function ue(e,t,n,s){const a=n.some(r=>r.id===t.id);switch(e.targets){case"single-enemy":return a?s.filter(r=>!E(r)):n.filter(r=>!E(r));case"all-enemies":return a?s.filter(r=>!E(r)):n.filter(r=>!E(r));case"single-ally":return a?n.filter(r=>!E(r)):s.filter(r=>!E(r));case"all-allies":return a?n.filter(r=>!E(r)):s.filter(r=>!E(r));case"self":return[t];default:return[]}}function wt(e,t){return t.type==="healing"&&!t.revivesFallen?e.filter(n=>!E(n)):e}function Jn(e,t,n,s){if(!e)return s.filter(a=>!E(a));switch(e.targets){case"single-enemy":case"all-enemies":return s.filter(a=>!E(a));case"single-ally":case"all-allies":return n.units.filter(a=>!E(a));case"self":return[t];default:return[]}}const D=e=>({ok:!0,value:e}),T=e=>({ok:!1,error:e});class Pe{snapshot=null;begin(t){this.snapshot=t}rollback(){return this.snapshot}commit(){this.snapshot=null}hasSnapshot(){return this.snapshot!==null}}const At=["poison","burn","freeze","paralyze","stun","debuff"],xt=e=>At.includes(e);function Dt(e,t,n){if(!e.units||e.units.length===0)return T("Player team must contain at least one unit");if(!t||t.length===0)return T("Battle requires at least one enemy");const s=[...e.units,...t],a=Ue(s,e,n,0);return D(lt(e,t,a))}function Rt(e,t,n,s,a){const r=new Pe;r.begin(e);const u=e.unitById.get(t);if(!u||E(u.unit))return r.rollback(),T(`Invalid actor: ${t}`);const o=u.unit;if(bt(o)){const g=o.statusEffects.find(b=>b.type==="freeze"),x=g?[{type:"status-applied",targetId:t,status:g}]:[];return r.commit(),D({state:e,result:{message:`${o.name} is frozen and cannot act!`,targetIds:[],updatedUnits:[...e.playerTeam.units,...e.enemies]},events:x})}if(Et(o,a)){const g=o.statusEffects.find(b=>b.type==="paralyze"),x=g?[{type:"status-applied",targetId:t,status:g}]:[];return r.commit(),D({state:e,result:{message:`${o.name} is paralyzed and cannot act!`,targetIds:[],updatedUnits:[...e.playerTeam.units,...e.enemies]},events:x})}const c=o.abilities.find(g=>g.id===n);if(!c)return r.rollback(),T(`Ability ${n} not found for unit ${t}`);const i=ue(c,o,e.playerTeam.units,e.enemies),f=wt(i,c).filter(g=>s.includes(g.id));if(f.length===0)return r.rollback(),T(`No valid targets for ability ${n}`);const p=f.filter(g=>(e.playerTeam.units.some(b=>b.id===g.id)||e.enemies.some(b=>b.id===g.id))&&!E(g));if(p.length===0)return r.rollback(),T("All targets are KO'd or invalid");const y=new Map;p.forEach(g=>{y.set(g.id,g.statusEffects)});const h=[...e.playerTeam.units,...e.enemies],m=Mt(o,c,p,h,e.playerTeam,e.enemies,a);if(!m.ok)return r.rollback(),T(m.error);const S=m.value,v=e.playerTeam.units.map(g=>S.updatedUnits.find(b=>b.id===g.id)||g),w=e.enemies.map(g=>S.updatedUnits.find(b=>b.id===g.id)||g),U={...e.playerTeam,units:v},$=j(e,{playerTeam:U,enemies:w,log:[...e.log,S.message]}),A=[{type:"ability",casterId:t,abilityId:n,targets:s}];return S.damage!==void 0&&s.forEach(g=>{if(f.find(b=>b.id===g)){A.push({type:"hit",targetId:g,amount:S.damage||0,element:c.element});const b=S.updatedUnits.find(C=>C.id===g);b&&b.currentHp<=0&&A.push({type:"ko",unitId:g})}}),S.healing!==void 0&&s.forEach(g=>{A.push({type:"heal",targetId:g,amount:S.healing||0})}),c.statusEffect&&s.forEach(g=>{const x=y.get(g)||[],b=S.updatedUnits.find(C=>C.id===g);if(b){const C=b.statusEffects,O=new Set(x.map(Y=>Y.type));C.filter(Y=>!O.has(Y.type)).forEach(Y=>{A.push({type:"status-applied",targetId:g,status:Y})})}}),r.commit(),D({state:$,result:S,events:A})}function de(e,t){return t.map(n=>{let s=n;if(e.shieldCharges){const a={type:"shield",remainingCharges:e.shieldCharges,duration:e.duration||3};s={...s,statusEffects:[...s.statusEffects,a]}}if(e.damageReductionPercent!==void 0){const a={type:"damageReduction",percent:e.damageReductionPercent,duration:e.duration||3};s={...s,statusEffects:[...s.statusEffects,a]}}if(e.elementalResistance){const a={type:"elementalResistance",element:e.elementalResistance.element,modifier:e.elementalResistance.modifier,duration:e.duration||3};s={...s,statusEffects:[...s.statusEffects,a]}}if(e.grantImmunity){const a={type:"immunity",all:e.grantImmunity.all,types:e.grantImmunity.types,duration:e.grantImmunity.duration};s={...s,statusEffects:[...s.statusEffects,a]}}if(e.removeStatusEffects){const a=e.removeStatusEffects;let r=s.statusEffects;if(a.type==="all")r=[];else if(a.type==="negative")r=r.filter(u=>!kt(u));else if(a.type==="byType"){const u=new Set(a.statuses);r=r.filter(o=>xt(o.type)?!u.has(o.type):!0)}s={...s,statusEffects:r}}return s})}function Mt(e,t,n,s,a,r,u){const o=n.map(l=>l.id);let c=`${e.name} uses ${t.name}!`;const i=[];switch(t.type){case"physical":case"psynergy":{let l=0;const f=t.hitCount||1;for(const h of n){let m=i.find(v=>v.id===h.id)||s.find(v=>v.id===h.id);if(!m||E(m))continue;let S=0;for(let v=0;v<f&&!E(m);v++){const w=t.type==="physical"?Te(e,m,a,t):Se(e,m,a,t),{updatedUnit:U,actualDamage:$}=Ee(m,w);m=U,S+=$;const A=i.findIndex(g=>g.id===m.id);A>=0?i[A]=m:i.push(m)}if(l+=S,t.statusEffect){const v=t.statusEffect.type,w=t.statusEffect.duration,U=t.statusEffect.chance??1;if(u.next()<U){const A=m.statusEffects.filter(b=>b.type!==v);m={...m,statusEffects:A};let g;v==="poison"?g={type:"poison",damagePerTurn:8,duration:w}:v==="burn"?g={type:"burn",damagePerTurn:10,duration:w}:v==="freeze"?g={type:"freeze",duration:w}:v==="stun"?g={type:"stun",duration:w}:g={type:"paralyze",duration:w},m=te(m,g);const x=i.findIndex(b=>b.id===m.id);x>=0?i[x]=m:i.push(m)}}if(t.debuffEffect){const v=[],w=["hp","pp","atk","def","mag","spd"];for(const[U,$]of Object.entries(t.debuffEffect))typeof $=="number"&&w.includes(U)&&v.push({type:"debuff",stat:U,modifier:-Math.abs($),duration:t.duration||3});if(v.length>0){for(const $ of v)m=te(m,$);const U=i.findIndex($=>$.id===m.id);U>=0?i[U]=m:i.push(m)}}}if(t.splashDamagePercent&&t.targets==="single-enemy"&&n.length===1){const h=n[0]?.id,m=t.splashDamagePercent,S=r.filter(v=>v.id!==h&&!E(v));for(const v of S){let w=i.find(b=>b.id===v.id)||s.find(b=>b.id===v.id);if(!w||E(w))continue;const U=t.type==="physical"?Te(e,w,a,t):Se(e,w,a,t),$=Math.floor(U*m),{updatedUnit:A,actualDamage:g}=Ee(w,$);w=A,l+=g;const x=i.findIndex(b=>b.id===w.id);x>=0?i[x]=w:i.push(w)}}const p=de(t,i);i.splice(0,i.length,...p),c+=` Deals ${l} damage!`;const y=s.map(h=>i.find(S=>S.id===h.id)||h);return D({damage:l,message:c,targetIds:o,updatedUnits:y,hit:l>0})}case"healing":{let l=0;for(const y of n){let h=y;if((t.revivesFallen||t.revive)&&E(y)){const m=y.baseStats.hp+(y.level-1)*y.growthRates.hp,S=t.reviveHPPercent??z.REVIVE_HP_PERCENTAGE;h={...y,currentHp:Math.floor(m*S)},l+=h.currentHp}else if(!E(y)){const m=ht(e,a,t);h=St(y,m,t.revivesFallen||t.revive||!1),l+=h.currentHp-y.currentHp}if(t.healOverTime&&!E(h)){const m={type:"healOverTime",healPerTurn:t.healOverTime.amount,duration:t.healOverTime.duration},S=h.statusEffects.filter(v=>v.type!=="healOverTime");h={...h,statusEffects:[...S,m]}}i.push(h)}const f=de(t,i);i.splice(0,i.length,...f),c+=` Restores ${l} HP!`;const p=s.map(y=>i.find(m=>m.id===y.id)||y);return D({healing:l,message:c,targetIds:o,updatedUnits:p,hit:!1})}case"buff":case"debuff":{for(const p of n)if(t.buffEffect){let y=p;const h=["hp","pp","atk","def","mag","spd"];for(const[m,S]of Object.entries(t.buffEffect))if(typeof S=="number"&&h.includes(m)){const v={type:t.type==="buff"?"buff":"debuff",stat:m,modifier:S,duration:t.duration||3};y=te(y,v)}i.push(y)}else i.push(p);const l=de(t,i);i.splice(0,i.length,...l),c+=` Applied ${t.type}!`;const f=s.map(p=>i.find(h=>h.id===p.id)||p);return D({message:c,targetIds:o,updatedUnits:f,hit:!1})}case"summon":return D({message:`${e.name} summons ${t.name}!`,targetIds:o,updatedUnits:[...s],hit:!1});default:{const l=t.type;return T(`Unhandled ability type: ${String(l)}`)}}}function Xn(e,t){const n=new Pe;n.begin(e);let s=e;const a=s.turnOrder[s.currentActorIndex];if(!a){let i=s.currentActorIndex+1;i>=s.turnOrder.length&&(i=0);const l=j(s,{currentActorIndex:i});return n.commit(),D(l)}const r=s.unitById.get(a),u=r?.unit;if(u){const i=$e(u,t);if(r.isPlayer){const f=s.playerTeam.units.map(p=>p.id===a?i.updatedUnit:p);s=j(s,{playerTeam:{...s.playerTeam,units:f},log:i.messages.length>0?[...s.log,...i.messages]:s.log})}else{const f=s.enemies.map(p=>p.id===a?i.updatedUnit:p);s=j(s,{enemies:f,log:i.messages.length>0?[...s.log,...i.messages]:s.log})}}let o=s.currentActorIndex+1;if(o>=s.turnOrder.length){o=0;const i=s.currentTurn+1,l=Ue([...s.playerTeam.units,...s.enemies],s.playerTeam,t,i),f=j(s,{currentTurn:i,turnOrder:l,currentActorIndex:0});return n.commit(),D(f)}const c=j(s,{currentActorIndex:o});return n.commit(),D(c)}function Zn(e){const t=e.playerTeam.units.every(s=>E(s)),n=e.enemies.every(s=>E(s));return n&&t?"PLAYER_DEFEAT":n?"PLAYER_VICTORY":t?"PLAYER_DEFEAT":null}function es(e,t){const n=e.turnOrder[e.currentActorIndex];if(!n)return{updatedState:e,events:[]};const s=[...e.playerTeam.units,...e.enemies],a=s.find(h=>h.id===n);if(!a)return{updatedState:e,events:[]};const r=$e(a,t),u=s.map(h=>h.id===n?r.updatedUnit:h),o=u.filter(h=>e.playerTeam.units.some(m=>m.id===h.id)),c=u.filter(h=>e.enemies.some(m=>m.id===h.id)),i={...e,playerTeam:{...e.playerTeam,units:o},enemies:c},l=[];r.damage>0&&l.push({type:"hit",targetId:n,amount:r.damage});const f=h=>`${h.type}-${"duration"in h?h.duration:"usesRemaining"in h?h.usesRemaining:"permanent"}`,p=new Set(a.statusEffects.map(f)),y=new Set(r.updatedUnit.statusEffects.map(f));return a.statusEffects.forEach(h=>{const m=f(h);p.has(m)&&!y.has(m)&&l.push({type:"status-expired",targetId:n,status:h})}),{updatedState:i,events:l}}function jt(e,t,n){let s=e.aiHints?.priority??1;const a=n.playerTeam,r={equippedDjinn:[],djinnTrackers:{},units:n.enemies,collectedDjinn:[],currentTurn:n.currentTurn??0,activationsThisTurn:{},djinnStates:{}},u={...r},o=q(t,u),i=ue(e,t,n.playerTeam.units,n.enemies).filter(f=>!E(f));if(i.length===0)return-1e3;let l=0;if(e.type==="physical"||e.type==="psynergy"){const f=e.basePower||0,p=e.type==="physical"?o.atk:o.mag,y=i.reduce((S,v)=>{const w=a.units.includes(v)?a:r,U=q(v,w).def;return S+U},0)/i.length,h=f+p-y,m=Math.max(1,h);if(e.element){const S=i.reduce((v,w)=>v+ae(e.element,w.element),0)/i.length;l=m*S}else l=m;(e.targets==="all-enemies"||e.targets==="all-allies")&&(l*=i.length)}else if(e.type==="healing"){const f=e.basePower||0,p=o.mag,y=f+p;l=Math.max(1,y),e.targets==="all-allies"&&(l*=i.length)}else(e.type==="buff"||e.type==="debuff")&&e.buffEffect&&(l=Object.values(e.buffEffect).filter(y=>typeof y=="number").reduce((y,h)=>y+Math.abs(h),0)*2);return s+=l*.1,e.aiHints?.opener&&(s+=1),s}function Ut(e,t,n,s){const r=ue(e,t,n.playerTeam.units,n.enemies).filter(o=>!E(o));if(r.length===0)return[];switch(e.aiHints?.target||"weakest"){case"weakest":{const o=r.map(c=>{const i=ne(c),l=c.currentHp,f=l/i;let p=l;if(e.element){const y=ae(e.element,c.element);p=l/y}return{target:c,effectiveHp:p,hpRatio:f}});if(o.sort((c,i)=>c.effectiveHp-i.effectiveHp),e.aiHints?.avoidOverkill){const c=(e.basePower||0)+(e.type==="physical"?t.baseStats.atk:t.baseStats.mag),i=o.filter(l=>c-l.effectiveHp<l.effectiveHp*.5);if(i.length>0)return[i[0].target.id]}return e.targets==="all-enemies"||e.targets==="all-allies"?o.map(c=>c.target.id):o.length>0?[o[0].target.id]:[]}case"lowestRes":{if(!e.element||r.length===0)return r.length>0?[r[0].id]:[];const o=e.element,c=r.map(i=>{const l=ae(o,i.element);return{target:i,resistMod:l}});return c.sort((i,l)=>i.resistMod-l.resistMod),c.length>0?[c[0].target.id]:[]}case"healerFirst":{const o=r.filter(c=>c.abilities.some(i=>i.type==="healing"));return o.length>0?[o[0].id]:r.length>0?[r[0].id]:[]}case"random":{if(r.length===0)return[];if(e.targets==="all-enemies"||e.targets==="all-allies")return r.map(c=>c.id);const o=Math.floor(s.next()*r.length);return[r[o].id]}case"highestDef":{if(r.length===0)return[];const o=r.map(c=>{const i=c.baseStats.def;return{target:c,def:i}});return o.sort((c,i)=>i.def-c.def),o.length>0?[o[0].target.id]:[]}default:return r.length>0?[r[0].id]:[]}}function $t(e,t,n){const a=[...e.playerTeam.units,...e.enemies].find(i=>i.id===t);if(!a||E(a))throw new Error(`Invalid actor: ${t}`);const r=a.abilities.filter(i=>ue(i,a,e.playerTeam.units,e.enemies).filter(p=>!E(p)).length>0);if(r.length===0)throw new Error(`No available abilities for ${t}`);const u=r.map(i=>({ability:i,score:jt(i,a,e)}));if(u.sort((i,l)=>l.score-i.score),u.length===0)throw new Error(`No scored abilities for ${t}`);let o=u[0].ability;if(u.length>1&&u[0].score-u[1].score<2){const i=u.slice(0,2),l=Math.floor(n.next()*i.length);o=i[l].ability}const c=Ut(o,a,e,n);return{abilityId:o.id,targetIds:c}}class re{state;initialSeed;draws;constructor(t){if(t<0)throw new Error(`PRNG seed must be non-negative, got: ${t}`);this.initialSeed=t||1,this.state=this.initialSeed,this.draws=0;for(let n=0;n<10;n++)this.stepInternal()}stepInternal(){return this.state^=this.state<<13,this.state^=this.state>>>17,this.state^=this.state<<5,this.state>>>0}next(){const t=this.stepInternal();return this.draws+=1,t/4294967296}nextU32(){const t=this.stepInternal();return this.draws+=1,t}clone(){const t=new re(this.initialSeed);return t.state=this.state,t.draws=this.draws,t}getSeed(){return this.initialSeed}getDrawCount(){return this.draws}snapshot(){return{state:this.state>>>0,initialSeed:this.initialSeed>>>0,draws:this.draws>>>0}}static fromSerialized(t){const n=new re(t.initialSeed);return n.state=t.state>>>0,n.draws=t.draws>>>0,n}}function ts(e){if(e<0)throw new Error(`PRNG seed must be non-negative, got: ${e}`);return new re(e)}function Pt(e,t){return e>=t}function Nt(e,t){if(e===null)return 0;if(!t)throw new Error(`Ability ${e} not found`);return t.manaCost??0}function Ct(e){return e.filter(t=>t!==null).reduce((t,n)=>t+n.manaCost,0)}function qt(e,t){return Ct(t)<=e}function _t(e){return e.abilityId===null}function Ht(e,t){return _t(e)}function ns(e,t,n,s,a){if(e.phase!=="planning")return T("Can only queue actions during planning phase");const r=e.playerTeam.units.findIndex(c=>c.id===t);if(r===-1)return T(`Unit ${t} not found in player team`);const u=e.playerTeam.units.length;if(r<0||r>=u)return T(`Unit index ${r} out of bounds for team size ${u}`);const o=e.queuedActions[r];try{const c=Nt(n,a),i=e.remainingMana+(o?.manaCost??0);if(!Pt(i,c))return T(`Cannot afford action: need ${c} mana, have ${i}`);const l={unitId:t,abilityId:n,targetIds:s,manaCost:c},f=[...e.queuedActions];return f[r]=l,D(j(e,{queuedActions:f,remainingMana:i-c}))}catch(c){return T(c instanceof Error?c.message:`Failed to queue action: ${String(c)}`)}}function ss(e,t){if(e.phase!=="planning")return T("Can only clear actions during planning phase");const n=e.queuedActions[t];if(!n)return D(e);const s=[...e.queuedActions];return s[t]=null,D(j(e,{queuedActions:s,remainingMana:e.remainingMana+n.manaCost}))}function as(e,t){return e.phase!=="planning"?T("Can only queue Djinn during planning phase"):st(e.playerTeam,t)?e.queuedDjinn.includes(t)?D(e):D(j(e,{queuedDjinn:[...e.queuedDjinn,t]})):T(`Djinn ${t} cannot be activated (not Set)`)}function rs(e,t){return e.phase!=="planning"?T("Can only unqueue Djinn during planning phase"):D(j(e,{queuedDjinn:e.queuedDjinn.filter(n=>n!==t)}))}function Ft(e){return j(e,{remainingMana:e.maxMana})}function Ot(e){if(e.phase!=="planning")return T("Can only execute round from planning phase");const n=e.playerTeam.units.filter(a=>!E(a)).length,s=e.queuedActions.filter((a,r)=>{const u=e.playerTeam.units[r];return u&&!E(u)&&a!==null});return s.length!==n?T(`Cannot execute: queue incomplete. Expected ${n} actions for alive units, got ${s.length}`):qt(e.maxMana,e.queuedActions)?D(e):T("Cannot execute: actions exceed mana budget")}function Bt(e){return j(e,{phase:"executing",executionIndex:0})}function Lt(e,t){const n=e.queuedActions.filter(c=>c!==null),s=Qt(e,t),a=[...n,...s],r=Wt(a,e.playerTeam,e.enemies);let u=e;const o=[];for(const c of r){const l=[...u.playerTeam.units,...u.enemies].find(h=>h.id===c.unitId);if(!l||E(l))continue;const f=Yt(c,u);if(f.length===0)continue;const p=Rt(u,c.unitId,c.abilityId||"strike",f,t);if(!p.ok)continue;if(u=p.value.state,o.push(...p.value.events),u.playerTeam.units.some(h=>h.id===c.unitId)&&Ht(c,p.value)){const m=Math.min(u.remainingMana+1,u.maxMana);u=j(u,{remainingMana:m}),o.push({type:"mana-generated",amount:1,source:c.unitId,newTotal:m})}}return{state:u,events:o}}function zt(e){return Jt(e)}function Gt(e,t){return j(e,{phase:t==="PLAYER_VICTORY"?"victory":"defeat",status:t})}function Vt(e){const t={...e.djinnRecoveryTimers},n={...e.playerTeam.djinnTrackers};for(const[o,c]of Object.entries(t))if(c>0){if(t[o]=c-1,t[o]===0){delete t[o];const i=n[o];i&&(n[o]={...i,state:"Set"})}}else delete t[o];let s=H(e.playerTeam,{djinnTrackers:n});const r=s.units.map(o=>pe(o,s)).map(o=>{const i=q(o,s).hp;let l=o;return o.currentHp>i&&(l={...l,currentHp:i}),l});s=H(s,{units:r});const u=j(e,{phase:"planning",roundNumber:e.roundNumber+1,currentQueueIndex:0,queuedActions:we(s.units.length),queuedDjinn:[],executionIndex:0,playerTeam:s,djinnRecoveryTimers:t});return Ft(u)}function is(e,t){if(!Ot(e).ok)return{state:e,events:[]};let s=Bt(e);const a=[];if(s.queuedDjinn.length>0){const o=Kt(s,t);s=o.state,a.push(...o.events)}const r=Lt(s,t);s=r.state,a.push(...r.events);const u=zt(s);if(u)s=Gt(s,u),a.push({type:"battle-end",result:u});else{const o=s;s=Vt(s);const c=Xt(o.playerTeam,s.playerTeam);if(c.length>0){const i=ie(o.playerTeam),l=ie(s.playerTeam),f=Ne(i,l,s.playerTeam.units,"djinn-recovered",c);a.push(...f)}}return{state:s,events:a}}function Kt(e,t){const n=[];let s=e,a=e.playerTeam;if(e.queuedDjinn.length===0)return{state:e,events:n};const r=e.queuedDjinn.length,u=ie(e.playerTeam),o=e.queuedDjinn.map(S=>J[S]).filter(S=>!!S),i=e.queuedDjinn.length+1,l={...a.djinnTrackers};for(const S of e.queuedDjinn){const v=l[S];v&&(l[S]={...v,state:"Standby",lastActivatedTurn:e.roundNumber})}a=H(a,{djinnTrackers:l});const p=a.units.map(S=>pe(S,a)).map(S=>{const w=q(S,a).hp;return S.currentHp>w?{...S,currentHp:w}:S});a=H(a,{units:p});const y=ie(a),h=Ne(u,y,a.units,"djinn-standby",e.queuedDjinn);n.push(...h);const m={...e.djinnRecoveryTimers};for(const S of e.queuedDjinn)m[S]=i;s=j(s,{playerTeam:a,djinnRecoveryTimers:m});for(const S of o){const v=S.summonEffect,w=[],U=[];if(v.type==="damage"){const A=v.damage??nt(r);if(r===3){const g=s.enemies.map(x=>{if(E(x))return x;const b=Math.max(0,x.currentHp-A);return n.push({type:"hit",targetId:x.id,amount:A}),w.push(x.id),{...x,currentHp:b}});s=j(s,{enemies:g})}else{const g=s.enemies.filter(x=>!E(x));if(g.length>0){const x=Math.floor(t.next()*g.length),b=g[x],C=Math.max(0,b.currentHp-A);n.push({type:"hit",targetId:b.id,amount:A}),w.push(b.id);const O=s.enemies.map(G=>G.id===b.id?{...G,currentHp:C}:G);s=j(s,{enemies:O})}}}else if(v.type==="heal"){const A=v.healAmount,g=s.playerTeam.units.map(b=>{const C=q(b,s.playerTeam).hp,O=Math.min(b.currentHp+A,C);return O!==b.currentHp&&U.push(b.id),{...b,currentHp:O}}),x=H(s.playerTeam,{units:g});s=j(s,{playerTeam:x})}else if(v.type==="buff"){const A=v.statBonus,g=s.playerTeam.units.map(b=>{let C=b;return Object.entries(A).forEach(([O,G])=>{G!==void 0&&(C=te(C,{type:"buff",stat:O,modifier:G,duration:3}))}),C}),x=H(s.playerTeam,{units:g});s=j(s,{playerTeam:x})}else if(v.type==="special"){const A=s.enemies.map(g=>E(g)?g:te(g,{type:"paralyze",duration:1}));s=j(s,{enemies:A})}const $=v.type==="heal"?U:v.type==="damage"?w:v.type==="buff"?s.playerTeam.units.map(A=>A.id):s.enemies.filter(A=>!E(A)).map(A=>A.id);if($.length>0&&n.push({type:"ability",casterId:"djinn-summon",abilityId:`summon-${S.id}`,targets:$}),v.type==="heal")for(const A of U)n.push({type:"heal",targetId:A,amount:v.healAmount})}return{state:s,events:n}}function Wt(e,t,n){const s=[...t.units,...n],a={equippedDjinn:[],djinnTrackers:{}};return[...e].sort((r,u)=>{const o=s.find(y=>y.id===r.unitId),c=s.find(y=>y.id===u.unitId);if(!o||!c)return 0;const i=t.units.some(y=>y.id===r.unitId),l=t.units.some(y=>y.id===u.unitId),f=i?F(o,t):F(o,a),p=l?F(c,t):F(c,a);return p!==f?p-f:i!==l?i?-1:1:r.unitId.localeCompare(u.unitId)})}function Yt(e,t){const n=[...t.playerTeam.units,...t.enemies],s=n.find(c=>c.id===e.unitId),a=e.targetIds.filter(c=>{const i=n.find(l=>l.id===c);return i&&!E(i)});if(a.length>0)return a;let r="enemy",u="single";if(s&&e.abilityId){let c=s.abilities.find(i=>i.id===e.abilityId);if(c||(c=Ve[e.abilityId]),c){const i=c.targets;i==="single-ally"||i==="all-allies"||i==="self"?r="ally":r="enemy",i==="all-enemies"||i==="all-allies"?u="all":u="single"}else console.warn(`[QueueBattle] Ability ${e.abilityId} not found for actor ${s.id}`)}else e.abilityId===null&&(r="enemy",u="single");const o=t.playerTeam.units.some(c=>c.id===e.unitId);if(r==="ally"){const c=o?t.playerTeam.units.filter(i=>!E(i)):t.enemies.filter(i=>!E(i));return c.length===0?[]:u==="all"?c.map(i=>i.id):[c[0].id]}else{const c=o?t.enemies.filter(i=>!E(i)):t.playerTeam.units.filter(i=>!E(i));return c.length===0?[]:u==="all"?c.map(i=>i.id):[c[0].id]}}function Qt(e,t){const n=[];for(const s of e.enemies)if(!E(s))try{const a=$t(e,s.id,t);a&&n.push({unitId:s.id,abilityId:a.abilityId,targetIds:a.targetIds,manaCost:0})}catch(a){console.warn(`AI decision failed for enemy ${s.id}, using basic attack:`,a);const r=e.playerTeam.units.filter(u=>!E(u));r.length>0&&n.push({unitId:s.id,abilityId:null,targetIds:[r[0].id],manaCost:0})}return n}function Jt(e){const t=e.enemies.every(a=>E(a)),n=e.playerTeam.units.every(a=>E(a)),s=e.playerTeam.units.filter(a=>!E(a));return n&&s.length>0?(console.warn("[QueueBattle] BUG: checkBattleEnd detected all players KO but some units are alive!",{units:e.playerTeam.units.map(a=>({id:a.id,currentHp:a.currentHp,isKO:E(a)})),aliveUnits:s.map(a=>({id:a.id,currentHp:a.currentHp})),allPlayersKO:n}),null):t&&n?"PLAYER_DEFEAT":t?"PLAYER_VICTORY":n?"PLAYER_DEFEAT":null}function ie(e){const t={};for(const n of e.units)t[n.id]=xe(n,e);return t}function Ne(e,t,n,s,a){if(a.length===0)return[];const r=[];for(const u of n){const o=e[u.id],c=t[u.id],i=(c?.atk??0)-(o?.atk??0),l=(c?.def??0)-(o?.def??0);i===0&&l===0||r.push({type:s,unitId:u.id,djinnIds:a,atkDelta:i,defDelta:l})}return r}function Xt(e,t){const n=[];for(const[s,a]of Object.entries(t.djinnTrackers)){const r=e.djinnTrackers[s]?.state;r&&r!=="Set"&&a.state==="Set"&&n.push(s)}return n}function os(e){const t=e.playerTeam.units.map((n,s)=>({index:s,spd:E(n)?-1:F(n,e.playerTeam),isKo:E(n)}));return t.sort((n,s)=>n.isKo&&!s.isKo?1:!n.isKo&&s.isKo?-1:s.spd!==n.spd?s.spd-n.spd:n.index-s.index),t.map(n=>n.index)}function us(e){return e.map(t=>{const n=ne(t);return{...t,currentHp:n,statusEffects:[]}})}const oe=I({hp:d().int().min(0),pp:d().int().min(0),atk:d().int().min(0),def:d().int().min(0),mag:d().int().min(0),spd:d().int().min(0)}),Ce=M(R(["campaign","tower"])).min(1),Zt=R(["Venus","Mars","Mercury","Jupiter","Neutral"]),en=I({hp:d().int(),pp:d().int(),atk:d().int(),def:d().int(),mag:d().int(),spd:d().int()}).partial(),tn=R(["weapon","armor","helm","boots","accessory"]),nn=R(["basic","bronze","iron","steel","silver","mythril","legendary","artifact"]),Q=I({id:k().min(1),name:k().min(1),slot:tn,tier:nn,cost:d().int().min(0),statBonus:en.default({}),allowedElements:M(Zt).min(1).readonly(),unlocksAbility:k().optional(),equipmentUnlocksPermanent:P().optional(),elementalResist:d().min(0).max(1).optional(),alwaysFirstTurn:P().optional(),availableIn:Ce.optional().readonly()}),sn=I({weapon:Q.nullable(),armor:Q.nullable(),helm:Q.nullable(),boots:Q.nullable(),accessory:Q.nullable()}),an=/^[a-z0-9]+(?:-[a-z0-9]+)*$/,qe=I({id:k().regex(an,{message:"Ability ID must be kebab-case (lowercase alphanumerics and hyphens only)"}),name:k().min(1),type:R(["physical","psynergy","healing","buff","debuff","summon"]),element:R(["Venus","Mars","Jupiter","Mercury","Neutral"]).optional(),manaCost:d().int().min(0).max(5),basePower:d().int().min(0),targets:R(["single-enemy","all-enemies","single-ally","all-allies","self"]),unlockLevel:d().int().min(1).max(20),kind:R(["attack","psynergy"]).optional(),description:k(),chainDamage:P().optional(),revivesFallen:P().optional(),buffEffect:I({atk:d().optional(),def:d().optional(),mag:d().optional(),spd:d().optional()}).optional(),duration:d().int().min(1).optional(),statusEffect:I({type:R(["poison","burn","freeze","paralyze","stun"]),duration:d().int().min(1),chance:d().min(0).max(1).optional()}).optional(),debuffEffect:I({atk:d().optional(),def:d().optional(),mag:d().optional(),spd:d().optional(),hp:d().optional()}).optional(),healOverTime:I({amount:d().int().min(1),duration:d().int().min(1)}).optional(),hitCount:d().int().min(1).max(10).optional(),revive:P().optional(),reviveHPPercent:d().min(0).max(1).optional(),ignoreDefensePercent:d().min(0).max(1).optional(),splashDamagePercent:d().min(0).max(1).optional(),shieldCharges:d().int().min(1).max(99).optional(),removeStatusEffects:fe([I({type:N("all")}),I({type:N("negative")}),I({type:N("byType"),statuses:M(R(["poison","burn","freeze","paralyze","stun","debuff"]))})]).optional(),damageReductionPercent:d().min(0).max(1).optional(),elementalResistance:I({element:R(["Venus","Mars","Mercury","Jupiter"]),modifier:d()}).optional(),grantImmunity:I({all:P(),types:M(R(["poison","burn","freeze","paralyze","stun","debuff"])).optional(),duration:d().int().min(1)}).optional(),aiHints:I({priority:d().min(0).max(3).optional(),target:R(["weakest","random","lowestRes","healerFirst","highestDef"]).optional(),avoidOverkill:P().optional(),opener:P().optional()}).optional()}),me=R(["Venus","Mars","Mercury","Jupiter","Neutral"]),_e=R(["Balanced Warrior","Pure DPS","Elemental Mage","Healer","Rogue Assassin","AoE Fire Mage","Support Buffer","Defensive Tank","Versatile Scholar","Master Warrior"]),ce=R(["Set","Standby","Recovery"]),be=R(["hp","pp","atk","def","mag","spd"]),rn=Xe("type",[I({type:N("buff"),stat:be,modifier:d().positive(),duration:d().int().positive()}),I({type:N("debuff"),stat:be,modifier:d().negative(),duration:d().int().positive()}),I({type:R(["poison","burn"]),damagePerTurn:d().int().positive(),duration:d().int().positive()}),I({type:R(["freeze","paralyze","stun"]),duration:d().int().positive()}),I({type:N("healOverTime"),healPerTurn:d().int().positive(),duration:d().int().positive()}),I({type:N("elementalResistance"),element:me,modifier:d(),duration:d().int().positive()}),I({type:N("damageReduction"),percent:d().min(0).max(1),duration:d().int().positive()}),I({type:N("shield"),remainingCharges:d().int().min(0),duration:d().int().positive()}),I({type:N("invulnerable"),duration:d().int().positive()}),I({type:N("immunity"),all:P(),types:M(R(["poison","burn","freeze","paralyze","stun","debuff"])).optional(),duration:d().int().positive()}),I({type:N("autoRevive"),hpPercent:d().min(0).max(1),usesRemaining:d().int().min(1)})]),cs=I({id:k().min(1),name:k().min(1),element:me,role:_e,baseStats:oe,growthRates:oe,abilities:M(qe),manaContribution:d().int().min(0),description:k(),autoAttackTiming:R(["same-turn","next-turn"]).optional(),availableIn:Ce.optional().readonly()}),he=I({id:k().min(1),name:k().min(1),element:me,role:_e,baseStats:oe,growthRates:oe,description:k(),manaContribution:d().int().min(0),level:d().int().min(1).max(20),xp:d().int().min(0),currentHp:d().int().min(0),autoAttackTiming:R(["same-turn","next-turn"]).optional(),equipment:sn,storeUnlocked:P(),djinn:M(k().min(1)),djinnStates:_(k(),ce),abilities:M(qe),unlockedAbilityIds:M(k().min(1)),statusEffects:M(rn),actionsTaken:d().int().min(0),battleStats:I({damageDealt:d().int().min(0),damageTaken:d().int().min(0)})}).superRefine((e,t)=>{const n=e.baseStats.hp+(e.level-1)*e.growthRates.hp;e.currentHp>n&&t.addIssue({code:B.custom,message:`currentHp (${e.currentHp}) exceeds maxHp (${n})`,path:["currentHp"]})}),on=I({djinnId:k().min(1),state:ce,lastActivatedTurn:d().int()}),un=I({defeated:P().optional(),dialogueSeen:P().optional(),questProgress:d().int().min(0).optional(),lastInteraction:d().int().optional(),customData:_(k(),fe([k(),d(),P()])).optional()}),cn=I({highestFloorEver:d().int().min(0).default(0),totalRuns:d().int().min(0).default(0),bestRunTurns:d().int().min(0).nullable().default(null),bestRunDamageDealt:d().int().min(0).nullable().default(null)}),Z=I({version:N("1.0.0"),timestamp:d().int().positive(),chapter:d().int().min(1).default(1),playerData:I({unitsCollected:M(he).max(10),activeParty:M(k().min(1)).min(K).max(L),inventory:M(Q),gold:d().int().min(0),djinnCollected:M(k().min(1)).max(12),equippedDjinn:M(k().min(1)).max(3).optional(),djinnTrackers:_(k(),on).optional(),recruitmentFlags:_(k(),P()),storyFlags:_(k(),P())}),overworldState:I({playerPosition:I({x:d(),y:d()}),currentScene:k().min(1),npcStates:_(k(),un)}),stats:I({battlesWon:d().int().min(0),battlesLost:d().int().min(0),totalDamageDealt:d().int().min(0),totalHealingDone:d().int().min(0),playtime:d().int().min(0)}),towerStats:cn.optional()}),ln=I({djinnId:k().min(1),state:ce,lastActivatedTurn:d().int().min(0)}),dn=I({equippedDjinn:M(k().min(1)).max(3),djinnTrackers:_(k(),ln),units:M(he).min(K).max(L),collectedDjinn:M(k().min(1)).max(12),currentTurn:d().int().min(0),activationsThisTurn:_(k(),d().int().min(0)),djinnStates:_(k(),ce)}).superRefine((e,t)=>{e.equippedDjinn.length>3&&t.addIssue({code:B.too_big,maximum:3,type:"array",inclusive:!0,path:["equippedDjinn"]})}),fn=R(["PLAYER_VICTORY","PLAYER_DEFEAT"]),pn=fe([N("ongoing"),fn]),mn=I({unitId:k().min(1),abilityId:k().nullable(),targetIds:M(k().min(1)),manaCost:d().int().min(0).max(10)}),hn=R(["planning","executing","victory","defeat"]);I({playerTeam:dn,enemies:M(he).min(1),currentTurn:d().int().min(0),roundNumber:d().int().min(1),phase:hn,turnOrder:M(k().min(1)),currentActorIndex:d().int().min(0),status:pn,log:M(k()),currentQueueIndex:d().int().min(0),queuedActions:M(mn.nullable()).min(K).max(L),queuedDjinn:M(k().min(1)),remainingMana:d().int().min(0),maxMana:d().int().min(0),executionIndex:d().int().min(0),djinnRecoveryTimers:_(k(),d().int().min(0)),rngSnapshot:I({state:d().int(),initialSeed:d().int(),draws:d().int()}).optional(),isBossBattle:P().optional(),npcId:k().optional(),encounterId:k().optional(),meta:I({encounterId:k(),difficulty:R(["normal","elite","boss"]).optional()}).optional()}).superRefine((e,t)=>{const n=e.playerTeam.units.map(u=>u.id),s=e.enemies.map(u=>u.id),a=new Set([...n,...s]);for(const[u,o]of e.turnOrder.entries())a.has(o)||t.addIssue({code:B.custom,path:["turnOrder",u],message:`Unknown actor id: ${o}`});const r=e.playerTeam.units.length;e.currentQueueIndex>=r&&t.addIssue({code:B.too_big,maximum:r-1,type:"number",inclusive:!0,path:["currentQueueIndex"],message:`currentQueueIndex (${e.currentQueueIndex}) exceeds team size (${r})`}),e.queuedActions.length!==r&&t.addIssue({code:B.custom,path:["queuedActions"],message:`queuedActions length (${e.queuedActions.length}) must match team size (${r})`});for(const[u,o]of e.queuedActions.entries())o&&!n.includes(o.unitId)&&t.addIssue({code:B.custom,path:["queuedActions",u,"unitId"],message:`Queued action references unknown unit: ${o.unitId}`}),o&&u>=r&&t.addIssue({code:B.custom,path:["queuedActions",u],message:`Queued action at index ${u} exceeds team size (${r})`});e.remainingMana>e.maxMana&&t.addIssue({code:B.custom,path:["remainingMana"],message:`remainingMana (${e.remainingMana}) exceeds maxMana (${e.maxMana})`})});const gn="1.0.0";function He(e){const t=Z.safeParse(e);return t.success?D(t.data):T(`Invalid save data: ${t.error.message}`)}function yn(e,t,n=gn,s){if(!e||typeof e!="object")return T({type:"INVALID_FORMAT",message:"Save file is not an object"});const a=e,r=[a.version?null:"version",a.timestamp?null:"timestamp",a.checksum?null:"checksum",typeof a.data>"u"?"data":null].filter(i=>i!==null);if(r.length>0)return T({type:"MISSING_DATA",missingFields:r});let u=a.data;const o=a.version;if(o!==n)if(s){const i=s(u);if(!i.ok)return T({type:"VERSION_MISMATCH",saveVersion:o,currentVersion:n,canMigrate:!0});u=i.value}else return T({type:"VERSION_MISMATCH",saveVersion:o,currentVersion:n,canMigrate:!1});if(!vn(u,a.checksum))return T({type:"CHECKSUM_FAILED",expected:a.checksum,actual:ge(u)});const c=t.safeParse(u);return c.success?D(c.data):T({type:"INVALID_FORMAT",message:c.error.message})}function ge(e){const t=JSON.stringify(e,(s,a)=>a&&typeof a=="object"&&!Array.isArray(a)?Object.keys(a).sort().reduce((r,u)=>(r[u]=a[u],r),{}):a);let n=2166136261;for(let s=0;s<t.length;s++)n^=t.charCodeAt(s),n=Math.imul(n,16777619);return(n>>>0).toString(16).padStart(8,"0")}function vn(e,t){return ge(e)===t}const Tn="vale_chronicles_v2_save_slot_",Sn="_backup";function ee(e){if(e<0||e>=3)throw new Error(`Invalid save slot: ${e}. Must be 0-2.`);return`${Tn}${e}`}function ye(e){return`${e}${Sn}`}function En(e){try{const t=localStorage.getItem(e);return t&&localStorage.setItem(ye(e),t),D(void 0)}catch(t){const n=t instanceof Error?t.message:String(t);return T(`Failed to create backup: ${n}`)}}function bn(e,t){const n=ge(e);return{version:t,timestamp:Date.now(),checksum:n,data:e}}function Fe(e,t,n,s){return yn(e,n,t,s)}function Oe(e,t){try{if(e<0||e>=3)return T(`Invalid save slot: ${e}. Must be 0-2.`);const n=Z.safeParse(t);if(!n.success)return T(`Invalid save data: ${n.error.message}`);const s=ee(e),a=En(s);if(!a.ok)return a;const r=bn(n.data,"1.0.0"),u=JSON.stringify(r);return localStorage.setItem(s,u),D(void 0)}catch(n){return T(`Failed to save progress: ${n instanceof Error?n.message:String(n)}`)}}function Be(e){try{if(e<0||e>=3)return T(`Invalid save slot: ${e}. Must be 0-2.`);const t=ee(e),n=localStorage.getItem(t);if(!n)return T("No save file found in this slot");let s;try{s=JSON.parse(n)}catch(u){const o=u instanceof Error?u.message:"Invalid JSON";return Ie(e,`JSON parse failed: ${o}`)}const a=Fe(s,"1.0.0",Z,He);if(!a.ok){const u=a.error.type;return Ie(e,`Validation failed: ${u}`)}const r=Z.safeParse(a.value);return r.success?D(r.data):T(`Save file validation failed: ${r.error.message}`)}catch(t){return T(`Failed to load progress: ${t instanceof Error?t.message:String(t)}`)}}function Ie(e,t){try{const n=ee(e),s=ye(n),a=localStorage.getItem(s);if(!a){const c=t?` Main save error: ${t}`:"";return T(`Save file corrupted and no backup found.${c}`)}const r=JSON.parse(a),u=Fe(r,"1.0.0",Z,He);if(!u.ok){const c=t?` Main save error: ${t}`:"";return T(`Both main save and backup are corrupted.${c}`)}const o=Z.safeParse(u.value);if(!o.success){const c=t?` Main save error: ${t}`:"";return T(`Backup validation failed.${c}`)}return localStorage.setItem(n,a),D(o.data)}catch(n){const s=t?` Main save error: ${t}`:"";return T(`Failed to load backup: ${n instanceof Error?n.message:String(n)}.${s}`)}}function In(e){return e<0||e>=3?!1:localStorage.getItem(ee(e))!==null}function kn(e){try{if(e<0||e>=3)return T(`Invalid save slot: ${e}. Must be 0-2.`);const t=ee(e);return localStorage.removeItem(t),localStorage.removeItem(ye(t)),D(void 0)}catch(t){return T(`Failed to delete save: ${t instanceof Error?t.message:String(t)}`)}}function ls(e){if(e<0||e>=3)return{exists:!1};const t=localStorage.getItem(ee(e));if(!t)return{exists:!1};try{const n=JSON.parse(t);if(!n.data||!n.checksum)return{exists:!0,corrupted:!0};const s=n.data;if(!s.playerData||!s.stats||!Array.isArray(s.playerData.unitsCollected))return{exists:!0,corrupted:!0};const a=s.playerData.unitsCollected.length>0?Math.round(s.playerData.unitsCollected.reduce((r,u)=>{const o=typeof u?.level=="number"?u.level:1;return r+o},0)/s.playerData.unitsCollected.length):1;return{exists:!0,timestamp:typeof n.timestamp=="number"?n.timestamp:Date.now(),playtime:typeof s.stats.playtime=="number"?s.stats.playtime:0,teamLevel:a,gold:typeof s.playerData.gold=="number"?s.playerData.gold:0,chapter:1,corrupted:!1}}catch{return{exists:!0,corrupted:!0}}}function ds(e){return Oe(0,e)}function fs(){return Be(0)}function ps(){return In(0)}function ms(){return kn(0)}function hs(e,t){return Oe(e,t)}function gs(e){return Be(e)}const W={restFloorInterval:4,targetMaxFloor:100,healFractionAtRest:.5,enemyScalingPerFloor:.04,bossFloorInterval:5,maxTeamSize:4};W.restFloorInterval;W.targetMaxFloor;W.healFractionAtRest;W.enemyScalingPerFloor;W.bossFloorInterval;W.maxTeamSize;function ys(e,t,n,s={}){if(!n.length)throw new Error("TOWER_FLOORS must contain at least one entry");const a=[...n].sort((u,o)=>u.floorNumber-o.floorNumber),r=a.map(u=>u.id);return{seed:e,difficulty:t,floorIndex:0,floorIds:r,isCompleted:!1,isFailed:!1,stats:{highestFloor:0,totalBattles:0,victories:0,defeats:0,retreats:0,turnsTaken:0,totalDamageDealt:0,totalDamageTaken:0},history:a.map(u=>({floorId:u.id,floorNumber:u.floorNumber,type:u.type,outcome:"pending",rewardsGranted:[]})),pendingRewards:[],config:s.config??W,rentalTeamId:s.rentalTeamId}}function Le(e,t){if(e.floorIndex>=e.floorIds.length)return null;const n=e.floorIds[e.floorIndex];return wn(t,n)}function vs({run:e,floors:t,outcome:n,summary:s,rewards:a=[]}){const r=Le(e,t);if(!r)return e;if(r.type==="rest")throw new Error(`Cannot record battle result for rest floor ${r.id}`);const u=An(e.stats,r.floorNumber,n,s),o=e.history.map(h=>h.floorId!==r.id?h:{...h,outcome:n,rewardsGranted:a}),c=n==="victory",i=n==="retreat",l=c?Math.min(e.floorIndex+1,e.floorIds.length):e.floorIndex,f=l>=e.floorIds.length,p=n==="defeat";return{...e,stats:u,history:o,floorIndex:l,isCompleted:f||i||p,isFailed:p,pendingRewards:a.length?[...e.pendingRewards,...a]:e.pendingRewards}}function Ts(e,t,n){const s=Le(e,t);if(!s)return e;if(s.type!=="rest")throw new Error(`completeRestFloor called for non-rest floor ${s.id}`);const a=e.history.map(r=>r.floorId!==s.id?r:{...r,outcome:"rested",rewardsGranted:[],restSummary:n});return{...e,history:a,floorIndex:Math.min(e.floorIndex+1,e.floorIds.length),stats:{...e.stats,highestFloor:Math.max(e.stats.highestFloor,s.floorNumber)}}}function Ss(e){return e.pendingRewards.length?{...e,pendingRewards:[]}:e}function wn(e,t){const n=e.find(s=>s.id===t);if(!n)throw new Error(`Tower floor ${t} not found`);return n}function An(e,t,n,s){return{highestFloor:n==="victory"?Math.max(e.highestFloor,t):e.highestFloor,totalBattles:e.totalBattles+1,victories:e.victories+(n==="victory"?1:0),defeats:e.defeats+(n==="defeat"?1:0),retreats:e.retreats+(n==="retreat"?1:0),turnsTaken:e.turnsTaken+s.turnsTaken,totalDamageDealt:e.totalDamageDealt+s.damageDealt,totalDamageTaken:e.totalDamageTaken+s.damageTaken}}function xn(e,t){if(!J[t])return T(`Djinn ${t} does not exist`);if(e.collectedDjinn.includes(t))return T(`Djinn ${t} already collected`);if(e.collectedDjinn.length>=12)return T("Cannot collect more than 12 Djinn");const n=[...e.collectedDjinn,t];return D(H(e,{collectedDjinn:n}))}function Es(e,t,n=-1){if(!e.collectedDjinn.includes(t))return T(`Djinn ${t} not collected`);if(e.equippedDjinn.includes(t))return T(`Djinn ${t} already equipped`);if(e.equippedDjinn.length>=3){if(n<0||n>=3)return T("All 3 Djinn slots are full. Unequip one first.");const r=[...e.equippedDjinn],u=r[n];r[n]=t;const o={...e.djinnTrackers};return u&&delete o[u],o[t]||(o[t]={djinnId:t,state:"Set",lastActivatedTurn:-1}),D(H(e,{equippedDjinn:r,djinnTrackers:o}))}const s=[...e.equippedDjinn,t],a={...e.djinnTrackers};return a[t]||(a[t]={djinnId:t,state:"Set",lastActivatedTurn:-1}),D(H(e,{equippedDjinn:s,djinnTrackers:a}))}function bs(e=1){return{chapter:e,flags:{}}}function V(e,t,n=!0){return{...e,flags:{...e.flags,[t]:n}}}function Is(e,t){const n=ze(t);return n==="boss:ch1"&&e.chapter===1?{ok:!0,value:{...V(e,"boss:ch1",!0),chapter:2}}:n==="boss:ch2"&&e.chapter===2?{ok:!0,value:{...V(e,"boss:ch2",!0),chapter:3}}:n==="boss:ch3"&&e.chapter===3?{ok:!0,value:{...V(e,"boss:ch3",!0),chapter:4}}:{ok:!1,error:`No chapter transition available for ${t} (${n}) at chapter ${e.chapter}`}}function ze(e){if(e==="house-20")return"boss:ch1";if(e.startsWith("house-")){const t=e.match(/^house-(\d+)$/);if(t)return`encounter:ch1:${parseInt(t[1],10)}`}return e==="c1_boss"?"boss:ch1":e==="c2_boss"?"boss:ch2":e==="c3_boss"?"boss:ch3":e==="c1_mini_boss"||e==="c1_miniboss"?"miniboss:ch1":e==="c2_mini_boss"||e==="c2_miniboss"?"miniboss:ch2":e==="c3_mini_boss"||e==="c3_miniboss"?"miniboss:ch3":e.startsWith("c1_normal_")?`encounter:ch1:${e.replace("c1_normal_","")}`:e.startsWith("c2_normal_")?`encounter:ch2:${e.replace("c2_normal_","")}`:e.startsWith("c3_normal_")?`encounter:ch3:${e.replace("c3_normal_","")}`:(e.startsWith("boss:")||e.startsWith("miniboss:")||e.startsWith("encounter:"),e)}function ks(e,t){const n=ze(t);let s=V(e,n,!0);return t.startsWith("house-")&&(s=V(s,t,!0)),s}function ws(e,t){if(t==="house-01")return!0;const n=t.match(/^house-(\d+)$/);if(!n)return!1;const[,s]=n;if(!s)return!1;const a=parseInt(s,10),r=`house-${String(a-1).padStart(2,"0")}`;return e.flags[r]===!0}function As(e,t,n,s){const a=V(e,n,s);if(s!==!0)return{story:a,team:t,djinnGranted:null};const r=Ke[n];if(!r)return{story:a,team:t,djinnGranted:null};const u=xn(t,r);return u.ok?{story:a,team:u.value,djinnGranted:r}:{story:a,team:t,djinnGranted:null}}function xs(e,t,n,s=1){const a=V(e,t,n),r=We[t];if(!r)return{story:a,recruitedUnit:null};const u=Ye[r];if(!u)return console.error(`Unit definition ${r} not found`),{story:a,recruitedUnit:null};const o=Re(u,s,0);return{story:a,recruitedUnit:o}}const Dn={1:0,2:100,3:350,4:850,5:1850,6:3100,7:4700,8:6700,9:9200,10:12300,11:16e3,12:20400,13:25600,14:31700,15:38800,16:47e3,17:56400,18:67100,19:79200,20:92800};function Rn(e){if(e<0)return 1;let t=1,n=20,s=1;for(;t<=n;){const a=Math.floor((t+n)/2),r=Dn[a];if(r===void 0)break;e>=r?(s=a,t=a+1):n=a-1}return s}function Mn(e,t){const n=Math.max(0,e.xp+t),s=e.level,a=Rn(n),r=a>s,u=a<s,o=[];if(r)for(let l=s+1;l<=a;l++){const f=e.abilities.filter(p=>p.unlockLevel===l);o.push(...f.map(p=>p.id))}let c=e.unlockedAbilityIds;return u?c=e.abilities.filter(l=>l.unlockLevel<=a).map(l=>l.id):r&&(c=[...e.unlockedAbilityIds,...o]),{unit:{...e,xp:n,level:a,unlockedAbilityIds:c},leveledUp:r,newLevel:a,unlockedAbilities:o}}function jn(e,t){const n=ke[e];if(!n)throw new Error(`Encounter ${e} not found`);const s=t===4,a=t>0?Math.floor(n.reward.xp/t):0;return{totalXp:n.reward.xp,totalGold:n.reward.gold,xpPerUnit:a,survivorCount:t,allSurvived:s,enemiesDefeated:n.enemies.length,equipmentReward:n.reward.equipment}}function Un(e,t,n){const s=n-t;return{hp:e.growthRates.hp*s,pp:e.growthRates.pp*s,atk:e.growthRates.atk*s,def:e.growthRates.def*s,mag:e.growthRates.mag*s,spd:e.growthRates.spd*s}}function $n(e,t){const n=[],s=[];for(const r of e.units){if(E(r)){s.push(r);continue}if(r.level>=20){s.push(r);continue}const u=r.level,o=Mn(r,t.xpPerUnit),c=o.unit;if(s.push(c),o.leveledUp){const i=Un(c,u,o.newLevel);n.push({unitId:c.id,unitName:c.name,oldLevel:u,newLevel:o.newLevel,statGains:i,newAbilitiesUnlocked:o.unlockedAbilities})}}const a={...e,units:s};return{rewards:t,levelUps:n,goldEarned:t.totalGold,updatedTeam:a}}function Ds(e){const t=dt(e);if(!t)throw new Error("Cannot process victory without encounter ID");const n=e.playerTeam.units.filter(i=>!E(i)),s=jn(t,n.length),a=$n(e.playerTeam,s),r=Pn(s.equipmentReward);let u=a.updatedTeam;const o={...u.djinnTrackers};for(const i in o){const l=o[i];l&&(o[i]={djinnId:l.djinnId,state:"Set",lastActivatedTurn:l.lastActivatedTurn})}return u={...u,djinnTrackers:o},{distribution:{...a,fixedEquipment:r.type==="fixed"?r.equipment:void 0,equipmentChoice:r.type==="choice"?r.options:void 0},updatedTeam:u}}function Pn(e){switch(e.type){case"none":return{type:"none"};case"fixed":{const t=X[e.itemId];if(!t)throw new Error(`Equipment ${e.itemId} not found`);return{type:"fixed",equipment:t}}case"choice":return{type:"choice",options:e.options.map(n=>{const s=X[n];if(!s)throw new Error(`Equipment ${n} not found`);return s})}}}function Nn(e,t){const n=t-1;return{hp:e.baseStats.hp+n*e.growthRates.hp,pp:e.baseStats.pp+n*e.growthRates.pp,atk:e.baseStats.atk+n*e.growthRates.atk,def:e.baseStats.def+n*e.growthRates.def,mag:e.baseStats.mag+n*e.growthRates.mag,spd:e.baseStats.spd+n*e.growthRates.spd}}function Rs(e,t=2,n=60,s=19,a={}){const r=Nn(e,t),u=a.stats?{...r,...a.stats}:r,o=e.abilities.filter(i=>t>=(i.unlockLevel??1)),c=o.length>0?o:[e.abilities[0]];return{id:a.id??`${e.id}-enemy`,name:e.name,level:t,element:e.element,stats:u,abilities:c,baseXp:n,baseGold:s}}function Cn(e,t){const n={id:e.id,name:e.name,element:e.element,role:"Pure DPS",baseStats:e.stats,growthRates:{hp:0,pp:0,atk:0,def:0,mag:0,spd:0},abilities:e.abilities,manaContribution:0,description:`A ${e.name} enemy`,autoAttackTiming:"same-turn"};return Re(n,e.level,0)}function qn(e){return ke[e]||null}function Ms(e,t,n){const s=qn(e);if(!s)return null;const a=s.enemies.map((o,c)=>{const i=Qe[o];if(!i)return console.error(`Enemy not found: ${o}`),null;const l=Cn(i);return{...l,id:`${l.id}_${c}`}}).filter(o=>o!==null);if(a.length===0)return console.error(`No valid enemies found for encounter: ${e}`),null;const r=Dt(t,a,n);return r.ok?{battle:{...r.value,encounterId:s.id,meta:{encounterId:s.id,difficulty:s.difficulty==="boss"?"boss":"normal"},isBossBattle:s.difficulty==="boss"},encounter:s}:(console.error(`Failed to start battle: ${r.error}`),null)}function _n(e,t){const n=t.x>=0&&t.x<e.width,s=t.y>=0&&t.y<e.height;if(!n||!s)return;const a=e.tiles[t.y];if(a)return a[t.x]}function Hn(e,t){const n=_n(e,t);return!(!n||!n.walkable||e.npcs.find(a=>a.position.x===t.x&&a.position.y===t.y)&&!e.triggers.some(r=>r.type==="npc"&&r.position.x===t.x&&r.position.y===t.y))}function Fn(e,t){return e.triggers.find(n=>n.position.x===t.x&&n.position.y===t.y)}function js(e,t,n){const s={up:{x:0,y:-1},down:{x:0,y:1},left:{x:-1,y:0},right:{x:1,y:0}},a={x:t.x+s[n].x,y:t.y+s[n].y};if(!Hn(e,a))return{newPos:t,blocked:!0};const r=Fn(e,a);return{newPos:a,blocked:!1,trigger:r}}function Us(e){return{treeId:e.id,currentNodeId:e.startNodeId,history:[e.startNodeId],variables:{}}}function Ge(e,t){return e.nodes.find(n=>n.id===t.currentNodeId)}function On(e,t){switch(e.type){case"flag":return t.flags[e.key]===e.value;case"item":return t.inventory.items.includes(e.key);case"gold":return e.operator==="greaterThan"?t.gold>e.value:e.operator==="lessThan"?t.gold<e.value:t.gold===e.value;case"level":return e.operator==="greaterThan"?t.level>e.value:e.operator==="lessThan"?t.level<e.value:t.level===e.value;default:return!1}}function $s(e,t){return e.choices?e.choices.filter(n=>n.condition?On(n.condition,t):!0):[]}function Ps(e,t,n){const s=Ge(e,t);if(!s)return t;const a=s.choices?.find(r=>r.id===n);return a?{...t,currentNodeId:a.nextNodeId,history:[...t.history,a.nextNodeId],variables:a.effects?{...t.variables,...a.effects}:t.variables}:t}function Ns(e,t){const n=Ge(e,t);return!n||n.choices&&n.choices.length>0?null:n.nextNodeId?{...t,currentNodeId:n.nextNodeId,history:[...t.history,n.nextNodeId],variables:n.effects?{...t.variables,...n.effects}:t.variables}:null}function Bn(e,t){return t.allowedElements.includes(e.element)}function Cs(e,t){const n=X[t];return n?e>=n.cost:!1}function qs(e,t){const n=X[t];return n?e<n.cost?T(`Cannot afford ${n.name}. Need ${n.cost}g, have ${e}g`):D({success:!0,newGold:e-n.cost,item:n}):T(`Item ${t} not found`)}function _s(e,t){const n=Je(e);if(t<n.cost)return T(`Insufficient gold. Need ${n.cost}g, have ${t}g`);const s=Object.values(n.equipment),a=[];for(const r of s){const u=X[r];if(!u)return T(`Equipment ${r} not found for ${n.name}`);a.push(u)}return D({newGold:t-n.cost,equipment:a})}function Hs(e,t,n){const s=X[n];return s?Bn(e,s)?t<s.cost?T(`Cannot afford ${s.name}. Need ${s.cost}g, have ${t}g`):D({newGold:t-s.cost,item:s}):T(`${e.name} cannot equip ${s.name}`):T(`Item ${n} not found`)}export{Ns as $,Vn as A,xn as B,ls as C,W as D,In as E,ps as F,kn as G,gs as H,hs as I,ms as J,ds as K,fs as L,bs as M,ks as N,ze as O,As as P,xs as Q,Ze as R,Is as S,V as T,Ds as U,L as V,K as W,Qn as X,Ms as Y,js as Z,ws as _,$t as a,Ps as a0,Us as a1,Es as a2,Fn as a3,ne as a4,Wn as a5,Ae as a6,Nt as a7,Pt as a8,os as a9,Jn as aa,Cs as ab,_s as ac,Hs as ad,qs as ae,ft as af,pt as ag,Kn as ah,Ge as ai,$s as aj,Ce as ak,me as al,Q as am,oe as an,qe as ao,cs as ap,Gn as b,Zn as c,is as d,Xn as e,us as f,dt as g,H as h,j as i,rs as j,ss as k,ns as l,ts as m,E as n,Re as o,Rt as p,as as q,Le as r,es as s,Ts as t,Rs as u,vs as v,Ss as w,ys as x,q as y,Yn as z};
//# sourceMappingURL=core-services-D8JEer3v.js.map
