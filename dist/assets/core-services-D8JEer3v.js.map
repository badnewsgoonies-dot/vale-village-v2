{"version":3,"file":"core-services-D8JEer3v.js","sources":["../../src/core/constants.ts","../../src/core/models/Team.ts","../../src/core/algorithms/djinn.ts","../../src/core/algorithms/djinnAbilities.ts","../../src/core/models/BattleState.ts","../../src/core/models/Unit.ts","../../src/core/models/Equipment.ts","../../src/core/algorithms/stats.ts","../../src/core/algorithms/damage.ts","../../src/core/algorithms/turn-order.ts","../../src/core/algorithms/status.ts","../../src/core/algorithms/targeting.ts","../../src/core/utils/result.ts","../../src/core/services/BattleTransaction.ts","../../src/core/services/BattleService.ts","../../src/core/services/AIService.ts","../../src/core/random/prng.ts","../../src/core/algorithms/mana.ts","../../src/core/services/QueueBattleService.ts","../../src/core/algorithms/healing.ts","../../src/data/schemas/StatsSchema.ts","../../src/data/schemas/ContentAvailabilitySchema.ts","../../src/data/schemas/EquipmentSchema.ts","../../src/data/schemas/AbilitySchema.ts","../../src/data/schemas/UnitSchema.ts","../../src/data/schemas/SaveV1Schema.ts","../../src/data/schemas/TeamSchema.ts","../../src/data/schemas/BattleStateSchema.ts","../../src/core/migrations/index.ts","../../src/core/validation/saveFileValidation.ts","../../src/core/services/SaveService.ts","../../src/core/config/towerConfig.ts","../../src/core/services/TowerService.ts","../../src/core/services/DjinnService.ts","../../src/core/models/story.ts","../../src/core/services/StoryService.ts","../../src/core/algorithms/xp.ts","../../src/core/algorithms/rewards.ts","../../src/core/services/RewardsService.ts","../../src/core/utils/unitToEnemy.ts","../../src/core/utils/enemyToUnit.ts","../../src/core/services/EncounterService.ts","../../src/core/services/OverworldService.ts","../../src/core/services/DialogueService.ts","../../src/core/algorithms/equipment.ts","../../src/core/services/ShopService.ts"],"sourcesContent":["/**\n * Game constants\n * Centralized magic numbers and configuration values\n */\n\n/**\n * Minimum party size - minimum number of units in player team\n */\nexport const MIN_PARTY_SIZE = 1;\n\n/**\n * Maximum party size - maximum number of units in player team\n */\nexport const MAX_PARTY_SIZE = 4;\n\n/**\n * Party size - maximum number of units in player team\n * @deprecated Use MAX_PARTY_SIZE instead. Kept for backward compatibility.\n */\nexport const PARTY_SIZE = MAX_PARTY_SIZE;\n\n/**\n * Maximum queue size (matches party size)\n * @deprecated Use MAX_PARTY_SIZE instead. Kept for backward compatibility.\n */\nexport const MAX_QUEUE_SIZE = MAX_PARTY_SIZE;\n\n/**\n * RNG stream offsets for deterministic battle RNG\n * Each stream is separated by a large offset to prevent collisions\n */\nexport const RNG_STREAMS = {\n  /** Status effects processing (poison, burn, etc.) */\n  STATUS_EFFECTS: 0,\n  /** Player/enemy actions */\n  ACTIONS: 7,\n  /** Victory reward calculation */\n  VICTORY: 999,\n  /** End turn processing */\n  END_TURN: 0,\n  /** Queue battle round execution */\n  QUEUE_ROUND: 1000,\n} as const;\n\n/**\n * Base multiplier for RNG stream separation\n * Ensures streams don't overlap across turns\n */\nexport const RNG_STREAM_BASE_MULTIPLIER = 1_000_000;\n\n/**\n * Battle calculation constants\n */\nexport const BATTLE_CONSTANTS = {\n  /** Revive HP percentage (50% of max HP) */\n  REVIVE_HP_PERCENTAGE: 0.5,\n  /** Base defense multiplier in damage formula (physical) */\n  DEFENSE_MULTIPLIER: 0.5,\n  /** Base defense multiplier for psynergy damage */\n  PSYNERGY_DEFENSE_MULTIPLIER: 0.3,\n  /** Element advantage damage multiplier */\n  ELEMENT_ADVANTAGE_MULTIPLIER: 1.5,\n  /** Element disadvantage damage multiplier */\n  ELEMENT_DISADVANTAGE_MULTIPLIER: 0.67,\n  /** Normal battle equipment drop rate (10%) */\n  EQUIPMENT_DROP_RATE_NORMAL: 0.1,\n  /** Boss battle equipment drop rate (50%) */\n  EQUIPMENT_DROP_RATE_BOSS: 0.5,\n  /** Minimum damage floor (all attacks deal at least this much) */\n  MINIMUM_DAMAGE: 1,\n  /** Minimum healing amount (all heals restore at least this much if basePower > 0) */\n  MINIMUM_HEALING: 1,\n} as const;\n\n/**\n * Create an empty action queue\n * Returns array of nulls with proper type for BattleState\n * @param size - Queue size (defaults to MAX_PARTY_SIZE for backward compatibility)\n */\nexport function createEmptyQueue(size: number = MAX_PARTY_SIZE): readonly null[] {\n  if (size < MIN_PARTY_SIZE || size > MAX_PARTY_SIZE) {\n    throw new Error(`Queue size must be between ${MIN_PARTY_SIZE} and ${MAX_PARTY_SIZE}, got ${size}`);\n  }\n  return Array(size).fill(null) as null[];\n}\n\n/**\n * Create RNG stream for a specific purpose\n * @param rngSeed Base seed for the battle\n * @param turnNumber Current turn/round number\n * @param stream Stream identifier (from RNG_STREAMS or custom offset)\n */\nexport function createRNGStream(\n  rngSeed: number,\n  turnNumber: number,\n  stream: keyof typeof RNG_STREAMS | number\n): number {\n  const offset = typeof stream === 'number' ? stream : RNG_STREAMS[stream];\n  return rngSeed + turnNumber * RNG_STREAM_BASE_MULTIPLIER + offset;\n}\n","/**\n * Team model (POJO)\n * Following ADR 003: Plain objects with readonly properties where possible\n */\n\nimport type { Unit } from './Unit';\nimport { MIN_PARTY_SIZE, MAX_PARTY_SIZE } from '../constants';\n\n/**\n * Djinn tracker for team-wide Djinn system\n */\nexport interface DjinnTracker {\n  readonly djinnId: string;\n  state: 'Set' | 'Standby' | 'Recovery';\n  lastActivatedTurn: number;  // When this Djinn was last activated\n}\n\n/**\n * Team manages party-wide Djinn system\n * From GAME_MECHANICS.md Section 2.0\n *\n * ðŸš¨ CRITICAL: Djinn are TEAM-WIDE, not per-unit!\n * - Team has exactly 3 Djinn slots (global)\n * - Bonuses apply to ALL party members\n * - Activating affects entire team\n */\nexport interface Team {\n  /** 3 Djinn equipped to team slots (affects ALL units) */\n  readonly equippedDjinn: readonly string[];  // Djinn IDs\n\n  /** State and timing of each equipped Djinn (Set/Standby/Recovery) */\n  djinnTrackers: Record<string, DjinnTracker>;  // Plain object instead of Map\n\n  /** Party members (1-4 units) */\n  readonly units: readonly Unit[];\n\n  /** Collected Djinn (up to 12 total) */\n  readonly collectedDjinn: readonly string[];  // Djinn IDs\n\n  /** Current turn in battle (for recovery tracking) */\n  currentTurn: number;\n\n  /** Track which units activated Djinn this turn (unitId â†’ count) */\n  activationsThisTurn: Record<string, number>;  // Plain object instead of Map\n\n  /** DEPRECATED: Old state tracking (for backward compatibility) */\n  djinnStates: Record<string, 'Set' | 'Standby' | 'Recovery'>;  // Plain object instead of Map\n}\n\n/**\n * Create a new team\n */\nexport function createTeam(units: readonly Unit[]): Team {\n  if (units.length < MIN_PARTY_SIZE || units.length > MAX_PARTY_SIZE) {\n    throw new Error(`Team must have between ${MIN_PARTY_SIZE} and ${MAX_PARTY_SIZE} units, got ${units.length}`);\n  }\n\n  return {\n    equippedDjinn: [],\n    djinnTrackers: {},\n    units,\n    collectedDjinn: [],\n    currentTurn: 0,\n    activationsThisTurn: {},\n    djinnStates: {},\n  };\n}\n\n/**\n * Update team (returns new object - immutability)\n * Handles nested objects properly\n * Validates Djinn equipments for duplicates\n * \n * @throws Error if equippedDjinn contains duplicates or exceeds 3 slots\n */\nexport function updateTeam(team: Team, updates: Partial<Team>): Team {\n  // Validate equippedDjinn if being updated\n  if (updates.equippedDjinn !== undefined) {\n    // Check for duplicates\n    const djinnSet = new Set(updates.equippedDjinn);\n    if (djinnSet.size !== updates.equippedDjinn.length) {\n      throw new Error(`Cannot equip duplicate Djinn. Equipped: ${updates.equippedDjinn.join(', ')}`);\n    }\n    \n    // Check max slots (3)\n    if (updates.equippedDjinn.length > 3) {\n      throw new Error(`Cannot equip more than 3 Djinn. Attempted: ${updates.equippedDjinn.length}`);\n    }\n  }\n\n  return {\n    ...team,\n    ...updates,\n    djinnTrackers: updates.djinnTrackers ? { ...team.djinnTrackers, ...updates.djinnTrackers } : team.djinnTrackers,\n    activationsThisTurn: updates.activationsThisTurn ? { ...team.activationsThisTurn, ...updates.activationsThisTurn } : team.activationsThisTurn,\n    djinnStates: updates.djinnStates ? { ...team.djinnStates, ...updates.djinnStates } : team.djinnStates,\n  };\n}\n\n","/**\n * Djinn synergy calculation algorithms\n * Pure functions, deterministic\n * PR-DJINN-CORE: Extended with activation, summon, and recovery logic\n */\n\nimport type { Element } from '../models/types';\nimport type { Team } from '../models/Team';\n\n/**\n * Djinn synergy bonus when multiple Djinn equipped\n * From GAME_MECHANICS.md Section 2.1\n */\nexport interface DjinnSynergy {\n  atk: number;\n  def: number;\n  spd?: number;\n  classChange: string;\n  abilitiesUnlocked: readonly string[];\n}\n\n/**\n * Summon damage values based on number of Djinn activated\n * From QUEUE_BATTLE_SYSTEM_PLAN.md\n */\nexport const DJINN_SUMMON_DAMAGE = {\n  1: 80,   // Individual attack\n  2: 150,  // Medium summon\n  3: 300,  // Mega summon (to all enemies)\n} as const;\n\n/**\n * Calculate Djinn synergy based on elements\n * From GAME_MECHANICS.md Section 2.1\n * ðŸš¨ CRITICAL: Synergy scales with Djinn COUNT!\n */\nexport function calculateDjinnSynergy(djinnElements: readonly Element[]): DjinnSynergy {\n  if (djinnElements.length === 0) {\n    return {\n      atk: 0,\n      def: 0,\n      classChange: 'Base',\n      abilitiesUnlocked: [],\n    };\n  }\n\n  const elementCounts = new Map<Element, number>();\n\n  for (const element of djinnElements) {\n    elementCounts.set(element, (elementCounts.get(element) || 0) + 1);\n  }\n\n  const uniqueElements = elementCounts.size;\n  const maxCount = Math.max(...Array.from(elementCounts.values()));\n  const primaryElement = Array.from(elementCounts.entries())\n    .find(([, count]) => count === maxCount)?.[0];\n\n  // 1 Djinn (any element)\n  if (djinnElements.length === 1) {\n    return {\n      atk: 4,\n      def: 3,\n      classChange: 'Adept',\n      abilitiesUnlocked: [],\n    };\n  }\n\n  // 2 Djinn - Same element\n  if (djinnElements.length === 2 && uniqueElements === 1) {\n    return {\n      atk: 8,\n      def: 5,\n      classChange: `${primaryElement} Warrior`,\n      abilitiesUnlocked: [],\n    };\n  }\n\n  // 2 Djinn - Different elements\n  if (djinnElements.length === 2 && uniqueElements === 2) {\n    return {\n      atk: 5,\n      def: 5,\n      classChange: 'Hybrid',\n      abilitiesUnlocked: [],\n    };\n  }\n\n  // 3 Djinn - All same element\n  if (djinnElements.length === 3 && uniqueElements === 1) {\n    return {\n      atk: 12,\n      def: 8,\n      classChange: `${primaryElement} Adept`,\n      abilitiesUnlocked: [`${primaryElement}-Ultimate`],\n    };\n  }\n\n  // 3 Djinn - 2 same + 1 different\n  if (djinnElements.length === 3 && uniqueElements === 2 && maxCount === 2) {\n    return {\n      atk: 8,\n      def: 6,\n      classChange: `${primaryElement} Knight`,\n      abilitiesUnlocked: ['Hybrid-Spell'],\n    };\n  }\n\n  // 3 Djinn - All different elements\n  return {\n    atk: 4,\n    def: 4,\n    spd: 4,\n    classChange: 'Mystic',\n    abilitiesUnlocked: ['Elemental Harmony'],\n  };\n}\n\n/**\n * Get Set Djinn IDs from team (only Set Djinn contribute to bonuses)\n * PR-DJINN-CORE: Filters Djinn by state\n * \n * @param team - Player's team\n * @returns Array of Djinn IDs that are in 'Set' state\n */\nexport function getSetDjinnIds(team: Team): readonly string[] {\n  return team.equippedDjinn.filter(djinnId => {\n    const tracker = team.djinnTrackers[djinnId];\n    return tracker?.state === 'Set';\n  });\n}\n\n/**\n * Calculate summon damage based on number of Djinn activated\n * PR-DJINN-CORE: Returns damage value for summon\n * \n * @param djinnCount - Number of Djinn activated (1, 2, or 3)\n * @returns Base damage value\n */\nexport function calculateSummonDamage(djinnCount: 1 | 2 | 3): number {\n  return DJINN_SUMMON_DAMAGE[djinnCount];\n}\n\n/**\n * Check if Djinn can be activated (must be in Set state)\n * PR-DJINN-CORE: Validates activation eligibility\n * \n * @param team - Player's team\n * @param djinnId - Djinn ID to check\n * @returns True if Djinn can be activated\n */\nexport function canActivateDjinn(team: Team, djinnId: string): boolean {\n  if (!team.equippedDjinn.includes(djinnId)) {\n    return false; // Not equipped\n  }\n  \n  const tracker = team.djinnTrackers[djinnId];\n  return tracker?.state === 'Set';\n}\n\n/**\n * Get Djinn recovery order from team\n * PR-DJINN-CORE: Returns Djinn IDs that are ready to recover (Standby for 2+ turns)\n * \n * @param team - Player's team\n * @param currentRound - Current round number\n * @returns Array of Djinn IDs ready for recovery\n */\nexport function getDjinnReadyForRecovery(\n  team: Team,\n  currentRound: number\n): readonly string[] {\n  return team.equippedDjinn.filter(djinnId => {\n    const tracker = team.djinnTrackers[djinnId];\n    if (!tracker || tracker.state !== 'Standby') {\n      return false;\n    }\n    \n    // Check if Djinn has been in Standby for 2+ rounds\n    const roundsInStandby = currentRound - (tracker.lastActivatedTurn || 0);\n    return roundsInStandby >= 2;\n  });\n}\n\n","import type { Team } from '../models/Team';\nimport type { Unit } from '../models/Unit';\nimport type { Stats, Element } from '../models/types';\nimport { getSetDjinnIds } from './djinn';\nimport { DJINN } from '../../data/definitions/djinn';\nimport { DJINN_ABILITIES } from '../../data/definitions/djinnAbilities';\n\nexport type ElementCompatibility = 'same' | 'counter' | 'neutral';\n\n/**\n * Element Opposition Pairs (Tetra System)\n * - Venus â†” Jupiter (Earth opposes Wind)\n * - Mars â†” Mercury (Fire opposes Water)\n *\n * Counter Djinn give stat DEBUFF but grant STRONGER abilities (2 skills)\n * Same element gives stat BONUS and 2 skills\n * Neutral (adjacent) gives small bonus and 1 skill\n */\nconst COUNTER_PAIRS: Record<Element, Element> = {\n  Venus: 'Jupiter',   // Earth opposes Wind\n  Jupiter: 'Venus',   // Wind opposes Earth\n  Mars: 'Mercury',    // Fire opposes Water\n  Mercury: 'Mars',    // Water opposes Fire\n  Neutral: 'Neutral',\n};\n\nexport function getElementCompatibility(\n  unitElement: Element,\n  djinnElement: Element\n): ElementCompatibility {\n  if (unitElement === djinnElement) {\n    return 'same';\n  }\n\n  if (COUNTER_PAIRS[unitElement] === djinnElement) {\n    return 'counter';\n  }\n\n  return 'neutral';\n}\n\nexport function calculateDjinnBonusesForUnit(unit: Unit, team: Team): Partial<Stats> {\n  const setDjinnIds = getSetDjinnIds(team);\n  const totals: Partial<Stats> = {};\n\n  for (const djinnId of setDjinnIds) {\n    const djinnElement = getDjinnElementFromId(djinnId);\n    if (!djinnElement) {\n      continue;\n    }\n\n    const compatibility = getElementCompatibility(unit.element, djinnElement);\n    const addStat = (key: keyof Stats, value: number) => {\n      totals[key] = (totals[key] || 0) + value;\n    };\n\n    switch (compatibility) {\n      case 'same':\n        addStat('atk', 4);\n        addStat('def', 3);\n        break;\n      case 'counter':\n        addStat('atk', -3);\n        addStat('def', -2);\n        break;\n      case 'neutral':\n        addStat('atk', 2);\n        addStat('def', 2);\n        break;\n    }\n  }\n\n  return totals;\n}\n\nfunction getDjinnElementFromId(djinnId: string): Element | null {\n  return DJINN[djinnId]?.element ?? null;\n}\n\n/**\n * Get Standby Djinn IDs from team (Djinn that have been activated)\n */\nfunction getStandbyDjinnIds(team: Team): readonly string[] {\n  return team.equippedDjinn.filter(djinnId => {\n    const tracker = team.djinnTrackers[djinnId];\n    return tracker?.state === 'Standby';\n  });\n}\n\nexport function getDjinnGrantedAbilitiesForUnit(unit: Unit, team: Team): string[] {\n  const setDjinnIds = getSetDjinnIds(team);\n  const standbyDjinnIds = getStandbyDjinnIds(team);\n  const granted: string[] = [];\n\n  // Same & Neutral elements: Grant abilities when Djinn is SET\n  for (const djinnId of setDjinnIds) {\n    const djinn = DJINN[djinnId];\n    if (!djinn) continue;\n\n    const compatibility = getElementCompatibility(unit.element, djinn.element);\n    const abilityGroup = djinn.grantedAbilities[unit.id];\n    if (!abilityGroup) continue;\n\n    // Counter abilities are granted on STANDBY, not SET\n    if (compatibility === 'counter') continue;\n\n    let abilitiesToGrant: string[] = [];\n\n    switch (compatibility) {\n      case 'same':\n        // Same element: 2 abilities when SET\n        abilitiesToGrant = abilityGroup.same.slice(0, 2);\n        break;\n      case 'neutral':\n        // Neutral (adjacent) element: 1 ability when SET\n        abilitiesToGrant = abilityGroup.neutral.slice(0, 1);\n        break;\n    }\n\n    granted.push(...abilitiesToGrant);\n  }\n\n  // Counter elements: Grant STRONGER abilities when Djinn is STANDBY (used)\n  // This creates strategic depth - use the Djinn to unlock counter abilities!\n  for (const djinnId of standbyDjinnIds) {\n    const djinn = DJINN[djinnId];\n    if (!djinn) continue;\n\n    const compatibility = getElementCompatibility(unit.element, djinn.element);\n    const abilityGroup = djinn.grantedAbilities[unit.id];\n    if (!abilityGroup) continue;\n\n    // Only counter abilities unlock on Standby\n    if (compatibility !== 'counter') continue;\n\n    // Counter element: 2 STRONGER abilities when STANDBY\n    const abilitiesToGrant = abilityGroup.counter.slice(0, 2);\n    granted.push(...abilitiesToGrant);\n  }\n\n  return [...new Set(granted)];\n}\n\nexport function mergeDjinnAbilitiesIntoUnit(unit: Unit, team: Team): Unit {\n  const abilityIds = getDjinnGrantedAbilitiesForUnit(unit, team);\n  const existingIds = new Set(unit.abilities.map((ability) => ability.id));\n  const baseAbilities = unit.abilities.filter(\n    ability => !DJINN_ABILITIES[ability.id] || abilityIds.includes(ability.id)\n  );\n  const baseUnlocked = unit.unlockedAbilityIds.filter(\n    id => !DJINN_ABILITIES[id] || abilityIds.includes(id)\n  );\n\n  const djinnAbilities = abilityIds\n    .map((id) => DJINN_ABILITIES[id])\n    .filter((ability): ability is typeof DJINN_ABILITIES[string] => ability !== undefined)\n    .filter((ability) => !existingIds.has(ability.id));\n\n  const mergedAbilities = [...baseAbilities, ...djinnAbilities];\n  const mergedUnlocked = Array.from(new Set([...baseUnlocked, ...abilityIds]));\n\n  return {\n    ...unit,\n    abilities: mergedAbilities,\n    unlockedAbilityIds: mergedUnlocked,\n  };\n}\n\nexport interface DjinnAbilityMetadata {\n  abilityId: string;\n  djinnId: string;\n  compatibility: ElementCompatibility;\n}\n\nexport function getDjinnAbilityMetadataForUnit(\n  unit: Unit,\n  team: Team,\n  djinnIds?: readonly string[]\n): DjinnAbilityMetadata[] {\n  const targetDjinn = djinnIds ?? team.equippedDjinn;\n  const seen = new Set<string>();\n  const metadata: DjinnAbilityMetadata[] = [];\n\n  for (const djinnId of targetDjinn) {\n    const djinn = DJINN[djinnId];\n    if (!djinn) continue;\n\n    const abilityGroup = djinn.grantedAbilities[unit.id];\n    if (!abilityGroup) continue;\n\n    const compatibility = getElementCompatibility(unit.element, djinn.element);\n    const abilityList =\n      compatibility === 'same'\n        ? abilityGroup.same\n        : compatibility === 'counter'\n          ? abilityGroup.counter\n          : abilityGroup.neutral;\n\n    for (const abilityId of abilityList) {\n      if (seen.has(abilityId)) continue;\n      seen.add(abilityId);\n      metadata.push({\n        abilityId,\n        djinnId,\n        compatibility,\n      });\n    }\n  }\n\n  return metadata;\n}\n\nexport function getLockedDjinnAbilityMetadataForUnit(unit: Unit, team: Team): DjinnAbilityMetadata[] {\n  const lockedDjinnIds = team.equippedDjinn.filter((djinnId) => {\n    const tracker = team.djinnTrackers[djinnId];\n    return tracker?.state !== 'Set';\n  });\n\n  if (lockedDjinnIds.length === 0) {\n    return [];\n  }\n\n  const lockedSet = new Set(lockedDjinnIds);\n  return getDjinnAbilityMetadataForUnit(unit, team).filter((meta) => lockedSet.has(meta.djinnId));\n}\n","/**\n * BattleState model (POJO)\n * Following ADR 003: Plain objects with readonly properties where possible\n */\n\nimport type { Team } from './Team';\nimport type { Unit } from './Unit';\nimport type { SerializedPRNG } from '../random/prng';\nimport { createEmptyQueue } from '../constants';\nimport { updateTeam } from './Team';\nimport { mergeDjinnAbilitiesIntoUnit } from '../algorithms/djinnAbilities';\n\n/**\n * Battle result types\n */\nexport type BattleResult = 'PLAYER_VICTORY' | 'PLAYER_DEFEAT';\n\n/**\n * Battle status (ongoing or ended)\n */\nexport type BattleStatus = 'ongoing' | BattleResult;\n\n/**\n * Battle phase for queue-based system\n */\nexport type BattlePhase = 'planning' | 'executing' | 'victory' | 'defeat';\n\n/**\n * Queued action for a unit\n */\nexport interface QueuedAction {\n  /** Unit ID that will perform this action */\n  readonly unitId: string;\n  /** Ability ID (null for basic attack) */\n  readonly abilityId: string | null;\n  /** Target unit IDs */\n  readonly targetIds: readonly string[];\n  /** Mana cost of this action */\n  readonly manaCost: number;\n}\n\n/**\n * Unit index for O(1) lookups\n * Maps unit ID -> unit and tracks which side they're on\n */\nexport interface UnitIndex {\n  readonly unit: Unit;\n  readonly isPlayer: boolean;\n}\n\n/**\n * Turn order tracking\n * Manages the sequence of unit actions in battle\n */\nexport interface BattleTurnOrder {\n  /** Turn order (SPD-sorted) - array of unit IDs */\n  readonly turnOrder: readonly string[];\n  /** Index of current acting unit in turnOrder (legacy, for old system compatibility) */\n  currentActorIndex: number;\n}\n\n/**\n * Queue-based battle system state\n * Tracks queued actions and execution progress\n */\nexport interface BattleQueue {\n  /** Which unit we're currently selecting action for (0 to teamSize-1) */\n  currentQueueIndex: number;\n  /** Queued actions for each unit (null if not queued yet). Array length matches team size (1-4) */\n  queuedActions: readonly (QueuedAction | null)[];\n  /** Djinn IDs marked for activation this round */\n  queuedDjinn: readonly string[];\n  /** Index of action currently executing (during execution phase) */\n  executionIndex: number;\n}\n\n/**\n * Battle progress tracking\n * Tracks current phase, status, and turn/round counters\n */\nexport interface BattleProgress {\n  /** Battle phase (planning/executing/victory/defeat) */\n  phase: BattlePhase;\n  /** Battle status (ongoing or result) */\n  status: BattleStatus;\n  /** Current turn number (for Djinn recovery tracking) */\n  currentTurn: number;\n  /** Current round number (increments each planning phase) */\n  roundNumber: number;\n}\n\n/**\n * Battle metadata\n * Context information about the battle encounter\n */\nexport interface BattleMetadata {\n  /** Is this a boss battle? (used for difficulty/rewards/UX) */\n  readonly isBossBattle?: boolean;\n  /** NPC ID that triggered this battle (for post-battle cutscene) */\n  readonly npcId?: string;\n  /**\n   * Encounter ID for story progression\n   * @deprecated Use meta.encounterId instead. This field is kept for backward compatibility.\n   */\n  encounterId?: string;\n  /** Battle metadata */\n  meta?: {\n    /** Canonical encounter ID for story progression */\n    encounterId: string;\n    /** Encounter difficulty tier */\n    difficulty?: 'normal' | 'elite' | 'boss';\n  };\n}\n\n/**\n * Battle state\n * Tracks current battle state including units, turn order, and battle status\n *\n * PR-QUEUE-BATTLE: Extended with queue-based battle system\n * PERFORMANCE: Added unitById index for O(1) lookups\n * REFACTOR: Split into focused sub-interfaces for better organization\n */\nexport interface BattleState extends BattleTurnOrder, BattleQueue, BattleProgress, BattleMetadata {\n  /** Player's team */\n  readonly playerTeam: Team;\n\n  /** Enemy units */\n  readonly enemies: readonly Unit[];\n\n  /**\n   * Unit index for O(1) lookups by ID\n   * PERFORMANCE: Eliminates repeated [...playerTeam.units, ...enemies].find() calls\n   */\n  readonly unitById: ReadonlyMap<string, UnitIndex>;\n\n  /** Battle log (for UI display) */\n  log: readonly string[];\n\n  /** Mana remaining in team pool */\n  remainingMana: number;\n\n  /** Maximum mana pool (sum of all units' manaContribution) */\n  maxMana: number;\n\n  /** Djinn recovery timers: djinnId â†’ turns until recovery */\n  djinnRecoveryTimers: Record<string, number>; // Plain object instead of Map\n\n  /** Optional RNG snapshot for deterministic mid-battle resumes */\n  rngSnapshot?: SerializedPRNG;\n}\n\n/**\n * Build unit index for O(1) lookups\n * PERFORMANCE: Eliminates O(n) array searches\n */\nexport function buildUnitIndex(\n  playerUnits: readonly Unit[],\n  enemyUnits: readonly Unit[]\n): ReadonlyMap<string, UnitIndex> {\n  const index = new Map<string, UnitIndex>();\n\n  for (const unit of playerUnits) {\n    index.set(unit.id, { unit, isPlayer: true });\n  }\n\n  for (const unit of enemyUnits) {\n    index.set(unit.id, { unit, isPlayer: false });\n  }\n\n  return index;\n}\n\n/**\n * Calculate team mana pool from unit contributions\n */\nexport function calculateTeamManaPool(team: Team): number {\n  return team.units.reduce((total, unit) => total + unit.manaContribution, 0);\n}\n\n/**\n * Create initial battle state\n * PR-QUEUE-BATTLE: Initializes queue-based battle system\n * PERFORMANCE: Builds unitById index for O(1) lookups\n */\nexport function createBattleState(\n  playerTeam: Team,\n  enemies: readonly Unit[],\n  turnOrder: readonly string[] = []\n): BattleState {\n  const unitsWithDjinnAbilities = playerTeam.units.map(unit =>\n    mergeDjinnAbilitiesIntoUnit(unit, playerTeam)\n  );\n  const updatedTeam = updateTeam(playerTeam, {\n    units: unitsWithDjinnAbilities,\n  });\n  const maxMana = calculateTeamManaPool(updatedTeam);\n  const unitById = buildUnitIndex(updatedTeam.units, enemies);\n\n  return {\n    playerTeam: updatedTeam,\n    enemies,\n    unitById,\n    currentTurn: 0,\n    roundNumber: 1,\n    phase: 'planning',\n    turnOrder: turnOrder.length > 0 ? turnOrder : [],\n    currentActorIndex: 0,\n    status: 'ongoing',\n    log: [],\n    // Queue-based fields\n    currentQueueIndex: 0,\n    queuedActions: createEmptyQueue(playerTeam.units.length),\n    queuedDjinn: [],\n    remainingMana: maxMana,\n    maxMana,\n    executionIndex: 0,\n    djinnRecoveryTimers: {},\n  };\n}\n\n/**\n * Update battle state (returns new object - immutability)\n * PERFORMANCE: Automatically rebuilds unitById index when units change\n * DEV MODE: Validates state invariants to catch impossible states early\n */\nexport function updateBattleState(state: BattleState, updates: Partial<BattleState>): BattleState {\n  const newState = { ...state, ...updates };\n\n  // Rebuild index if units changed\n  if (updates.playerTeam || updates.enemies) {\n    newState.unitById = buildUnitIndex(newState.playerTeam.units, newState.enemies);\n  }\n\n  // Validate invariants in development mode\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Dynamic import to avoid bundling in production\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const { validateBattleState } = require('../validation/battleStateInvariants');\n      validateBattleState(newState);\n    } catch (error) {\n      // Re-throw validation errors\n      if (error instanceof Error && error.name === 'BattleStateInvariantError') {\n        throw error;\n      }\n      // Ignore module loading errors (validation module might not exist in some builds)\n      if (error instanceof Error && !error.message.includes('Cannot find module') && !error.message.includes('require is not defined')) {\n        console.warn('Battle state validation failed:', error);\n      }\n    }\n  }\n\n  return newState;\n}\n\n/**\n * Get encounter ID from battle state\n * Uses canonical meta.encounterId, falls back to deprecated encounterId field\n */\nexport function getEncounterId(battle: BattleState): string | undefined {\n  return battle.meta?.encounterId ?? battle.encounterId;\n}\n","/**\n * Unit model (POJO)\n * Following ADR 003: Plain objects with readonly properties where possible\n */\n\nimport type { Element, Stats, GrowthRates, UnitRole, StatusEffect } from './types';\nimport type { EquipmentLoadout } from './Equipment';\nimport type { Ability } from '../../data/schemas/AbilitySchema';\n\n/**\n * Unit definition (base template - immutable)\n */\nexport interface UnitDefinition {\n  readonly id: string;\n  readonly name: string;\n  readonly element: Element;\n  readonly role: UnitRole;\n  readonly baseStats: Stats;\n  readonly growthRates: GrowthRates;\n  readonly abilities: readonly Ability[];\n  readonly manaContribution: number;  // Base mana circles this unit provides to team pool\n  readonly description: string;\n  readonly autoAttackTiming?: 'same-turn' | 'next-turn';\n}\n\n/**\n * Unit instance - represents a unit in the player's collection or battle\n * Mutable properties are for runtime state (HP, XP, etc.)\n */\nexport interface Unit {\n  // Immutable properties\n  readonly id: string;\n  readonly name: string;\n  readonly element: Element;\n  readonly role: UnitRole;\n  readonly baseStats: Stats;\n  readonly growthRates: GrowthRates;\n  readonly description: string;\n  readonly autoAttackTiming?: 'same-turn' | 'next-turn';\n\n  // Mutable properties (but we create new objects instead of mutating)\n  manaContribution: number;\n  level: number;\n  xp: number;\n  currentHp: number;\n\n  // Equipment and abilities\n  equipment: EquipmentLoadout;\n  djinn: readonly string[];  // Djinn IDs (plain array instead of Djinn objects)\n  djinnStates: Record<string, 'Set' | 'Standby' | 'Recovery'>; // Plain object instead of Map\n  abilities: readonly Ability[];\n  unlockedAbilityIds: readonly string[]; // Array instead of Set\n  storeUnlocked: boolean;\n\n  // Battle state\n  statusEffects: readonly StatusEffect[];\n  actionsTaken: number;\n  battleStats: {\n    damageDealt: number;\n    damageTaken: number;\n  };\n}\n\n/**\n * Calculate max HP for a unit based on level and base stats\n */\nexport function calculateMaxHp(unit: Unit): number {\n  const levelBonus = (unit.level - 1) * unit.growthRates.hp;\n  return unit.baseStats.hp + levelBonus;\n}\n\n/**\n * Check if unit is KO'd\n */\nexport function isUnitKO(unit: Unit): boolean {\n  return unit.currentHp <= 0;\n}\n\n/**\n * Create a new Unit from definition\n */\nexport function createUnit(\n  definition: UnitDefinition,\n  level: number = 1,\n  initialXp: number = 0\n): Unit {\n  const maxHp = definition.baseStats.hp + (level - 1) * definition.growthRates.hp;\n\n  // Auto-unlock abilities based on level\n  const unlockedAbilityIds = definition.abilities\n    .filter(ability => level >= (ability.unlockLevel ?? 1))\n    .map(ability => ability.id);\n\n  return {\n    id: definition.id,\n    name: definition.name,\n    element: definition.element,\n    role: definition.role,\n    baseStats: definition.baseStats,\n    growthRates: definition.growthRates,\n    description: definition.description,\n    autoAttackTiming: definition.autoAttackTiming ?? 'same-turn',\n    manaContribution: definition.manaContribution,\n    level,\n    xp: initialXp,\n    currentHp: maxHp,\n    equipment: {\n      weapon: null,\n      armor: null,\n      helm: null,\n      boots: null,\n      accessory: null,\n    },\n    storeUnlocked: false,\n    djinn: [],\n    djinnStates: {},\n    abilities: definition.abilities,\n    unlockedAbilityIds,\n    statusEffects: [],\n    actionsTaken: 0,\n    battleStats: {\n      damageDealt: 0,\n      damageTaken: 0,\n    },\n  };\n}\n\n/**\n * Update unit (returns new object - immutability)\n * Handles nested objects properly\n */\nexport function updateUnit(unit: Unit, updates: Partial<Unit>): Unit {\n  return {\n    ...unit,\n    ...updates,\n    equipment: updates.equipment ? { ...unit.equipment, ...updates.equipment } : unit.equipment,\n    battleStats: updates.battleStats ? { ...unit.battleStats, ...updates.battleStats } : unit.battleStats,\n  };\n}\n","/**\n * Equipment model (POJO)\n * Following ADR 003: Plain objects with readonly properties\n * REFACTORED: Element-based equipment restrictions (allowedElements, not allowedUnits)\n */\n\nimport type { Stats, Element } from './types';\n\n/**\n * Equipment slots\n */\nexport type EquipmentSlot = 'weapon' | 'armor' | 'helm' | 'boots' | 'accessory';\n\n/**\n * Equipment tiers\n */\nexport type EquipmentTier = 'basic' | 'bronze' | 'iron' | 'steel' | 'silver' | 'mythril' | 'legendary' | 'artifact';\n\n/**\n * Equipment item definition\n * REFACTORED: allowedUnits â†’ allowedElements (element-based restrictions)\n */\nexport interface Equipment {\n  readonly id: string;\n  readonly name: string;\n  readonly slot: EquipmentSlot;\n  readonly tier: EquipmentTier;\n  readonly cost: number;\n  readonly allowedElements: readonly Element[]; // CHANGED: Element-based restrictions\n\n  // Stat bonuses\n  readonly statBonus: Partial<Stats>;\n\n  // Special properties\n  readonly unlocksAbility?: string;      // Legendary equipment unlocks abilities\n  readonly elementalResist?: number;     // e.g., 0.2 = 20% reduction\n  readonly alwaysFirstTurn?: boolean;    // Hermes' Sandals property\n}\n\n/**\n * Equipment loadout for a unit (5 slots)\n */\nexport interface EquipmentLoadout {\n  weapon: Equipment | null;\n  armor: Equipment | null;\n  helm: Equipment | null;\n  boots: Equipment | null;\n  accessory: Equipment | null;\n}\n\n/**\n * Create empty equipment loadout\n */\nexport function createEmptyLoadout(): EquipmentLoadout {\n  return {\n    weapon: null,\n    armor: null,\n    helm: null,\n    boots: null,\n    accessory: null,\n  };\n}\n\n/**\n * Calculate total stat bonuses from equipment\n */\nexport function calculateEquipmentBonuses(loadout: EquipmentLoadout): Partial<Stats> {\n  const totals: Partial<Record<keyof Stats, number>> = {};\n\n  for (const item of Object.values(loadout)) {\n    if (!item) continue;\n\n    for (const stat of Object.keys(item.statBonus) as Array<keyof Stats>) {\n      const value = item.statBonus[stat];\n      if (value !== undefined && value !== null && typeof value === 'number') {\n        totals[stat] = (totals[stat] ?? 0) + value;\n      }\n    }\n  }\n\n  return totals;\n}\n","/**\n * Effective Stats Pipeline\n * PR-STATS-EFFECTIVE: Calculate effective stats combining base + level + equipment + Djinn + status\n * \n * All functions are pure and deterministic (no RNG, no side effects)\n */\n\nimport type { Unit } from '../models/Unit';\nimport type { Team } from '../models/Team';\nimport type { Stats } from '../models/types';\nimport { calculateEquipmentBonuses } from '../models/Equipment';\nimport { calculateDjinnBonusesForUnit } from './djinnAbilities';\n\n/**\n * Calculate level-based stat bonuses\n * Stats increase by growthRates per level above 1\n * \n * @param unit - Unit to calculate bonuses for\n * @returns Partial stats with level bonuses\n */\nexport function calculateLevelBonuses(unit: Unit): Partial<Stats> {\n  const levelBonus = unit.level - 1; // Level 1 = 0 bonus, Level 20 = 19 bonuses\n  \n  return {\n    hp: levelBonus * unit.growthRates.hp,\n    pp: levelBonus * unit.growthRates.pp,\n    atk: levelBonus * unit.growthRates.atk,\n    def: levelBonus * unit.growthRates.def,\n    mag: levelBonus * unit.growthRates.mag,\n    spd: levelBonus * unit.growthRates.spd,\n  };\n}\n\n\n\n/**\n * Calculate status effect stat modifiers\n * Sums all buff/debuff stat deltas\n * Clamps to prevent negative stats\n * \n * @param unit - Unit with status effects\n * @returns Partial stats with status modifiers\n */\nexport function calculateStatusModifiers(unit: Unit): Partial<Stats> {\n  const modifiers: Partial<Stats> = {};\n  \n  for (const status of unit.statusEffects) {\n    if (status.type === 'buff' || status.type === 'debuff') {\n      const statKey = status.stat;\n      const modifier = status.modifier;\n      \n      // Only process if stat and modifier are defined\n      if (statKey && modifier !== undefined) {\n        // Sum modifiers (buffs are positive, debuffs are negative)\n        const current = modifiers[statKey] ?? 0;\n        modifiers[statKey] = current + modifier;\n      }\n    }\n  }\n  \n  return modifiers;\n}\n\n/**\n * Calculate effective stats for a unit\n * Combines: base + level + equipment + Djinn + status\n * Rounds to integers to avoid floating-point differences\n * \n * @param unit - Unit to calculate effective stats for\n * @param team - Team (for Djinn bonuses)\n * @returns Complete effective stats\n */\nexport function calculateEffectiveStats(unit: Unit, team: Team): Stats {\n  const base = unit.baseStats;\n  const level = calculateLevelBonuses(unit);\n  const equipment = calculateEquipmentBonuses(unit.equipment);\n  const djinn = calculateDjinnBonusesForUnit(unit, team);\n  const status = calculateStatusModifiers(unit);\n  \n  // Combine all bonuses\n  const effective: Stats = {\n    hp: Math.max(1, Math.floor(base.hp + (level.hp ?? 0) + (equipment.hp ?? 0) + (status.hp ?? 0))),\n    pp: Math.max(0, Math.floor(base.pp + (level.pp ?? 0) + (equipment.pp ?? 0) + (status.pp ?? 0))),\n    atk: Math.max(1, Math.floor(base.atk + (level.atk ?? 0) + (equipment.atk ?? 0) + (djinn.atk ?? 0) + (status.atk ?? 0))),\n    def: Math.max(0, Math.floor(base.def + (level.def ?? 0) + (equipment.def ?? 0) + (djinn.def ?? 0) + (status.def ?? 0))),\n    mag: Math.max(1, Math.floor(base.mag + (level.mag ?? 0) + (equipment.mag ?? 0) + (djinn.mag ?? 0) + (status.mag ?? 0))),\n    spd: Math.max(1, Math.floor(base.spd + (level.spd ?? 0) + (equipment.spd ?? 0) + (djinn.spd ?? 0) + (status.spd ?? 0))),\n  };\n  \n  return effective;\n}\n\n/**\n * Get effective SPD for a unit\n * Convenience wrapper for turn order calculations\n * \n * @param unit - Unit to get effective SPD for\n * @param team - Team (for Djinn bonuses)\n * @returns Effective SPD value\n */\nexport function getEffectiveSPD(unit: Unit, team: Team): number {\n  const effective = calculateEffectiveStats(unit, team);\n  return effective.spd;\n}\n","/**\n * Damage calculation algorithms\n * Pure functions, deterministic with PRNG\n */\n\nimport type { Unit } from '../models/Unit';\nimport type { Team } from '../models/Team';\nimport type { Ability } from '../../data/schemas/AbilitySchema';\nimport type { Element } from '../models/types';\nimport { calculateMaxHp, isUnitKO } from '../models/Unit';\nimport { calculateEffectiveStats } from './stats';\nimport { BATTLE_CONSTANTS } from '../constants';\n\n/**\n * Element advantage triangle (from GAME_MECHANICS.md Section 5.2)\n * - Venus â†’ Jupiter (Earth strong vs Wind)\n * - Mars â†’ Venus (Fire strong vs Earth)\n * - Mercury â†’ Mars (Water strong vs Fire)\n * - Jupiter â†’ Mercury (Wind strong vs Water)\n */\nconst ELEMENT_ADVANTAGE: Record<string, boolean> = {\n  'Venusâ†’Jupiter': true,\n  'Marsâ†’Venus': true,\n  'Mercuryâ†’Mars': true,\n  'Jupiterâ†’Mercury': true,\n};\n\n/**\n * Get element modifier for attack\n * Returns 1.5 for advantage, 0.67 for disadvantage, 1.0 for neutral\n */\nexport function getElementModifier(attackElement: Element, defenseElement: Element): number {\n  const key = `${attackElement}â†’${defenseElement}`;\n  if (ELEMENT_ADVANTAGE[key]) {\n    return BATTLE_CONSTANTS.ELEMENT_ADVANTAGE_MULTIPLIER; // +50% damage\n  }\n\n  const reverseKey = `${defenseElement}â†’${attackElement}`;\n  if (ELEMENT_ADVANTAGE[reverseKey]) {\n    return BATTLE_CONSTANTS.ELEMENT_DISADVANTAGE_MULTIPLIER; // -33% damage\n  }\n\n  return 1.0; // Neutral\n}\n\n/**\n * Phase 2: Apply damage modifiers from status effects\n * - Elemental resistance/weakness (from status effects)\n * - Damage reduction (global, from status effects)\n *\n * Applied AFTER elemental advantage but BEFORE minimum damage clamping\n *\n * @param baseDamage - Damage before modifiers\n * @param abilityElement - Element of the attack (undefined for physical/neutral)\n * @param defender - Target unit with status effects\n * @returns Modified damage\n */\nexport function applyDamageModifiers(\n  baseDamage: number,\n  abilityElement: Element | undefined,\n  defender: Unit\n): number {\n  let modifiedDamage = baseDamage;\n\n  // 1. Apply elemental resistance/weakness from status effects\n  if (abilityElement && abilityElement !== 'Neutral') {\n    const resistanceEffects = defender.statusEffects.filter(\n      effect => effect.type === 'elementalResistance' && effect.element === abilityElement\n    ) as Array<Extract<typeof defender.statusEffects[number], { type: 'elementalResistance' }>>;\n\n    const resistanceModifiers = resistanceEffects.map(effect => effect.modifier);\n\n    const totalResistModifier = resistanceModifiers.reduce((sum, mod) => sum + mod, 0);\n\n    // Convention: factor = 1 - modifier\n    // modifier > 0 = resistance (reduces damage)\n    // modifier < 0 = weakness (increases damage)\n    // Example: 0.4 resist â†’ factor 0.6 â†’ damage Ã— 0.6\n    // Example: -0.2 weakness â†’ factor 1.2 â†’ damage Ã— 1.2\n    const resistanceFactor = 1 - totalResistModifier;\n    modifiedDamage *= resistanceFactor;\n  }\n\n  // 2. Apply damage reduction from status effects\n  const damageReductionEffects = defender.statusEffects.filter(\n    effect => effect.type === 'damageReduction'\n  ) as Array<Extract<typeof defender.statusEffects[number], { type: 'damageReduction' }>>;\n\n  const damageReductionPercents = damageReductionEffects.map(effect => effect.percent);\n\n  const totalDamageReduction = damageReductionPercents.reduce((sum, pct) => sum + pct, 0);\n  // Clamp to [0, 1] to prevent negative damage or > 100% reduction\n  const clampedReduction = Math.min(1, Math.max(0, totalDamageReduction));\n\n  // Damage reduction: reduce by percentage (e.g., 0.3 = 30% reduction â†’ Ã— 0.7)\n  modifiedDamage *= (1 - clampedReduction);\n\n  return modifiedDamage;\n}\n\n/**\n * Calculate physical damage\n * From GAME_MECHANICS.md Section 5.2\n * Formula: basePower + effective ATK - (effective DEF Ã— 0.5)\n * Always returns at least 1 damage\n * Uses effective stats (base + level + equipment + Djinn + status)\n *\n * Phase 2: Supports ignore defense percentage\n */\nexport function calculatePhysicalDamage(\n  attacker: Unit,\n  defender: Unit,\n  team: Team,\n  ability: Ability\n): number {\n  const attackerEffective = calculateEffectiveStats(attacker, team);\n  const defenderEffective = calculateEffectiveStats(defender, team);\n\n  const baseDamage = ability.basePower > 0 ? ability.basePower : attackerEffective.atk;\n  const attackPower = attackerEffective.atk;\n\n  // Phase 2: Apply ignore defense percentage (clamp to [0, 1] for safety)\n  const ignoreDefensePercent = Math.min(1, Math.max(0, ability.ignoreDefensePercent || 0));\n  const effectiveDefense = defenderEffective.def * (1 - ignoreDefensePercent);\n\n  const rawDamage = baseDamage + attackPower - (effectiveDefense * BATTLE_CONSTANTS.DEFENSE_MULTIPLIER);\n\n  // Phase 2: Apply damage modifiers from status effects (elemental resist, damage reduction)\n  const modifiedDamage = applyDamageModifiers(rawDamage, ability.element, defender);\n\n  const damage = Math.max(BATTLE_CONSTANTS.MINIMUM_DAMAGE, Math.floor(modifiedDamage));\n\n  return damage;\n}\n\n/**\n * Calculate Psynergy (magic) damage\n * From GAME_MECHANICS.md Section 5.2\n * Formula: (basePower + effective MAG - (effective DEF Ã— 0.3)) Ã— elementModifier\n * Always returns at least 1 damage\n * Uses effective stats (base + level + equipment + Djinn + status)\n *\n * Phase 2: Supports ignore defense percentage, applies damage modifiers from status effects\n */\nexport function calculatePsynergyDamage(\n  attacker: Unit,\n  defender: Unit,\n  team: Team,\n  ability: Ability\n): number {\n  const attackerEffective = calculateEffectiveStats(attacker, team);\n  const defenderEffective = calculateEffectiveStats(defender, team);\n\n  const basePower = ability.basePower || 0;\n  const magicPower = attackerEffective.mag;\n\n  // Phase 2: Apply ignore defense percentage (clamp to [0, 1] for safety)\n  const ignoreDefensePercent = Math.min(1, Math.max(0, ability.ignoreDefensePercent || 0));\n  const effectiveDefense = defenderEffective.def * (1 - ignoreDefensePercent);\n  const magicDefense = effectiveDefense * BATTLE_CONSTANTS.PSYNERGY_DEFENSE_MULTIPLIER;\n\n  // Element advantage/disadvantage (1.5x / 0.67x / 1.0x)\n  const elementModifier = ability.element\n    ? getElementModifier(ability.element, defender.element)\n    : 1.0;\n\n  let rawDamage = (basePower + magicPower - magicDefense) * elementModifier;\n\n  // Apply elemental resist from armor (e.g., Dragon Scales)\n  const resist = defender.equipment.armor?.elementalResist || 0;\n  if (ability.element && resist > 0) {\n    rawDamage = rawDamage * (1 - resist);\n  }\n\n  // Phase 2: Apply damage modifiers from status effects (elemental resist, damage reduction)\n  const modifiedDamage = applyDamageModifiers(rawDamage, ability.element, defender);\n\n  const damage = Math.max(BATTLE_CONSTANTS.MINIMUM_DAMAGE, Math.floor(modifiedDamage));\n\n  return damage;\n}\n\n/**\n * Calculate healing amount\n * From GAME_MECHANICS.md Section 5.2\n * Formula: basePower + effective MAG\n * Always returns at least 1 healing (if basePower > 0)\n * Uses effective MAG (base + level + equipment + Djinn + status)\n */\nexport function calculateHealAmount(\n  caster: Unit,\n  team: Team,\n  ability: Ability\n): number {\n  const baseHeal = ability.basePower || 0;\n\n  // Validate healing abilities have non-negative power\n  if (baseHeal < 0) {\n    return 0; // Clamp to 0\n  }\n\n  if (baseHeal === 0) {\n    return 0; // No healing if base power is 0\n  }\n\n  const casterEffective = calculateEffectiveStats(caster, team);\n  const magicPower = casterEffective.mag;\n\n  const rawHeal = baseHeal + magicPower;\n  const healAmount = Math.max(BATTLE_CONSTANTS.MINIMUM_HEALING, Math.floor(rawHeal));\n\n  return healAmount;\n}\n\n/**\n * Phase 2: Check if unit is invulnerable (blocks ALL damage)\n */\nexport function isInvulnerable(unit: Unit): boolean {\n  return unit.statusEffects.some(effect => effect.type === 'invulnerable');\n}\n\n/**\n * Phase 2: Check if unit has active shield charges\n */\nexport function hasShieldCharges(unit: Unit): boolean {\n  return unit.statusEffects.some(\n    effect => effect.type === 'shield' && effect.remainingCharges > 0\n  );\n}\n\n/**\n * Phase 2: Consume one shield charge from unit\n * Returns updated unit with ONE shield charge consumed (from first available shield)\n * Removes shield status if charges reach 0\n */\nexport function consumeShieldCharge(unit: Unit): Unit {\n  let chargeConsumed = false;\n\n  const updatedStatusEffects = unit.statusEffects\n    .map(effect => {\n      // Only consume from the FIRST shield with charges remaining\n      if (effect.type === 'shield' && effect.remainingCharges > 0 && !chargeConsumed) {\n        chargeConsumed = true;\n        return { ...effect, remainingCharges: effect.remainingCharges - 1 };\n      }\n      return effect;\n    })\n    .filter(effect => {\n      // Remove shield if charges depleted OR already at 0 (cleanup)\n      return !(effect.type === 'shield' && effect.remainingCharges === 0);\n    });\n\n  return {\n    ...unit,\n    statusEffects: updatedStatusEffects,\n  };\n}\n\n/**\n * Apply damage to unit (returns new unit with updated HP)\n * Clamps HP to [0, maxHp]\n *\n * Phase 2: Supports invulnerability and shield blocking\n * NOTE: Shield/invuln logic should be checked BEFORE calling this function\n * This function always applies the damage amount passed to it\n */\nexport function applyDamage(unit: Unit, damage: number): Unit {\n  const maxHp = calculateMaxHp(unit);\n  const newHp = Math.max(0, Math.min(maxHp, unit.currentHp - damage));\n\n  return {\n    ...unit,\n    currentHp: newHp,\n    battleStats: {\n      ...unit.battleStats,\n      damageTaken: unit.battleStats.damageTaken + damage,\n    },\n  };\n}\n\n/**\n * Phase 2: Apply damage with shield/invulnerability checks and auto-revive\n * This is the main entry point for damage application in battle\n *\n * Ordering:\n * 1. Check invulnerability (blocks damage, does NOT consume shield)\n * 2. Check shield (blocks damage, consumes 1 charge)\n * 3. Apply damage if not blocked\n * 4. Check for auto-revive if unit is KO'd\n *\n * @returns Object with updated unit, actual damage dealt (0 if blocked), and whether auto-revive triggered\n */\nexport function applyDamageWithShields(\n  unit: Unit,\n  damage: number\n): { updatedUnit: Unit; actualDamage: number; autoRevived?: boolean } {\n  // 0. Zero damage doesn't consume shields or trigger any mechanics\n  if (damage <= 0) {\n    return { updatedUnit: unit, actualDamage: 0 };\n  }\n\n  // 1. Invulnerability blocks all damage (no shield consumption)\n  if (isInvulnerable(unit)) {\n    return { updatedUnit: unit, actualDamage: 0 };\n  }\n\n  // 2. Shield blocks damage and consumes 1 charge\n  if (hasShieldCharges(unit)) {\n    const updatedUnit = consumeShieldCharge(unit);\n    return { updatedUnit, actualDamage: 0 };\n  }\n\n  // 3. No blocking - apply damage normally\n  let updatedUnit = applyDamage(unit, damage);\n\n  // Clean up any shields with 0 charges\n  updatedUnit = {\n    ...updatedUnit,\n    statusEffects: updatedUnit.statusEffects.filter(\n      effect => !(effect.type === 'shield' && effect.remainingCharges === 0)\n    ),\n  };\n\n  // 4. Check for auto-revive if unit is KO'd\n  const { updatedUnit: finalUnit, revived } = checkAutoRevive(updatedUnit);\n\n  return revived\n    ? { updatedUnit: finalUnit, actualDamage: damage, autoRevived: true }\n    : { updatedUnit: finalUnit, actualDamage: damage };\n}\n\n/**\n * Phase 2: Check for and trigger auto-revive if unit is KO'd\n * Returns updated unit with auto-revive triggered (if applicable)\n *\n * @param unit - Unit to check for auto-revive\n * @returns Object with updated unit and whether auto-revive was triggered\n */\nexport function checkAutoRevive(unit: Unit): { updatedUnit: Unit; revived: boolean } {\n  // Only trigger if unit is KO'd\n  if (unit.currentHp > 0) {\n    // Clean up exhausted auto-revive statuses even if unit isn't KO'd\n    const hasExhaustedAutoRevive = unit.statusEffects.some(\n      effect => effect.type === 'autoRevive' && effect.usesRemaining === 0\n    );\n    if (hasExhaustedAutoRevive) {\n      const cleanedStatusEffects = unit.statusEffects.filter(\n        effect => !(effect.type === 'autoRevive' && effect.usesRemaining === 0)\n      );\n      return { updatedUnit: { ...unit, statusEffects: cleanedStatusEffects }, revived: false };\n    }\n    return { updatedUnit: unit, revived: false };\n  }\n\n  // Find auto-revive status with uses remaining\n  const autoReviveEffects = unit.statusEffects.filter(\n    effect => effect.type === 'autoRevive' && effect.usesRemaining > 0\n  ) as Array<Extract<typeof unit.statusEffects[number], { type: 'autoRevive' }>>;\n\n  const autoReviveStatus = autoReviveEffects[0];\n\n  if (!autoReviveStatus) {\n    // Clean up exhausted auto-revive statuses even if none can trigger\n    const hasExhaustedAutoRevive = unit.statusEffects.some(\n      effect => effect.type === 'autoRevive' && effect.usesRemaining === 0\n    );\n    if (hasExhaustedAutoRevive) {\n      const cleanedStatusEffects = unit.statusEffects.filter(\n        effect => !(effect.type === 'autoRevive' && effect.usesRemaining === 0)\n      );\n      return { updatedUnit: { ...unit, statusEffects: cleanedStatusEffects }, revived: false };\n    }\n    return { updatedUnit: unit, revived: false };\n  }\n\n  // Calculate revive HP\n  const maxHp = calculateMaxHp(unit);\n  const reviveHp = Math.floor(maxHp * autoReviveStatus.hpPercent);\n\n  // Decrement uses only for the first auto-revive status that triggered\n  // Other auto-revive statuses remain unchanged\n  let foundFirst = false;\n  const updatedStatusEffects = unit.statusEffects\n    .map(effect => {\n      // Only decrement the first auto-revive status with uses remaining\n      if (effect.type === 'autoRevive' && effect.usesRemaining > 0 && !foundFirst) {\n        foundFirst = true;\n        return { ...effect, usesRemaining: effect.usesRemaining - 1 };\n      }\n      return effect;\n    })\n    .filter(effect => {\n      // Remove auto-revive if uses depleted (only the one we decremented)\n      return !(effect.type === 'autoRevive' && effect.usesRemaining === 0);\n    });\n\n  const revivedUnit: Unit = {\n    ...unit,\n    currentHp: reviveHp,\n    statusEffects: updatedStatusEffects,\n  };\n\n  return { updatedUnit: revivedUnit, revived: true };\n}\n\n/**\n * Apply healing to unit (returns new unit with updated HP)\n * Clamps HP to [0, maxHp]\n * Never exceeds max HP\n * \n * @param unit - Unit to heal\n * @param healing - Amount to heal (must be non-negative)\n * @param abilityRevivesFallen - Whether the ability can revive fallen units (default: false)\n * @returns New unit with updated HP, or throws error if invalid\n * @throws Error if healing is negative or unit is KO'd without revivesFallen\n */\nexport function applyHealing(unit: Unit, healing: number, abilityRevivesFallen: boolean = false): Unit {\n  // Validate healing amount is non-negative\n  if (healing < 0) {\n    throw new Error(`Cannot apply negative healing: ${healing}`);\n  }\n\n  // Check if unit is KO'd and ability cannot revive\n  if (isUnitKO(unit) && !abilityRevivesFallen) {\n    throw new Error(`Cannot heal KO'd unit without revivesFallen ability`);\n  }\n\n  const maxHp = calculateMaxHp(unit);\n  const newHp = Math.min(maxHp, Math.max(0, unit.currentHp + healing)); // Clamp to [0, maxHp]\n  \n  return {\n    ...unit,\n    currentHp: newHp,\n  };\n}\n","/**\n * Turn order calculation algorithms\n * Pure functions, deterministic with PRNG\n */\n\nimport type { Unit } from '../models/Unit';\nimport type { Team } from '../models/Team';\nimport type { PRNG } from '../random/prng';\nimport { isUnitKO } from '../models/Unit';\nimport { getEffectiveSPD } from './stats';\n\n/**\n * Calculate turn order based on effective SPD stat\n * From GAME_MECHANICS.md Section 6.1\n * Orders by: priority tier (Hermes) > effective SPD > tiebreaker\n * Deterministic tiebreaker using turn number for stability\n * Returns array of unit IDs in turn order\n * \n * @param units - All units (player + enemies)\n * @param team - Player team (for Djinn bonuses)\n * @param rng - PRNG for deterministic tie-breaking\n * @param turnNumber - Current turn number for stable tie-breaking\n */\nexport function calculateTurnOrder(\n  units: readonly Unit[],\n  team: Team,\n  rng: PRNG,\n  turnNumber: number = 0\n): readonly string[] {\n  // Filter out KO'd units\n  const aliveUnits = units.filter(u => !isUnitKO(u));\n\n  // Separate by priority tier (Hermes' Sandals = priority 1, others = priority 0)\n  const priorityUnits = aliveUnits.filter(u =>\n    u.equipment.boots?.alwaysFirstTurn === true\n  );\n\n  const regularUnits = aliveUnits.filter(u =>\n    u.equipment.boots?.alwaysFirstTurn !== true\n  );\n\n  // Create deterministic tiebreaker RNG using turn number\n  // Consume turnNumber values from RNG to create stable tiebreaker\n  const tieRng = rng.clone();\n  for (let i = 0; i < turnNumber; i++) {\n    tieRng.next(); // Advance for determinism\n  }\n\n  // Sort priority units: priority desc â†’ effective SPD desc â†’ stable tiebreak (ID sort then RNG)\n  // Stable ID sort ensures deterministic tiebreaker order\n  // Deterministic comparator: higher SPD â†’ player before enemy â†’ lexicographic unitId\n  const sortedPriority = [...priorityUnits]\n    .sort((a, b) => a.id.localeCompare(b.id)) // Stable sort by ID first\n    .sort((a, b) => {\n      const aSpd = getEffectiveSPD(a, team);\n      const bSpd = getEffectiveSPD(b, team);\n      const spdDiff = bSpd - aSpd;\n      \n      if (spdDiff === 0) {\n        // Same effective SPD: player units before enemies, then lexicographic ID\n        const aIsPlayer = team.units.some(u => u.id === a.id);\n        const bIsPlayer = team.units.some(u => u.id === b.id);\n        \n        if (aIsPlayer !== bIsPlayer) {\n          return aIsPlayer ? -1 : 1; // Player before enemy\n        }\n        \n        // Both same side: stable tiebreaker using deterministic RNG\n        return tieRng.next() - 0.5;\n      }\n      return spdDiff;\n    });\n\n  // Sort regular units: effective SPD desc â†’ stable tiebreak (ID sort then RNG)\n  const sortedRegular = [...regularUnits]\n    .sort((a, b) => a.id.localeCompare(b.id)) // Stable sort by ID first\n    .sort((a, b) => {\n      const aSpd = getEffectiveSPD(a, team);\n      const bSpd = getEffectiveSPD(b, team);\n      const spdDiff = bSpd - aSpd;\n      \n      if (spdDiff === 0) {\n        // Same effective SPD: player units before enemies, then lexicographic ID\n        const aIsPlayer = team.units.some(u => u.id === a.id);\n        const bIsPlayer = team.units.some(u => u.id === b.id);\n        \n        if (aIsPlayer !== bIsPlayer) {\n          return aIsPlayer ? -1 : 1; // Player before enemy\n        }\n        \n        // Both same side: stable tiebreaker using deterministic RNG\n        return tieRng.next() - 0.5;\n      }\n      return spdDiff;\n    });\n\n  // Priority units first, then regular units\n  const allOrdered = [...sortedPriority, ...sortedRegular];\n  return allOrdered.map(u => u.id);\n}\n\n","/**\n * Status effect algorithms\n * Pure functions, deterministic with PRNG\n */\n\nimport type { Unit } from '../models/Unit';\nimport type { PRNG } from '../random/prng';\nimport { applyDamage } from './damage';\n\n/**\n * Process status effect tick at start of unit's turn\n * From GAME_MECHANICS.md Section 5.3\n *\n * Status tick ordering (executed in this order):\n * 1. Duration decay (all effects)\n * 2. Damage-over-time (poison, burn) - applied after decay\n * 3. Heal-over-time - applied after decay\n * 4. Status expiration events emitted for effects that reached duration 0\n *\n * Note: Freeze, Stun, and Paralyze are checked separately before action execution\n * (freeze/stun in isFrozen(), paralyze in checkParalyzeFailure())\n *\n * Poison: 8% max HP damage per turn\n * Burn: 10% max HP damage per turn\n * HealOverTime: Fixed HP heal per turn (specified in effect)\n * Freeze: Skip turn, 30% break chance per turn (checked in isFrozen())\n * Stun: Skip turn completely\n * Paralyze: 25% failure chance (checked in checkParalyzeFailure())\n */\nexport function processStatusEffectTick(\n  unit: Unit,\n  rng: PRNG\n): { updatedUnit: Unit; damage: number; healing: number; messages: readonly string[] } {\n  let totalDamage = 0;\n  let totalHealing = 0;\n  const messages: string[] = [];\n  const maxHp = unit.baseStats.hp + (unit.level - 1) * unit.growthRates.hp;\n\n  const updatedStatusEffects = unit.statusEffects.map(effect => {\n    if (effect.type === 'poison') {\n      const damage = Math.floor(maxHp * 0.08);\n      totalDamage += damage;\n      messages.push(`${unit.name} takes ${damage} poison damage!`);\n      return { ...effect, duration: effect.duration - 1 };\n    } else if (effect.type === 'burn') {\n      const damage = Math.floor(maxHp * 0.10);\n      totalDamage += damage;\n      messages.push(`${unit.name} takes ${damage} burn damage!`);\n      return { ...effect, duration: effect.duration - 1 };\n    } else if (effect.type === 'healOverTime') {\n      const healing = effect.healPerTurn;\n      totalHealing += healing;\n      messages.push(`${unit.name} recovers ${healing} HP!`);\n      return { ...effect, duration: effect.duration - 1 };\n    } else if (effect.type === 'freeze') {\n      const breakChance = 0.3; // 30% chance to break free\n      if (rng.next() < breakChance) {\n        messages.push(`${unit.name} broke free from freeze!`);\n        return { ...effect, duration: 0 }; // Mark for removal\n      } else {\n        messages.push(`${unit.name} is frozen and cannot act!`);\n        return { ...effect, duration: effect.duration - 1 };\n      }\n    } else if (effect.type === 'stun') {\n      messages.push(`${unit.name} is stunned and cannot act!`);\n      return { ...effect, duration: effect.duration - 1 };\n    } else if (effect.type === 'autoRevive') {\n      // Auto-revive is uses-based, not time-based - keep as-is\n      return effect;\n    }\n    // Buff/debuff/paralyze/other duration-based effects - decrement duration\n    if ('duration' in effect) {\n      return { ...effect, duration: effect.duration - 1 };\n    }\n    return effect;\n  }).filter(effect => {\n    // Remove effects with duration <= 0 (skip autoRevive which doesn't have duration)\n    if ('duration' in effect) {\n      return effect.duration > 0;\n    }\n    return true;\n  });\n\n  let modifiedUnit = unit;\n  if (totalDamage > 0) {\n    modifiedUnit = applyDamage(modifiedUnit, totalDamage);\n  }\n  if (totalHealing > 0) {\n    const newHp = Math.min(modifiedUnit.currentHp + totalHealing, maxHp);\n    modifiedUnit = { ...modifiedUnit, currentHp: newHp };\n  }\n\n  const updatedUnit: Unit = {\n    ...modifiedUnit,\n    statusEffects: updatedStatusEffects,\n  };\n\n  return {\n    updatedUnit,\n    damage: totalDamage,\n    healing: totalHealing,\n    messages,\n  };\n}\n\n/**\n * Check if unit's action fails due to paralyze\n * From GAME_MECHANICS.md Section 5.3\n * Paralyze: 25% chance action fails\n */\nexport function checkParalyzeFailure(\n  unit: Unit,\n  rng: PRNG\n): boolean {\n  const paralyzeEffects = unit.statusEffects.filter(\n    e => e.type === 'paralyze'\n  ) as Array<Extract<typeof unit.statusEffects[number], { type: 'paralyze' }>>;\n\n  const paralyzed = paralyzeEffects[0];\n  if (paralyzed && rng.next() < 0.25) {\n    return true; // Action fails (25% chance)\n  }\n  return false;\n}\n\n/**\n * Check if unit is frozen or stunned (cannot act)\n */\nexport function isFrozen(unit: Unit): boolean {\n  return unit.statusEffects.some(e => e.type === 'freeze' || e.type === 'stun');\n}\n\n/**\n * Phase 2: Check if unit is immune to a specific status type\n */\nexport function isImmuneToStatus(unit: Unit, statusType: string): boolean {\n  const immunities = unit.statusEffects.filter(s => s.type === 'immunity');\n\n  // Check if any immunity grants \"all\" protection\n  if (immunities.some(s => s.all)) {\n    return true;\n  }\n\n  // Check if any immunity specifically lists this status type\n  return immunities.some(s => s.types?.some(t => t === statusType));\n}\n\n/**\n * Phase 2: Check if a status effect is negative (can be cleansed)\n * Negative statuses: poison, burn, freeze, paralyze, stun, debuffs\n * NOT negative: buffs, healOverTime, shields, resistance buffs\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isNegativeStatus(status: { type: string; [key: string]: any }): boolean {\n  // Damage-over-time and action-preventing statuses\n  if (['poison', 'burn', 'freeze', 'paralyze', 'stun'].includes(status.type)) {\n    return true;\n  }\n\n  // Debuffs (negative stat modifiers)\n  if (status.type === 'debuff') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Phase 2: Apply a status to a unit (with immunity check)\n * This is the canonical way to add statuses; centralizes immunity logic\n */\nexport function applyStatusToUnit(\n  unit: Unit,\n  newStatus: typeof unit.statusEffects[number]\n): Unit {\n  // Check immunity (immunity statuses themselves always replace existing ones)\n  if (newStatus.type !== 'immunity' && isImmuneToStatus(unit, newStatus.type)) {\n    return unit; // No change\n  }\n\n  // Phase 2: Immunity replacement - if applying a new immunity, remove old immunities\n  let updatedStatusEffects = unit.statusEffects;\n  if (newStatus.type === 'immunity') {\n    // Remove all existing immunity statuses (replacement behavior)\n    updatedStatusEffects = unit.statusEffects.filter(s => s.type !== 'immunity');\n  }\n\n  // Add status to unit\n  return {\n    ...unit,\n    statusEffects: [...updatedStatusEffects, newStatus],\n  };\n}\n","/**\n * Targeting algorithms\n * Resolve target sets for abilities\n * Pure functions, deterministic\n */\n\nimport type { Unit } from '../models/Unit';\nimport type { Ability } from '../../data/schemas/AbilitySchema';\nimport { isUnitKO } from '../models/Unit';\n\n/**\n * Resolve targets for an ability\n * Returns array of units matching the ability's target type\n */\nexport function resolveTargets(\n  ability: Ability,\n  caster: Unit,\n  playerUnits: readonly Unit[],\n  enemyUnits: readonly Unit[]\n): readonly Unit[] {\n  const isPlayerUnit = playerUnits.some(u => u.id === caster.id);\n\n  switch (ability.targets) {\n    case 'single-enemy':\n      return isPlayerUnit\n        ? enemyUnits.filter(u => !isUnitKO(u))\n        : playerUnits.filter(u => !isUnitKO(u));\n\n    case 'all-enemies':\n      return isPlayerUnit\n        ? enemyUnits.filter(u => !isUnitKO(u))\n        : playerUnits.filter(u => !isUnitKO(u));\n\n    case 'single-ally':\n      return isPlayerUnit\n        ? playerUnits.filter(u => !isUnitKO(u))\n        : enemyUnits.filter(u => !isUnitKO(u));\n\n    case 'all-allies':\n      return isPlayerUnit\n        ? playerUnits.filter(u => !isUnitKO(u))\n        : enemyUnits.filter(u => !isUnitKO(u));\n\n    case 'self':\n      return [caster];\n\n    default:\n      return [];\n  }\n}\n\n/**\n * Filter targets by validity (e.g., healing only works on alive units)\n */\nexport function filterValidTargets(\n  targets: readonly Unit[],\n  ability: Ability\n): readonly Unit[] {\n  if (ability.type === 'healing' && !ability.revivesFallen) {\n    // Healing only works on alive units (unless it revives)\n    return targets.filter(u => !isUnitKO(u));\n  }\n\n  // Other abilities can target KO'd units (for revival)\n  return targets;\n}\n\n/**\n * Get valid targets for UI selection\n * Simplified version for UI components that need to show selectable targets\n * @param ability - Ability (null for basic attack)\n * @param caster - Unit casting the ability\n * @param playerTeam - Player team\n * @param enemies - Enemy units\n * @returns Array of valid target units for selection\n */\nexport function getValidTargets(\n  ability: Ability | null,\n  caster: Unit,\n  playerTeam: { units: readonly Unit[] },\n  enemies: readonly Unit[]\n): readonly Unit[] {\n  if (!ability) {\n    // Basic attack targets enemies\n    return enemies.filter(e => !isUnitKO(e));\n  }\n\n  switch (ability.targets) {\n    case 'single-enemy':\n    case 'all-enemies':\n      return enemies.filter(e => !isUnitKO(e));\n    case 'single-ally':\n    case 'all-allies':\n      return playerTeam.units.filter(u => !isUnitKO(u));\n    case 'self':\n      return [caster];\n    default:\n      return [];\n  }\n}\n\n","/**\n * Result type for error handling\n * Prevents throwing errors across boundaries\n */\nexport type Result<T, E> = \n  | { ok: true; value: T }\n  | { ok: false; error: E };\n\nexport const Ok = <T>(value: T): Result<T, never> => ({ ok: true, value });\n\nexport const Err = <E>(error: E): Result<never, E> => ({ ok: false, error });\n\n","/**\n * BattleTransaction - Simple transaction support for battle state\n * Allows rollback of state changes when operations fail\n */\n\nimport type { BattleState } from '../models/BattleState';\n\n/**\n * Transaction class for managing battle state changes\n * Provides commit/rollback functionality\n */\nexport class BattleTransaction {\n  private snapshot: BattleState | null = null;\n\n  /**\n   * Begin a new transaction by saving current state\n   * @param state - The current battle state to snapshot\n   */\n  begin(state: BattleState): void {\n    // State is immutable, so we can safely store a reference\n    this.snapshot = state;\n  }\n\n  /**\n   * Rollback to the saved state\n   * @returns The original state or null if no transaction\n   */\n  rollback(): BattleState | null {\n    return this.snapshot;\n  }\n\n  /**\n   * Commit the transaction by clearing the snapshot\n   * Called when operation succeeds\n   */\n  commit(): void {\n    this.snapshot = null;\n  }\n\n  /**\n   * Check if a transaction is active\n   */\n  hasSnapshot(): boolean {\n    return this.snapshot !== null;\n  }\n}","/**\n * Battle Service\n * Coordinates battle algorithms and state management\n * Pure functions, deterministic with PRNG\n */\n\nimport type { Unit } from '../models/Unit';\nimport type { BattleState } from '../models/BattleState';\nimport type { Team } from '../models/Team';\nimport type { Ability } from '../../data/schemas/AbilitySchema';\nimport type { StatusEffect } from '../../data/schemas/UnitSchema';\nimport type { PRNG } from '../random/prng';\nimport { createBattleState, updateBattleState } from '../models/BattleState';\nimport { isUnitKO } from '../models/Unit';\nimport {\n  calculatePhysicalDamage,\n  calculatePsynergyDamage,\n  calculateHealAmount,\n  applyDamageWithShields,\n  applyHealing,\n} from '../algorithms/damage';\nimport { calculateTurnOrder } from '../algorithms/turn-order';\nimport {\n  processStatusEffectTick,\n  checkParalyzeFailure,\n  isFrozen,\n  isNegativeStatus,\n  applyStatusToUnit,\n} from '../algorithms/status';\nimport { resolveTargets, filterValidTargets } from '../algorithms/targeting';\nimport { BATTLE_CONSTANTS } from '../constants';\nimport type { BattleEvent } from './types';\nimport { Ok, Err, type Result } from '../utils/result';\nimport { BattleTransaction } from './BattleTransaction';\n\nconst REMOVABLE_STATUS_TYPES = ['poison', 'burn', 'freeze', 'paralyze', 'stun', 'debuff'] as const;\ntype RemovableStatusType = (typeof REMOVABLE_STATUS_TYPES)[number];\n\nconst isRemovableStatusType = (type: StatusEffect['type']): type is RemovableStatusType =>\n  (REMOVABLE_STATUS_TYPES as readonly string[]).includes(type);\n\n/**\n * Action result for executing abilities\n */\nexport interface ActionResult {\n  damage?: number;\n  healing?: number;\n  message: string;\n  targetIds: readonly string[];\n  updatedUnits: readonly Unit[];\n  hit?: boolean;\n}\n\n/**\n * Start a new battle\n * Creates initial battle state with turn order\n */\nexport function startBattle(\n  playerTeam: Team,\n  enemies: readonly Unit[],\n  rng: PRNG\n): Result<BattleState, string> {\n  if (!playerTeam.units || playerTeam.units.length === 0) {\n    return Err('Player team must contain at least one unit');\n  }\n\n  if (!enemies || enemies.length === 0) {\n    return Err('Battle requires at least one enemy');\n  }\n\n  const allUnits = [...playerTeam.units, ...enemies];\n  const turnOrder = calculateTurnOrder(allUnits, playerTeam, rng, 0); // Start at turn 0\n\n  return Ok(createBattleState(playerTeam, enemies, turnOrder));\n}\n\n/**\n * Perform an action in battle\n * Executes ability and returns updated state and events\n * PERFORMANCE: Uses unitById index for O(1) lookups\n */\nexport function performAction(\n  state: BattleState,\n  actorId: string,\n  abilityId: string,\n  targetIds: readonly string[],\n  rng: PRNG\n): Result<{ state: BattleState; result: ActionResult; events: readonly BattleEvent[] }, string> {\n  const transaction = new BattleTransaction();\n  transaction.begin(state);\n\n  // Find actor using index (O(1) instead of O(n))\n  const actorEntry = state.unitById.get(actorId);\n  if (!actorEntry || isUnitKO(actorEntry.unit)) {\n    transaction.rollback();\n    return Err(`Invalid actor: ${actorId}`);\n  }\n  const actor = actorEntry.unit;\n\n  // Check if frozen\n  if (isFrozen(actor)) {\n    const freezeStatus = actor.statusEffects.find((e): e is Extract<typeof e, { type: 'freeze' }> => e.type === 'freeze');\n    const events: BattleEvent[] = freezeStatus ? [{\n      type: 'status-applied',\n      targetId: actorId,\n      status: freezeStatus,\n    }] : [];\n    transaction.commit();\n    return Ok({\n      state,\n      result: {\n        message: `${actor.name} is frozen and cannot act!`,\n        targetIds: [],\n        updatedUnits: [...state.playerTeam.units, ...state.enemies],\n      },\n      events,\n    });\n  }\n\n  // Check paralyze failure\n  if (checkParalyzeFailure(actor, rng)) {\n    const paralyzeStatus = actor.statusEffects.find((e): e is Extract<typeof e, { type: 'paralyze' }> => e.type === 'paralyze');\n    const events: BattleEvent[] = paralyzeStatus ? [{\n      type: 'status-applied',\n      targetId: actorId,\n      status: paralyzeStatus,\n    }] : [];\n    transaction.commit();\n    return Ok({\n      state,\n      result: {\n        message: `${actor.name} is paralyzed and cannot act!`,\n        targetIds: [],\n        updatedUnits: [...state.playerTeam.units, ...state.enemies],\n      },\n      events,\n    });\n  }\n\n  // Find ability\n  const ability = actor.abilities.find(a => a.id === abilityId);\n  if (!ability) {\n    transaction.rollback();\n    return Err(`Ability ${abilityId} not found for unit ${actorId}`);\n  }\n\n  // Resolve targets\n  const potentialTargets = resolveTargets(\n    ability,\n    actor,\n    state.playerTeam.units,\n    state.enemies\n  );\n  const validTargets = filterValidTargets(potentialTargets, ability);\n  const targets = validTargets.filter(t => targetIds.includes(t.id));\n\n  if (targets.length === 0) {\n    transaction.rollback();\n    return Err(`No valid targets for ability ${abilityId}`);\n  }\n\n  // Re-validate targets exist and are alive (defensive check)\n  const aliveTargets = targets.filter(t => {\n    const exists = state.playerTeam.units.some(u => u.id === t.id) ||\n                   state.enemies.some(u => u.id === t.id);\n    return exists && !isUnitKO(t);\n  });\n\n  if (aliveTargets.length === 0) {\n    transaction.rollback();\n    return Err(`All targets are KO'd or invalid`);\n  }\n\n  // Store status effects before execution (for status-applied event detection)\n  const statusEffectsBefore = new Map<string, typeof aliveTargets[number]['statusEffects']>();\n  aliveTargets.forEach(target => {\n    statusEffectsBefore.set(target.id, target.statusEffects);\n  });\n\n  // Execute ability with validated alive targets\n  // Pass team for effective stats calculation and RNG for status chance rolls\n  const allUnits = [...state.playerTeam.units, ...state.enemies];\n  const abilityResult = executeAbility(actor, ability, aliveTargets, allUnits, state.playerTeam, state.enemies, rng);\n  if (!abilityResult.ok) {\n    transaction.rollback();\n    return Err(abilityResult.error);\n  }\n  const result = abilityResult.value;\n\n  // Update battle state with new units\n  const updatedPlayerUnits = state.playerTeam.units.map(u => {\n    const updated = result.updatedUnits.find(up => up.id === u.id);\n    return updated || u;\n  });\n  const updatedEnemies = state.enemies.map(u => {\n    const updated = result.updatedUnits.find(up => up.id === u.id);\n    return updated || u;\n  });\n\n  const updatedTeam: Team = {\n    ...state.playerTeam,\n    units: updatedPlayerUnits,\n  };\n\n  const updatedState = updateBattleState(state, {\n    playerTeam: updatedTeam,\n    enemies: updatedEnemies,\n    log: [...state.log, result.message],\n  });\n\n  // Build events from result\n  const events: BattleEvent[] = [{\n    type: 'ability',\n    casterId: actorId,\n    abilityId,\n    targets: targetIds,\n  }];\n\n  // Add hit/heal events\n  if (result.damage !== undefined) {\n    targetIds.forEach(targetId => {\n      const target = targets.find(t => t.id === targetId);\n      if (target) {\n        events.push({\n          type: 'hit',\n          targetId,\n          amount: result.damage || 0,\n          element: ability.element,\n        });\n\n        // Check if target was KO'd and emit KO event\n        const updatedTarget = result.updatedUnits.find(u => u.id === targetId);\n        if (updatedTarget && updatedTarget.currentHp <= 0) {\n          events.push({ type: 'ko', unitId: targetId });\n        }\n      }\n    });\n  }\n\n  if (result.healing !== undefined) {\n    targetIds.forEach(targetId => {\n      events.push({\n        type: 'heal',\n        targetId,\n        amount: result.healing || 0,\n      });\n    });\n  }\n\n  // Emit status-applied events for newly added status effects (on-hit statuses)\n  if (ability.statusEffect) {\n    targetIds.forEach(targetId => {\n      const beforeStatuses = statusEffectsBefore.get(targetId) || [];\n      const afterUnit = result.updatedUnits.find(u => u.id === targetId);\n      if (afterUnit) {\n        const afterStatuses = afterUnit.statusEffects;\n        \n        // Find newly added statuses (compare by type)\n        const beforeTypes = new Set(beforeStatuses.map(s => s.type));\n        const newStatuses = afterStatuses.filter(s => !beforeTypes.has(s.type));\n        \n        // Emit event for each newly applied status\n        newStatuses.forEach(status => {\n          events.push({\n            type: 'status-applied',\n            targetId,\n            status,\n          });\n        });\n      }\n    });\n  }\n\n  transaction.commit();\n  return Ok({ state: updatedState, result, events });\n}\n\n/**\n * Phase 2: Apply shield granting and status cleanse to targets\n * This processes optional Phase 2 ability effects after main ability execution\n */\nfunction applyPhase2Effects(\n  ability: Ability,\n  targets: Unit[]\n): Unit[] {\n  return targets.map(target => {\n    let modifiedTarget = target;\n\n    // 1. Shield granting\n    if (ability.shieldCharges) {\n      const shieldStatus: Extract<typeof target.statusEffects[number], { type: 'shield' }> = {\n        type: 'shield',\n        remainingCharges: ability.shieldCharges,\n        duration: ability.duration || 3, // Default 3 turns if not specified\n      };\n\n      modifiedTarget = {\n        ...modifiedTarget,\n        statusEffects: [...modifiedTarget.statusEffects, shieldStatus],\n      };\n    }\n\n    // 2. Damage reduction granting\n    if (ability.damageReductionPercent !== undefined) {\n      const damageReductionStatus: Extract<typeof target.statusEffects[number], { type: 'damageReduction' }> = {\n        type: 'damageReduction',\n        percent: ability.damageReductionPercent,\n        duration: ability.duration || 3,\n      };\n\n      modifiedTarget = {\n        ...modifiedTarget,\n        statusEffects: [...modifiedTarget.statusEffects, damageReductionStatus],\n      };\n    }\n\n    // 3. Elemental resistance granting\n    if (ability.elementalResistance) {\n      const elementalResistanceStatus: Extract<typeof target.statusEffects[number], { type: 'elementalResistance' }> = {\n        type: 'elementalResistance',\n        element: ability.elementalResistance.element,\n        modifier: ability.elementalResistance.modifier,\n        duration: ability.duration || 3,\n      };\n\n      modifiedTarget = {\n        ...modifiedTarget,\n        statusEffects: [...modifiedTarget.statusEffects, elementalResistanceStatus],\n      };\n    }\n\n    // 4. Immunity granting\n    if (ability.grantImmunity) {\n      const immunityStatus: Extract<typeof target.statusEffects[number], { type: 'immunity' }> = {\n        type: 'immunity',\n        all: ability.grantImmunity.all,\n        types: ability.grantImmunity.types,\n        duration: ability.grantImmunity.duration,\n      };\n\n      modifiedTarget = {\n        ...modifiedTarget,\n        statusEffects: [...modifiedTarget.statusEffects, immunityStatus],\n      };\n    }\n\n    // 5. Status cleanse\n    if (ability.removeStatusEffects) {\n      const removeSpec = ability.removeStatusEffects;\n      let filteredStatuses = modifiedTarget.statusEffects;\n\n      if (removeSpec.type === 'all') {\n        // Remove all status effects\n        filteredStatuses = [];\n      } else if (removeSpec.type === 'negative') {\n        // Remove only negative status effects\n        filteredStatuses = filteredStatuses.filter(s => !isNegativeStatus(s));\n      } else if (removeSpec.type === 'byType') {\n        // Remove specific status types\n        const typesToRemove = new Set<RemovableStatusType>(removeSpec.statuses);\n        filteredStatuses = filteredStatuses.filter(status => {\n          if (!isRemovableStatusType(status.type)) {\n            return true;\n          }\n\n          return !typesToRemove.has(status.type);\n        });\n      }\n\n      modifiedTarget = {\n        ...modifiedTarget,\n        statusEffects: filteredStatuses,\n      };\n    }\n\n    return modifiedTarget;\n  });\n}\n\n/**\n * Execute an ability in battle (internal helper)\n * Phase 2: Added enemies parameter for splash damage targeting, added rng for status chance rolls\n */\nexport function executeAbility(\n  caster: Unit,\n  ability: Ability,\n  targets: readonly Unit[],\n  allUnits: readonly Unit[],\n  team: Team,\n  enemies: readonly Unit[],\n  rng: PRNG\n): Result<ActionResult, string> {\n  const targetIds = targets.map(t => t.id);\n  let message = `${caster.name} uses ${ability.name}!`;\n  const updatedUnits: Unit[] = [];\n\n  // Execute based on ability type\n  switch (ability.type) {\n    case 'physical':\n    case 'psynergy': {\n      let totalDamage = 0;\n      const hitCount = ability.hitCount || 1; // Multi-hit support\n\n      for (const target of targets) {\n        // Re-validate target exists and is alive (may have been KO'd by previous hits)\n        let currentTarget = updatedUnits.find(u => u.id === target.id) ||\n                             allUnits.find(u => u.id === target.id);\n        if (!currentTarget || isUnitKO(currentTarget)) {\n          continue;\n        }\n\n        let targetDamage = 0;\n\n        // Multi-hit logic\n        for (let hit = 0; hit < hitCount; hit++) {\n          if (isUnitKO(currentTarget)) break; // Stop hitting if target is KO'd\n\n          const damage = ability.type === 'physical'\n            ? calculatePhysicalDamage(caster, currentTarget, team, ability)\n            : calculatePsynergyDamage(caster, currentTarget, team, ability);\n\n          // Phase 2: Apply damage with shield/invulnerability checks\n          const { updatedUnit, actualDamage } = applyDamageWithShields(currentTarget, damage);\n          currentTarget = updatedUnit;\n          targetDamage += actualDamage;\n\n          // Update in the working set\n          const existingIndex = updatedUnits.findIndex(u => u.id === currentTarget!.id);\n          if (existingIndex >= 0) {\n            updatedUnits[existingIndex] = currentTarget;\n          } else {\n            updatedUnits.push(currentTarget);\n          }\n        }\n\n        totalDamage += targetDamage;\n\n        // Apply status effect (if any)\n        if (ability.statusEffect) {\n          const statusType = ability.statusEffect.type;\n          const statusDuration = ability.statusEffect.duration;\n          const statusChance = ability.statusEffect.chance ?? 1.0; // Default 100% chance\n\n          // Phase 2: Use RNG for status chance roll\n          const roll = rng.next(); // Returns [0, 1)\n          if (roll < statusChance) {\n            // First, remove existing status of the same type\n            const filteredStatuses = currentTarget.statusEffects.filter(\n              s => s.type !== statusType\n            );\n            currentTarget = {\n              ...currentTarget,\n              statusEffects: filteredStatuses,\n            };\n\n            // Create new status\n            let newStatus: typeof currentTarget.statusEffects[number];\n            if (statusType === 'poison') {\n              newStatus = {\n                type: 'poison',\n                damagePerTurn: 8,\n                duration: statusDuration,\n              };\n            } else if (statusType === 'burn') {\n              newStatus = {\n                type: 'burn',\n                damagePerTurn: 10,\n                duration: statusDuration,\n              };\n            } else if (statusType === 'freeze') {\n              newStatus = {\n                type: 'freeze',\n                duration: statusDuration,\n              };\n            } else if (statusType === 'stun') {\n              newStatus = {\n                type: 'stun',\n                duration: statusDuration,\n              };\n            } else {\n              newStatus = {\n                type: 'paralyze',\n                duration: statusDuration,\n              };\n            }\n\n            // Phase 2: Apply status with immunity check\n            currentTarget = applyStatusToUnit(currentTarget, newStatus);\n\n            const existingIndex = updatedUnits.findIndex(u => u.id === currentTarget!.id);\n            if (existingIndex >= 0) {\n              updatedUnits[existingIndex] = currentTarget;\n            } else {\n              updatedUnits.push(currentTarget);\n            }\n          }\n        }\n\n        // Apply debuff effect (if any)\n        if (ability.debuffEffect) {\n          const newDebuffs: Array<typeof currentTarget.statusEffects[number]> = [];\n          const validStats: Array<keyof typeof caster.baseStats> = ['hp', 'pp', 'atk', 'def', 'mag', 'spd'];\n\n          for (const [stat, modifier] of Object.entries(ability.debuffEffect)) {\n            if (typeof modifier === 'number' && validStats.includes(stat as keyof typeof caster.baseStats)) {\n              newDebuffs.push({\n                type: 'debuff',\n                stat: stat as keyof typeof caster.baseStats,\n                modifier: -Math.abs(modifier), // Ensure negative for debuff\n                duration: ability.duration || 3,\n              });\n            }\n          }\n\n          // Phase 2: Apply each debuff with immunity check\n          if (newDebuffs.length > 0) {\n            for (const debuff of newDebuffs) {\n              currentTarget = applyStatusToUnit(currentTarget, debuff);\n            }\n\n            const existingIndex = updatedUnits.findIndex(u => u.id === currentTarget!.id);\n            if (existingIndex >= 0) {\n              updatedUnits[existingIndex] = currentTarget;\n            } else {\n              updatedUnits.push(currentTarget);\n            }\n          }\n        }\n      }\n\n      // Phase 2: Splash damage for single-target abilities\n      if (ability.splashDamagePercent && ability.targets === 'single-enemy' && targets.length === 1) {\n        const primaryTargetId = targets[0]?.id;\n        const splashPercent = ability.splashDamagePercent;\n\n        // Find all alive enemies excluding primary target\n        const secondaryTargets = enemies.filter(enemy =>\n          enemy.id !== primaryTargetId && !isUnitKO(enemy)\n        );\n\n        for (const secondaryTarget of secondaryTargets) {\n          // Get current state of secondary target\n          let currentSecondary = updatedUnits.find(u => u.id === secondaryTarget.id) ||\n                                   allUnits.find(u => u.id === secondaryTarget.id);\n\n          if (!currentSecondary || isUnitKO(currentSecondary)) {\n            continue;\n          }\n\n          // Calculate splash damage (reduced by splashPercent)\n          const baseDamage = ability.type === 'physical'\n            ? calculatePhysicalDamage(caster, currentSecondary, team, ability)\n            : calculatePsynergyDamage(caster, currentSecondary, team, ability);\n\n          const splashDamage = Math.floor(baseDamage * splashPercent);\n\n          // Apply splash damage with shields/invulnerability\n          const { updatedUnit, actualDamage } = applyDamageWithShields(currentSecondary, splashDamage);\n          currentSecondary = updatedUnit;\n          totalDamage += actualDamage;\n\n          // Update in the working set\n          const existingIndex = updatedUnits.findIndex(u => u.id === currentSecondary.id);\n          if (existingIndex >= 0) {\n            updatedUnits[existingIndex] = currentSecondary;\n          } else {\n            updatedUnits.push(currentSecondary);\n          }\n        }\n      }\n\n      // Phase 2: Apply shield granting and status cleanse to affected units\n      const unitsWithPhase2Effects = applyPhase2Effects(ability, updatedUnits);\n      updatedUnits.splice(0, updatedUnits.length, ...unitsWithPhase2Effects);\n\n      message += ` Deals ${totalDamage} damage!`;\n\n      const finalUnits = allUnits.map(u => {\n        const updated = updatedUnits.find(up => up.id === u.id);\n        return updated || u;\n      });\n\n      return Ok({\n        damage: totalDamage,\n        message,\n        targetIds,\n        updatedUnits: finalUnits,\n        hit: totalDamage > 0,\n      });\n    }\n\n    case 'healing': {\n      let totalHealing = 0;\n\n      for (const target of targets) {\n        let currentTarget = target;\n\n        // Handle revive\n        if ((ability.revivesFallen || ability.revive) && isUnitKO(target)) {\n          const maxHp = target.baseStats.hp + (target.level - 1) * target.growthRates.hp;\n          const reviveHPPercent = ability.reviveHPPercent ?? BATTLE_CONSTANTS.REVIVE_HP_PERCENTAGE;\n          currentTarget = {\n            ...target,\n            currentHp: Math.floor(maxHp * reviveHPPercent),\n          };\n          totalHealing += currentTarget.currentHp;\n        } else if (!isUnitKO(target)) {\n          // Use effective MAG for healing calculation\n          const healAmount = calculateHealAmount(caster, team, ability);\n          currentTarget = applyHealing(target, healAmount, ability.revivesFallen || ability.revive || false);\n          totalHealing += currentTarget.currentHp - target.currentHp;\n        }\n\n        // Apply heal-over-time effect (if any)\n        if (ability.healOverTime && !isUnitKO(currentTarget)) {\n          const hotEffect: Extract<typeof currentTarget.statusEffects[number], { type: 'healOverTime' }> = {\n            type: 'healOverTime',\n            healPerTurn: ability.healOverTime.amount,\n            duration: ability.healOverTime.duration,\n          };\n\n          // Remove existing heal-over-time effects\n          const filteredStatuses = currentTarget.statusEffects.filter(s => s.type !== 'healOverTime');\n\n          currentTarget = {\n            ...currentTarget,\n            statusEffects: [...filteredStatuses, hotEffect],\n          };\n        }\n\n        updatedUnits.push(currentTarget);\n      }\n\n      // Phase 2: Apply shield granting and status cleanse\n      const unitsWithPhase2Effects = applyPhase2Effects(ability, updatedUnits);\n      updatedUnits.splice(0, updatedUnits.length, ...unitsWithPhase2Effects);\n\n      message += ` Restores ${totalHealing} HP!`;\n\n      const finalUnits = allUnits.map(u => {\n        const updated = updatedUnits.find(up => up.id === u.id);\n        return updated || u;\n      });\n\n      return Ok({\n        healing: totalHealing,\n        message,\n        targetIds,\n        updatedUnits: finalUnits,\n        hit: false,\n      });\n    }\n\n    case 'buff':\n    case 'debuff': {\n      for (const target of targets) {\n        if (ability.buffEffect) {\n          let modifiedTarget = target;\n\n          const validStats: Array<keyof typeof target.baseStats> = ['hp', 'pp', 'atk', 'def', 'mag', 'spd'];\n          for (const [stat, modifier] of Object.entries(ability.buffEffect)) {\n            if (typeof modifier === 'number' && validStats.includes(stat as keyof typeof target.baseStats)) {\n              const newStatus: typeof target.statusEffects[number] = {\n                type: ability.type === 'buff' ? 'buff' : 'debuff',\n                stat: stat as keyof typeof target.baseStats,\n                modifier: modifier as number,\n                duration: ability.duration || 3,\n              };\n\n              // Phase 2: Apply status with immunity check\n              modifiedTarget = applyStatusToUnit(modifiedTarget, newStatus);\n            }\n          }\n\n          updatedUnits.push(modifiedTarget);\n        } else {\n          updatedUnits.push(target);\n        }\n      }\n\n      // Phase 2: Apply shield granting and status cleanse\n      const unitsWithPhase2Effects = applyPhase2Effects(ability, updatedUnits);\n      updatedUnits.splice(0, updatedUnits.length, ...unitsWithPhase2Effects);\n\n      message += ` Applied ${ability.type}!`;\n\n      const finalUnits = allUnits.map(u => {\n        const updated = updatedUnits.find(up => up.id === u.id);\n        return updated || u;\n      });\n\n      return Ok({\n        message,\n        targetIds,\n        updatedUnits: finalUnits,\n        hit: false,\n      });\n    }\n\n    case 'summon': {\n      // Summon abilities are handled separately by the Djinn system\n      // This case exists for type safety but shouldn't be called directly\n      return Ok({\n        message: `${caster.name} summons ${ability.name}!`,\n        targetIds,\n        updatedUnits: [...allUnits],\n        hit: false,\n      });\n    }\n\n    default: {\n      // Exhaustive check - ensures all ability types are handled\n      const _exhaustive: never = ability.type;\n      return Err(`Unhandled ability type: ${String(_exhaustive)}`);\n    }\n  }\n}\n\n/**\n * End turn and advance to next actor\n * Processes status effects and recalculates turn order if needed\n * PERFORMANCE: Uses unitById index for O(1) lookup\n */\nexport function endTurn(\n  state: BattleState,\n  rng: PRNG\n): Result<BattleState, string> {\n  const transaction = new BattleTransaction();\n  transaction.begin(state);\n  let workingState = state;\n  // Process status effects for current actor\n  const currentActorId = workingState.turnOrder[workingState.currentActorIndex];\n  if (!currentActorId) {\n    // No current actor, just advance\n    let nextIndex = workingState.currentActorIndex + 1;\n    if (nextIndex >= workingState.turnOrder.length) {\n      nextIndex = 0;\n    }\n    const updated = updateBattleState(workingState, { currentActorIndex: nextIndex });\n    transaction.commit();\n    return Ok(updated);\n  }\n\n  const currentActorEntry = workingState.unitById.get(currentActorId);\n  const currentActor = currentActorEntry?.unit;\n\n  if (currentActor) {\n    const statusResult = processStatusEffectTick(currentActor, rng);\n\n    // Update actor in the appropriate array (player or enemy)\n    const isPlayer = currentActorEntry!.isPlayer;\n\n    if (isPlayer) {\n      const updatedPlayerUnits = workingState.playerTeam.units.map(u =>\n        u.id === currentActorId ? statusResult.updatedUnit : u\n      );\n      workingState = updateBattleState(workingState, {\n        playerTeam: { ...workingState.playerTeam, units: updatedPlayerUnits },\n        log: statusResult.messages.length > 0\n          ? [...workingState.log, ...statusResult.messages]\n          : workingState.log,\n      });\n    } else {\n      const updatedEnemies = workingState.enemies.map(u =>\n        u.id === currentActorId ? statusResult.updatedUnit : u\n      );\n      workingState = updateBattleState(workingState, {\n        enemies: updatedEnemies,\n        log: statusResult.messages.length > 0\n          ? [...workingState.log, ...statusResult.messages]\n          : workingState.log,\n      });\n    }\n  }\n\n  // Advance to next actor\n  let nextIndex = workingState.currentActorIndex + 1;\n\n  // If we've gone through all units, start new round\n  if (nextIndex >= workingState.turnOrder.length) {\n    nextIndex = 0;\n    const newTurn = workingState.currentTurn + 1;\n    const newTurnOrder = calculateTurnOrder(\n      [...workingState.playerTeam.units, ...workingState.enemies],\n      workingState.playerTeam,\n      rng,\n      newTurn\n    );\n\n    const updated = updateBattleState(workingState, {\n      currentTurn: newTurn,\n      turnOrder: newTurnOrder,\n      currentActorIndex: 0,\n    });\n    transaction.commit();\n    return Ok(updated);\n  }\n\n  const updated = updateBattleState(workingState, {\n    currentActorIndex: nextIndex,\n  });\n  transaction.commit();\n  return Ok(updated);\n}\n\n/**\n * Check if battle has ended\n */\nexport function checkBattleEnd(\n  state: BattleState\n): 'PLAYER_VICTORY' | 'PLAYER_DEFEAT' | null {\n  const allPlayerKO = state.playerTeam.units.every(u => isUnitKO(u));\n  const allEnemiesKO = state.enemies.every(u => isUnitKO(u));\n\n  // If both teams are KO'd simultaneously, treat as defeat (player loses ties)\n  if (allEnemiesKO && allPlayerKO) {\n    return 'PLAYER_DEFEAT';\n  }\n\n  if (allEnemiesKO) return 'PLAYER_VICTORY';\n  if (allPlayerKO) return 'PLAYER_DEFEAT';\n\n  return null;\n}\n\n/**\n * Process status effects for current actor at turn start\n * Returns updated battle state and events generated\n */\nexport function startTurnTick(\n  state: BattleState,\n  rng: PRNG\n): { updatedState: BattleState; events: readonly BattleEvent[] } {\n  const currentActorId = state.turnOrder[state.currentActorIndex];\n  if (!currentActorId) {\n    return { updatedState: state, events: [] };\n  }\n\n  const allUnits = [...state.playerTeam.units, ...state.enemies];\n  const currentActor = allUnits.find(u => u.id === currentActorId);\n\n  if (!currentActor) {\n    return { updatedState: state, events: [] };\n  }\n\n  // Process status effects\n  const statusResult = processStatusEffectTick(currentActor, rng);\n\n  // Update actor with status effects\n  const updatedAllUnits = allUnits.map(u =>\n    u.id === currentActorId ? statusResult.updatedUnit : u\n  );\n\n  const updatedPlayerUnits = updatedAllUnits.filter(u =>\n    state.playerTeam.units.some(pu => pu.id === u.id)\n  );\n  const updatedEnemies = updatedAllUnits.filter(u =>\n    state.enemies.some(e => e.id === u.id)\n  );\n\n  const updatedBattle: BattleState = {\n    ...state,\n    playerTeam: {\n      ...state.playerTeam,\n      units: updatedPlayerUnits,\n    },\n    enemies: updatedEnemies,\n  };\n\n  // Generate events for status effects\n  const newEvents: BattleEvent[] = [];\n\n  if (statusResult.damage > 0) {\n    newEvents.push({\n      type: 'hit',\n      targetId: currentActorId,\n      amount: statusResult.damage,\n    });\n  }\n\n  // Check for expired statuses by comparing old and new status effects\n  const makeStatusKey = (s: typeof currentActor.statusEffects[number]) =>\n    `${s.type}-${'duration' in s ? s.duration : 'usesRemaining' in s ? s.usesRemaining : 'permanent'}`;\n  const oldStatusIds = new Set(currentActor.statusEffects.map(makeStatusKey));\n  const newStatusIds = new Set(statusResult.updatedUnit.statusEffects.map(makeStatusKey));\n\n  currentActor.statusEffects.forEach(status => {\n    const statusKey = makeStatusKey(status);\n    if (oldStatusIds.has(statusKey) && !newStatusIds.has(statusKey)) {\n      newEvents.push({\n        type: 'status-expired',\n        targetId: currentActorId,\n        status,\n      });\n    }\n  });\n\n  return { updatedState: updatedBattle, events: newEvents };\n}\n","/**\n * AI Service\n * Deterministic AI decision-making for enemy units\n * Uses ability scoring and target selection based on tactical rules\n */\n\nimport type { Unit } from '../models/Unit';\nimport type { BattleState } from '../models/BattleState';\nimport type { Ability } from '../../data/schemas/AbilitySchema';\nimport type { PRNG } from '../random/prng';\nimport { calculateMaxHp, isUnitKO } from '../models/Unit';\nimport { getElementModifier } from '../algorithms/damage';\nimport { resolveTargets } from '../algorithms/targeting';\nimport type { Team } from '../models/Team';\nimport { calculateEffectiveStats } from '../algorithms/stats';\n\n/**\n * AI hints for abilities (optional metadata)\n * Used to guide AI decision-making\n */\nexport interface AIHints {\n  priority?: number; // Baseline weight (0-3, higher = prefer)\n  target?: 'weakest' | 'random' | 'lowestRes' | 'healerFirst' | 'highestDef';\n  avoidOverkill?: boolean; // Penalize heavy hits on low HP targets\n  opener?: boolean; // Prefer in first N turns\n}\n\n/**\n * Decision made by AI\n */\nexport interface AIDecision {\n  abilityId: string;\n  targetIds: readonly string[];\n}\n\n/**\n * Selects the living unit with the lowest HP percentage.\n * Returns null if no valid units remain.\n */\nexport function selectLowHPTarget(units: readonly Unit[]): Unit | null {\n  const livingUnits = units.filter(unit => !isUnitKO(unit));\n  if (livingUnits.length === 0) {\n    return null;\n  }\n\n  return livingUnits.reduce((lowest, unit) => {\n    const lowestHpPct = lowest.currentHp / calculateMaxHp(lowest);\n    const unitHpPct = unit.currentHp / calculateMaxHp(unit);\n    return unitHpPct < lowestHpPct ? unit : lowest;\n  }, livingUnits[0]!);\n}\n\n/**\n * Score an ability for use by an enemy unit\n * Higher score = better choice\n */\nfunction scoreAbility(\n  ability: Ability,\n  caster: Unit,\n  state: BattleState\n): number {\n  let score = ability.aiHints?.priority ?? 1.0;\n\n  // Build lightweight teams for effective stat calculations\n  const playerTeam = state.playerTeam;\n  const enemyTeam: Team = {\n    equippedDjinn: [],\n    djinnTrackers: {},\n    units: state.enemies,\n    collectedDjinn: [],\n    currentTurn: state.currentTurn ?? 0,\n    activationsThisTurn: {},\n    djinnStates: {},\n  };\n  const casterTeam: Team = { ...enemyTeam, units: [caster] };\n  const casterStats = calculateEffectiveStats(caster, casterTeam);\n\n  // Get potential targets\n  const potentialTargets = resolveTargets(\n    ability,\n    caster,\n    state.playerTeam.units,\n    state.enemies\n  );\n  const validTargets = potentialTargets.filter(t => !isUnitKO(t));\n\n  if (validTargets.length === 0) {\n    return -1000; // No valid targets\n  }\n\n  // Estimate damage/healing value\n  let estimatedValue = 0;\n\n  if (ability.type === 'physical' || ability.type === 'psynergy') {\n    // Estimate damage using effective stats (includes equipment/Djinn/status)\n    const basePower = ability.basePower || 0;\n    const casterStat = ability.type === 'physical' ? casterStats.atk : casterStats.mag;\n    const avgTargetDef = validTargets.reduce((sum, t) => {\n      const targetTeam = playerTeam.units.includes(t) ? playerTeam : enemyTeam;\n      const def = calculateEffectiveStats(t, targetTeam).def;\n      return sum + def;\n    }, 0) / validTargets.length;\n\n    // Rough damage estimate (simplified formula)\n    // Note: This is approximate - actual damage uses effective stats in BattleService\n    const rawDamage = basePower + casterStat - avgTargetDef;\n    const avgDamage = Math.max(1, rawDamage);\n\n    // Apply element modifier if applicable\n    if (ability.element) {\n      const avgElementMod = validTargets.reduce((sum, t) => {\n        return sum + getElementModifier(ability.element!, t.element);\n      }, 0) / validTargets.length;\n      estimatedValue = avgDamage * avgElementMod;\n    } else {\n      estimatedValue = avgDamage;\n    }\n\n    // Multi-target bonus\n    if (ability.targets === 'all-enemies' || ability.targets === 'all-allies') {\n      estimatedValue *= validTargets.length;\n    }\n  } else if (ability.type === 'healing') {\n    // Estimate healing value\n    const baseHeal = ability.basePower || 0;\n    const casterMag = casterStats.mag;\n    const rawHeal = baseHeal + casterMag;\n    estimatedValue = Math.max(1, rawHeal);\n\n    // Multi-target bonus\n    if (ability.targets === 'all-allies') {\n      estimatedValue *= validTargets.length;\n    }\n  } else if (ability.type === 'buff' || ability.type === 'debuff') {\n    // Status utility - value based on stat modifier\n    if (ability.buffEffect) {\n      const statMods = Object.values(ability.buffEffect).filter(v => typeof v === 'number');\n      const totalMod = statMods.reduce((sum, mod) => sum + Math.abs(mod as number), 0);\n      estimatedValue = totalMod * 2; // Status effects are valuable\n    }\n  }\n\n  // Apply status utility weight\n  score += estimatedValue * 0.1;\n\n  // Opener bonus (prefer in early turns)\n  // Note: turnNumber tracking would need to be added to BattleState if needed\n  // For now, opener hint is ignored (can be added later)\n  if (ability.aiHints?.opener) {\n    score += 1.0; // Small bonus for opener abilities\n  }\n\n  return score;\n}\n\n/**\n * Select targets for an ability\n * Uses AI hints to choose optimal targets\n */\nfunction selectTargets(\n  ability: Ability,\n  caster: Unit,\n  state: BattleState,\n  rng: PRNG\n): readonly string[] {\n  const potentialTargets = resolveTargets(\n    ability,\n    caster,\n    state.playerTeam.units,\n    state.enemies\n  );\n  const validTargets = potentialTargets.filter(t => !isUnitKO(t));\n\n  if (validTargets.length === 0) {\n    return [];\n  }\n\n  const targetHint = ability.aiHints?.target || 'weakest';\n\n  switch (targetHint) {\n    case 'weakest': {\n      // Find weakest effective HP (HP Ã— resist multiplier)\n      const scored = validTargets.map(target => {\n        const maxHp = calculateMaxHp(target);\n        const currentHp = target.currentHp;\n        const hpRatio = currentHp / maxHp;\n\n        // Apply element resistance if ability has element\n        let effectiveHp = currentHp;\n        if (ability.element) {\n          const resistMod = getElementModifier(ability.element, target.element);\n          effectiveHp = currentHp / resistMod; // Lower effective HP = weaker\n        }\n\n        return { target, effectiveHp, hpRatio };\n      });\n\n      // Sort by effective HP (lowest first)\n      scored.sort((a, b) => a.effectiveHp - b.effectiveHp);\n\n      // Avoid overkill if hint says so\n      if (ability.aiHints?.avoidOverkill) {\n        // Prefer targets that won't be overkilled by estimated damage\n        const estimatedDamage = (ability.basePower || 0) + \n          (ability.type === 'physical' ? caster.baseStats.atk : caster.baseStats.mag);\n        \n        // Filter out targets that would be overkilled by >50%\n        const nonOverkill = scored.filter(s => {\n          const overkill = estimatedDamage - s.effectiveHp;\n          return overkill < s.effectiveHp * 0.5; // Don't overkill by more than 50% of remaining HP\n        });\n\n        if (nonOverkill.length > 0) {\n          // Length check guarantees [0] exists\n          return [nonOverkill[0]!.target.id];\n        }\n      }\n\n      // Return weakest target(s)\n      if (ability.targets === 'all-enemies' || ability.targets === 'all-allies') {\n        return scored.map(s => s.target.id);\n      }\n      if (scored.length > 0) {\n        // Length check guarantees [0] exists\n        return [scored[0]!.target.id];\n      }\n      return [];\n    }\n\n    case 'lowestRes': {\n      // Find target with lowest resistance to ability element\n      if (!ability.element || validTargets.length === 0) {\n        if (validTargets.length > 0) {\n          // Length check guarantees [0] exists\n          return [validTargets[0]!.id];\n        }\n        return [];\n      }\n\n      // ability.element is guaranteed to be defined here\n      const abilityElement = ability.element;\n      const scored = validTargets.map(target => {\n        const resistMod = getElementModifier(abilityElement, target.element);\n        return { target, resistMod };\n      });\n\n      scored.sort((a, b) => a.resistMod - b.resistMod); // Lower = weaker resistance\n      if (scored.length > 0) {\n        // Length check guarantees [0] exists\n        return [scored[0]!.target.id];\n      }\n      return [];\n    }\n\n    case 'healerFirst': {\n      // Target healers first (units with healing abilities)\n      const healers = validTargets.filter(t => \n        t.abilities.some(a => a.type === 'healing')\n      );\n      if (healers.length > 0) {\n        // Length check guarantees [0] exists\n        return [healers[0]!.id];\n      }\n      if (validTargets.length > 0) {\n        // Length check guarantees [0] exists\n        return [validTargets[0]!.id];\n      }\n      return [];\n    }\n\n    case 'random': {\n      // Random selection (deterministic via RNG)\n      if (validTargets.length === 0) {\n        return [];\n      }\n      // AoE abilities ignore random single-target selection and hit everyone\n      if (ability.targets === 'all-enemies' || ability.targets === 'all-allies') {\n        return validTargets.map(t => t.id);\n      }\n      const index = Math.floor(rng.next() * validTargets.length);\n      // Index is guaranteed to be valid since 0 <= index < length\n      return [validTargets[index]!.id];\n    }\n\n    case 'highestDef': {\n      // Find target with highest DEF (single-target only)\n      if (validTargets.length === 0) {\n        return [];\n      }\n      \n      const scored = validTargets.map(target => {\n        // Use base DEF (AI doesn't have access to effective stats here)\n        // Could be enhanced later to use effective DEF if team is passed\n        const def = target.baseStats.def;\n        return { target, def };\n      });\n      \n      scored.sort((a, b) => b.def - a.def); // Highest DEF first\n      if (scored.length > 0) {\n        // Length check guarantees [0] exists\n        return [scored[0]!.target.id];\n      }\n      return [];\n    }\n\n    default:\n      if (validTargets.length > 0) {\n        // Length check guarantees [0] exists\n        return [validTargets[0]!.id];\n      }\n      return [];\n  }\n}\n\n/**\n * Make an AI decision for an enemy unit\n * Returns the ability ID and target IDs to use\n */\nexport function makeAIDecision(\n  state: BattleState,\n  actorId: string,\n  rng: PRNG\n): AIDecision {\n  // Find actor\n  const allUnits = [...state.playerTeam.units, ...state.enemies];\n  const actor = allUnits.find(u => u.id === actorId);\n  if (!actor || isUnitKO(actor)) {\n    throw new Error(`Invalid actor: ${actorId}`);\n  }\n\n  // Get available abilities (unlocked and with valid targets)\n  const availableAbilities = actor.abilities.filter(ability => {\n    // Check if ability is unlocked (simplified - assume all are unlocked for enemies)\n    // In future, check unlockLevel vs actor.level\n\n    // Check if ability has valid targets\n    const potentialTargets = resolveTargets(\n      ability,\n      actor,\n      state.playerTeam.units,\n      state.enemies\n    );\n    const validTargets = potentialTargets.filter(t => !isUnitKO(t));\n    return validTargets.length > 0;\n  });\n\n  if (availableAbilities.length === 0) {\n    // Fallback: use first ability (shouldn't happen)\n    throw new Error(`No available abilities for ${actorId}`);\n  }\n\n  // Score all abilities\n  const scored = availableAbilities.map(ability => ({\n    ability,\n    score: scoreAbility(ability, actor, state),\n  }));\n\n  // Sort by score (highest first)\n  scored.sort((a, b) => b.score - a.score);\n\n  // Pick best ability (or randomize among top 2 if scores are close)\n  if (scored.length === 0) {\n    throw new Error(`No scored abilities for ${actorId}`);\n  }\n\n  // Length check guarantees [0] and potentially [1] exist\n  let chosenAbility = scored[0]!.ability;\n\n  if (scored.length > 1 && scored[0]!.score - scored[1]!.score < 2.0) {\n    // Scores are close - randomize between top 2\n    const topTwo = scored.slice(0, 2);\n    const index = Math.floor(rng.next() * topTwo.length);\n    chosenAbility = topTwo[index]!.ability;\n  }\n\n  // Select targets\n  const targetIds = selectTargets(chosenAbility, actor, state, rng);\n\n  return {\n    abilityId: chosenAbility.id,\n    targetIds,\n  };\n}\n","/**\n * Serializable snapshot of the PRNG state.\n *\n * NOTE: `state` is the internal XorShift state after warmup and draws,\n * not the original seed. `initialSeed` is preserved for debugging and\n * reproducibility. `draws` counts how many times `next()` has been\n * called on this instance (after warmup).\n */\nexport interface SerializedPRNG {\n  state: number;\n  initialSeed: number;\n  draws: number;\n}\n\n/**\n * Seeded PRNG interface for deterministic randomness\n */\nexport interface PRNG {\n  /**\n   * Returns next random number in [0, 1)\n   */\n  next(): number;\n\n  /**\n   * Creates a clone of this PRNG (for branching)\n   */\n  clone(): PRNG;\n\n  /**\n   * Returns original seed (for debugging / provenance)\n   */\n  getSeed(): number;\n\n  /**\n   * Returns the number of draws that have been performed.\n   * Does not include the warmup draws performed in the constructor.\n   */\n  getDrawCount(): number;\n\n  /**\n   * Captures a serializable snapshot of the current generator state.\n   */\n  snapshot(): SerializedPRNG;\n}\n\n/**\n * XorShift PRNG implementation\n * Fast, deterministic, good quality\n */\nexport class XorShiftPRNG implements PRNG {\n  private state: number;\n  private readonly initialSeed: number;\n  private draws: number;\n\n  constructor(seed: number) {\n    // Validate seed is non-negative\n    if (seed < 0) {\n      throw new Error(`PRNG seed must be non-negative, got: ${seed}`);\n    }\n\n    // Use 1 as default if seed is 0 (0 would cause issues with XorShift)\n    this.initialSeed = seed || 1;\n    this.state = this.initialSeed;\n    this.draws = 0;\n\n    // Warm up the generator\n    for (let i = 0; i < 10; i++) {\n      this.stepInternal();\n    }\n  }\n\n  /**\n   * Internal XorShift32 step that updates the state and returns the raw u32.\n   */\n  private stepInternal(): number {\n    // XorShift32 algorithm\n    this.state ^= this.state << 13;\n    this.state ^= this.state >>> 17;\n    this.state ^= this.state << 5;\n    return this.state >>> 0;\n  }\n\n  /**\n   * Returns next random number in [0, 1).\n   */\n  next(): number {\n    const value = this.stepInternal();\n    this.draws += 1;\n    // Convert to [0, 1) range using 2^32 as denominator\n    return value / 0x1_0000_0000;\n  }\n\n  /**\n   * Returns the raw 32-bit unsigned integer from the generator.\n   * Useful for hashing or deriving additional values.\n   */\n  nextU32(): number {\n    const value = this.stepInternal();\n    this.draws += 1;\n    return value;\n  }\n\n  clone(): PRNG {\n    const cloned = new XorShiftPRNG(this.initialSeed);\n    cloned.state = this.state;\n    cloned.draws = this.draws;\n    return cloned;\n  }\n\n  getSeed(): number {\n    return this.initialSeed;\n  }\n\n  getDrawCount(): number {\n    return this.draws;\n  }\n\n  snapshot(): SerializedPRNG {\n    return {\n      state: this.state >>> 0,\n      initialSeed: this.initialSeed >>> 0,\n      draws: this.draws >>> 0,\n    };\n  }\n\n  /**\n   * Reconstruct a PRNG from a serialized snapshot.\n   *\n   * This will perform the same warmup as the constructor and then\n   * restore the internal state and draw count, so subsequent calls\n   * to `next()` produce the same sequence as the original instance.\n   */\n  static fromSerialized(snapshot: SerializedPRNG): XorShiftPRNG {\n    const prng = new XorShiftPRNG(snapshot.initialSeed);\n    prng.state = snapshot.state >>> 0;\n    prng.draws = snapshot.draws >>> 0;\n    return prng;\n  }\n}\n\n/**\n * Create a new PRNG from seed\n * @param seed - Non-negative integer seed (0 is converted to 1)\n * @throws Error if seed is negative\n */\nexport function makePRNG(seed: number): PRNG {\n  if (seed < 0) {\n    throw new Error(`PRNG seed must be non-negative, got: ${seed}`);\n  }\n  return new XorShiftPRNG(seed);\n}\n\n/**\n * Recreate a PRNG instance from a serialized snapshot.\n */\nexport function prngFromSnapshot(snapshot: SerializedPRNG): PRNG {\n  return XorShiftPRNG.fromSerialized(snapshot);\n}\n\n/**\n * Create PRNG from current time (for non-deterministic use cases).\n *\n * NOTE: This should be used only in UI/infra layers. Core deterministic\n * logic should receive a seeded PRNG created via `makePRNG` instead.\n */\nexport function makeRandomPRNG(): PRNG {\n  return new XorShiftPRNG(Date.now());\n}\n\n/**\n * Deterministically derive a new seed from a parent seed and a label.\n * Uses a simple FNV-1a 32-bit hash.\n */\nexport function deriveSeed(parentSeed: number, label: string): number {\n  // FNV-1a 32-bit offset basis\n  let h = (0x811c9dc5 ^ (parentSeed >>> 0)) >>> 0;\n  for (let i = 0; i < label.length; i++) {\n    h ^= label.charCodeAt(i);\n    h = Math.imul(h, 0x01000193) >>> 0;\n  }\n  return h >>> 0;\n}\n\n","/**\n * Mana circle system algorithms\n * PR-MANA-QUEUE: Team-wide mana pool management\n */\n\nimport type { QueuedAction } from '../models/BattleState';\nimport type { Ability } from '../../data/schemas/AbilitySchema';\n\n/**\n * Check if action can be afforded with remaining mana\n *\n * @param remainingMana - Current mana pool\n * @param manaCost - Cost of the action\n * @returns True if action can be afforded\n */\nexport function canAffordAction(remainingMana: number, manaCost: number): boolean {\n  return remainingMana >= manaCost;\n}\n\n/**\n * Get mana cost for an ability\n * Basic attacks (null abilityId) cost 0\n *\n * @param abilityId - Ability ID or null for basic attack\n * @param ability - Ability definition (if not basic attack)\n * @returns Mana cost (0-10)\n */\nexport function getAbilityManaCost(\n  abilityId: string | null,\n  ability?: Ability\n): number {\n  if (abilityId === null) {\n    // Basic attack is always free\n    return 0;\n  }\n\n  if (!ability) {\n    throw new Error(`Ability ${abilityId} not found`);\n  }\n\n  return ability.manaCost ?? 0;\n}\n\n/**\n * Calculate total mana cost of all queued actions\n *\n * @param queuedActions - Array of queued actions (null if not queued)\n * @returns Total mana cost\n */\nexport function calculateTotalQueuedManaCost(\n  queuedActions: readonly (QueuedAction | null)[]\n): number {\n  return queuedActions\n    .filter((action): action is QueuedAction => action !== null)\n    .reduce((total, action) => total + action.manaCost, 0);\n}\n\n/**\n * Validate that all queued actions are affordable\n *\n * @param remainingMana - Current mana pool\n * @param queuedActions - Array of queued actions\n * @returns True if all actions are affordable\n */\nexport function validateQueuedActions(\n  remainingMana: number,\n  queuedActions: readonly (QueuedAction | null)[]\n): boolean {\n  const totalCost = calculateTotalQueuedManaCost(queuedActions);\n  return totalCost <= remainingMana;\n}\n\n/**\n * Check if all unit actions are queued\n *\n * @param queuedActions - Array of queued actions\n * @param teamSize - Expected team size (1-4). If not provided, uses queuedActions.length\n * @returns True if all actions are queued\n */\nexport function isQueueComplete(\n  queuedActions: readonly (QueuedAction | null)[],\n  teamSize?: number\n): boolean {\n  const expectedSize = teamSize ?? queuedActions.length;\n  if (expectedSize < 1 || expectedSize > 4) {\n    throw new Error(`Team size must be between 1 and 4, got ${expectedSize}`);\n  }\n  return queuedActions.length === expectedSize && queuedActions.every(action => action !== null);\n}","/**\n * Queue-Based Battle Service\n * PR-QUEUE-BATTLE: Manages planning and execution phases\n * Pure functions, deterministic with PRNG\n */\n\nimport type { BattleState, QueuedAction } from '../models/BattleState';\nimport type { Team } from '../models/Team';\nimport type { Unit } from '../models/Unit';\nimport type { Stats } from '../models/types';\nimport type { Ability } from '../../data/schemas/AbilitySchema';\nimport type { PRNG } from '../random/prng';\nimport type { BattleEvent } from './types';\nimport { updateBattleState } from '../models/BattleState';\nimport { updateTeam } from '../models/Team';\nimport { isUnitKO } from '../models/Unit';\nimport { createEmptyQueue } from '../constants';\nimport { getAbilityManaCost, canAffordAction, validateQueuedActions } from '../algorithms/mana';\nimport { Result, Ok, Err } from '../utils/result';\nimport { calculateSummonDamage, canActivateDjinn } from '../algorithms/djinn';\nimport { getEffectiveSPD, calculateEffectiveStats } from '../algorithms/stats';\nimport { performAction, type ActionResult } from './BattleService';\nimport { makeAIDecision } from './AIService';\nimport {\n  mergeDjinnAbilitiesIntoUnit,\n  calculateDjinnBonusesForUnit,\n} from '../algorithms/djinnAbilities';\nimport { DJINN } from '../../data/definitions/djinn';\nimport { ABILITIES } from '../../data/definitions/abilities';\nimport { applyStatusToUnit } from '../algorithms/status';\n\n// The unwrapped value from performAction Result\ntype PerformActionValue = { state: BattleState; result: ActionResult; events: readonly BattleEvent[] };\n\nfunction isBasicAttack(action: QueuedAction): boolean {\n  return action.abilityId === null;\n}\n\nfunction shouldGenerateMana(\n  action: QueuedAction,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  __actionResult: PerformActionValue\n): boolean {\n  return isBasicAttack(action);\n}\n\n/**\n * Queue an action for a unit\n * PR-QUEUE-BATTLE: Adds action to queue and deducts mana\n * \n * @param state - Current battle state\n * @param unitId - Unit ID to queue action for\n * @param abilityId - Ability ID (null for basic attack)\n * @param targetIds - Target unit IDs\n * @param ability - Ability definition (if not basic attack)\n * @returns Result with updated battle state or error message\n */\nexport function queueAction(\n  state: BattleState,\n  unitId: string,\n  abilityId: string | null,\n  targetIds: readonly string[],\n  ability?: Ability\n): Result<BattleState, string> {\n  if (state.phase !== 'planning') {\n    return Err('Can only queue actions during planning phase');\n  }\n\n  // Find unit index in team\n  const unitIndex = state.playerTeam.units.findIndex(u => u.id === unitId);\n  if (unitIndex === -1) {\n    return Err(`Unit ${unitId} not found in player team`);\n  }\n  \n  // Validate unitIndex is within bounds\n  const teamSize = state.playerTeam.units.length;\n  if (unitIndex < 0 || unitIndex >= teamSize) {\n    return Err(`Unit index ${unitIndex} out of bounds for team size ${teamSize}`);\n  }\n\n  // If this unit already has an action queued, refund its mana before re-queuing.\n  const previousAction = state.queuedActions[unitIndex];\n\n  // Calculate mana cost\n  try {\n    const manaCost = getAbilityManaCost(abilityId, ability);\n    const availableMana = state.remainingMana + (previousAction?.manaCost ?? 0);\n\n    // Check if affordable\n    if (!canAffordAction(availableMana, manaCost)) {\n      return Err(`Cannot afford action: need ${manaCost} mana, have ${availableMana}`);\n    }\n\n    // Create queued action\n    const action: QueuedAction = {\n      unitId,\n      abilityId,\n      targetIds,\n      manaCost,\n    };\n\n    // Update queue\n    const newQueuedActions = [...state.queuedActions];\n    newQueuedActions[unitIndex] = action;\n\n    return Ok(updateBattleState(state, {\n      queuedActions: newQueuedActions,\n      remainingMana: availableMana - manaCost,\n    }));\n  } catch (error) {\n    // Handle errors from getAbilityManaCost (e.g., missing ability)\n    return Err(error instanceof Error ? error.message : `Failed to queue action: ${String(error)}`);\n  }\n}\n\n/**\n * Clear a queued action (refund mana)\n * PR-QUEUE-BATTLE: Removes action from queue and refunds mana\n *\n * @param state - Current battle state\n * @param unitIndex - Index of unit (0 to teamSize-1)\n * @returns Result with updated battle state or error message\n */\nexport function clearQueuedAction(state: BattleState, unitIndex: number): Result<BattleState, string> {\n  if (state.phase !== 'planning') {\n    return Err('Can only clear actions during planning phase');\n  }\n\n  const action = state.queuedActions[unitIndex];\n  if (!action) {\n    return Ok(state); // Nothing to clear\n  }\n\n  // Refund mana\n  const newQueuedActions = [...state.queuedActions];\n  newQueuedActions[unitIndex] = null;\n\n  return Ok(updateBattleState(state, {\n    queuedActions: newQueuedActions,\n    remainingMana: state.remainingMana + action.manaCost,\n  }));\n}\n\n/**\n * Queue Djinn activation\n * PR-DJINN-CORE: Adds Djinn to activation queue\n *\n * @param state - Current battle state\n * @param djinnId - Djinn ID to activate\n * @returns Result with updated battle state or error message\n */\nexport function queueDjinn(state: BattleState, djinnId: string): Result<BattleState, string> {\n  if (state.phase !== 'planning') {\n    return Err('Can only queue Djinn during planning phase');\n  }\n\n  if (!canActivateDjinn(state.playerTeam, djinnId)) {\n    return Err(`Djinn ${djinnId} cannot be activated (not Set)`);\n  }\n\n  if (state.queuedDjinn.includes(djinnId)) {\n    return Ok(state); // Already queued\n  }\n\n  return Ok(updateBattleState(state, {\n    queuedDjinn: [...state.queuedDjinn, djinnId],\n  }));\n}\n\n/**\n * Unqueue Djinn activation\n * PR-DJINN-CORE: Removes Djinn from activation queue\n *\n * @param state - Current battle state\n * @param djinnId - Djinn ID to unqueue\n * @returns Result with updated battle state or error message\n */\nexport function unqueueDjinn(state: BattleState, djinnId: string): Result<BattleState, string> {\n  if (state.phase !== 'planning') {\n    return Err('Can only unqueue Djinn during planning phase');\n  }\n\n  return Ok(updateBattleState(state, {\n    queuedDjinn: state.queuedDjinn.filter(id => id !== djinnId),\n  }));\n}\n\n/**\n * Refresh mana pool at start of planning phase\n * PR-MANA-QUEUE: Resets mana to max\n *\n * @param state - Current battle state\n * @returns Updated battle state\n */\nexport function refreshMana(state: BattleState): BattleState {\n  return updateBattleState(state, {\n    remainingMana: state.maxMana,\n  });\n}\n\n/**\n * Validate queue is ready for execution\n * Returns Result instead of throwing so UI can handle failures gracefully\n */\nfunction validateQueueForExecution(state: BattleState): Result<BattleState, string> {\n  if (state.phase !== 'planning') {\n    return Err('Can only execute round from planning phase');\n  }\n  \n  // BUG FIX: Only require actions for ALIVE units, not all units\n  // Dead units don't need actions queued\n  const aliveUnits = state.playerTeam.units.filter(u => !isUnitKO(u));\n  const aliveUnitCount = aliveUnits.length;\n  \n  // Check that we have actions for all alive units\n  // Note: queuedActions array may have null entries for dead units, which is fine\n  const aliveUnitActions = state.queuedActions.filter((action, index) => {\n    const unit = state.playerTeam.units[index];\n    return unit && !isUnitKO(unit) && action !== null;\n  });\n  \n  if (aliveUnitActions.length !== aliveUnitCount) {\n    return Err(`Cannot execute: queue incomplete. Expected ${aliveUnitCount} actions for alive units, got ${aliveUnitActions.length}`);\n  }\n  \n  // BUG FIX: Validate against maxMana, not remainingMana\n  // remainingMana was already decremented during queueing, so we need to check\n  // the total cost against the original pool\n  if (!validateQueuedActions(state.maxMana, state.queuedActions)) {\n    return Err('Cannot execute: actions exceed mana budget');\n  }\n\n  return Ok(state);\n}\n\n/**\n * Transition battle state to executing phase\n */\nfunction transitionToExecutingPhase(state: BattleState): BattleState {\n  return updateBattleState(state, {\n    phase: 'executing',\n    executionIndex: 0,\n  });\n}\n\n/**\n * Execute all actions (player and enemy) in SPD order\n * FIX: Interleaves player and enemy actions by speed instead of running all player actions first\n */\nfunction executeAllActionsPhase(\n  state: BattleState,\n  rng: PRNG\n): { state: BattleState; events: readonly BattleEvent[] } {\n  // Gather player actions\n  const playerActions = state.queuedActions.filter((a): a is QueuedAction => a !== null);\n\n  // Generate enemy actions\n  const enemyActions = generateEnemyActions(state, rng);\n\n  // Combine and sort all actions by SPD\n  const allActions = [...playerActions, ...enemyActions];\n  const sortedActions = sortActionsBySPD(allActions, state.playerTeam, state.enemies);\n\n  let currentState = state;\n  const events: BattleEvent[] = [];\n\n  for (const action of sortedActions) {\n    // Find actor in either team\n    const allUnits = [...currentState.playerTeam.units, ...currentState.enemies];\n    const actor = allUnits.find(u => u.id === action.unitId);\n\n    if (!actor || isUnitKO(actor)) {\n      continue;\n    }\n\n    const validTargets = resolveValidTargets(action, currentState);\n    if (validTargets.length === 0) {\n      continue;\n    }\n\n    const actionResult = performAction(\n      currentState,\n      action.unitId,\n      action.abilityId || 'strike',\n      validTargets,\n      rng\n    );\n\n    if (!actionResult.ok) {\n      // Action failed, skip to next\n      continue;\n    }\n\n    currentState = actionResult.value.state;\n    events.push(...actionResult.value.events);\n\n    // Only generate mana for player basic attacks\n    const isPlayerAction = currentState.playerTeam.units.some(u => u.id === action.unitId);\n    if (isPlayerAction && shouldGenerateMana(action, actionResult.value)) {\n      const manaGained = 1;\n      const newMana = Math.min(currentState.remainingMana + manaGained, currentState.maxMana);\n      currentState = updateBattleState(currentState, {\n        remainingMana: newMana,\n      });\n\n      events.push({\n        type: 'mana-generated',\n        amount: manaGained,\n        source: action.unitId,\n        newTotal: newMana,\n      });\n    }\n  }\n\n  return { state: currentState, events };\n}\n\n/**\n * Check if battle has ended (victory or defeat)\n * Returns battle result or null if battle continues\n */\nfunction checkBattleEndPhase(state: BattleState): 'PLAYER_VICTORY' | 'PLAYER_DEFEAT' | null {\n  return checkBattleEnd(state);\n}\n\n/**\n * Transition to victory or defeat phase\n */\nfunction transitionToVictoryOrDefeat(\n  state: BattleState,\n  result: 'PLAYER_VICTORY' | 'PLAYER_DEFEAT'\n): BattleState {\n  return updateBattleState(state, {\n    phase: result === 'PLAYER_VICTORY' ? 'victory' : 'defeat',\n    status: result,\n  });\n}\n\n/**\n * Transition back to planning phase for next round\n */\nfunction transitionToPlanningPhase(state: BattleState): BattleState {\n  const updatedTimers = { ...state.djinnRecoveryTimers };\n  const updatedTrackers = { ...state.playerTeam.djinnTrackers };\n\n  for (const [djinnId, timer] of Object.entries(updatedTimers)) {\n    if (timer > 0) {\n      updatedTimers[djinnId] = timer - 1;\n      if (updatedTimers[djinnId] === 0) {\n        delete updatedTimers[djinnId];\n        const tracker = updatedTrackers[djinnId];\n        if (tracker) {\n          updatedTrackers[djinnId] = {\n            ...tracker,\n            state: 'Set',\n          };\n        }\n      }\n    } else {\n      delete updatedTimers[djinnId];\n    }\n  }\n\n  let updatedTeam = updateTeam(state.playerTeam, {\n    djinnTrackers: updatedTrackers,\n  });\n\n  const unitsWithUpdatedAbilities = updatedTeam.units.map(unit =>\n    mergeDjinnAbilitiesIntoUnit(unit, updatedTeam)\n  );\n\n  // Clamp HP/PP after Djinn recovery (stat bonuses may have changed)\n  const unitsWithClampedStats = unitsWithUpdatedAbilities.map(unit => {\n    const effectiveStats = calculateEffectiveStats(unit, updatedTeam);\n    const newMaxHp = effectiveStats.hp;\n    let updated = unit;\n    if (unit.currentHp > newMaxHp) {\n      updated = { ...updated, currentHp: newMaxHp };\n    }\n    // Note: PP system removed, no need to clamp currentPp\n    return updated;\n  });\n\n  updatedTeam = updateTeam(updatedTeam, {\n    units: unitsWithClampedStats,\n  });\n\n  const nextState = updateBattleState(state, {\n    phase: 'planning',\n    roundNumber: state.roundNumber + 1,\n    currentQueueIndex: 0,\n    queuedActions: createEmptyQueue(updatedTeam.units.length),\n    queuedDjinn: [],\n    executionIndex: 0,\n    playerTeam: updatedTeam,\n    djinnRecoveryTimers: updatedTimers,\n  });\n  return refreshMana(nextState);\n}\n\n/**\n * Execute a complete round\n * PR-QUEUE-BATTLE: Executes Djinn â†’ all actions interleaved by SPD\n * FIX: Player and enemy actions now execute in SPD order, not in separate phases\n *\n * @param state - Current battle state\n * @param rng - PRNG instance\n * @returns Updated battle state and events\n */\nexport function executeRound(\n  state: BattleState,\n  rng: PRNG\n): { state: BattleState; events: readonly BattleEvent[] } {\n  const validation = validateQueueForExecution(state);\n  if (!validation.ok) {\n    // In development, surface a warning but do not throw to avoid crashing the UI\n    if (process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.warn(validation.error);\n    }\n    return { state, events: [] };\n  }\n\n  let currentState = transitionToExecutingPhase(state);\n  const allEvents: BattleEvent[] = [];\n\n  if (currentState.queuedDjinn.length > 0) {\n    const djinnResult = executeDjinnSummons(currentState, rng);\n    currentState = djinnResult.state;\n    allEvents.push(...djinnResult.events);\n  }\n\n  // Execute all actions (player and enemy) interleaved by SPD\n  const actionsResult = executeAllActionsPhase(currentState, rng);\n  currentState = actionsResult.state;\n  allEvents.push(...actionsResult.events);\n\n  const battleEnd = checkBattleEndPhase(currentState);\n  if (battleEnd) {\n    currentState = transitionToVictoryOrDefeat(currentState, battleEnd);\n    allEvents.push({\n      type: 'battle-end',\n      result: battleEnd,\n    });\n  } else {\n    const prePlanningState = currentState;\n    currentState = transitionToPlanningPhase(currentState);\n    const recoveredDjinnIds = getRecoveredDjinnIds(\n      prePlanningState.playerTeam,\n      currentState.playerTeam\n    );\n    if (recoveredDjinnIds.length > 0) {\n      const preBonuses = snapshotDjinnBonuses(prePlanningState.playerTeam);\n      const postBonuses = snapshotDjinnBonuses(currentState.playerTeam);\n      const recoveryEvents = buildDjinnStateChangeEvents(\n        preBonuses,\n        postBonuses,\n        currentState.playerTeam.units,\n        'djinn-recovered',\n        recoveredDjinnIds\n      );\n      allEvents.push(...recoveryEvents);\n    }\n  }\n\n  return {\n    state: currentState,\n    events: allEvents,\n  };\n}\n\n/**\n * Execute Djinn summons\n * PR-DJINN-CORE: Handles Djinn activation and damage\n */\nfunction executeDjinnSummons(\n  state: BattleState,\n  rng: PRNG\n): { state: BattleState; events: readonly BattleEvent[] } {\n  const events: BattleEvent[] = [];\n  let currentState = state;\n  let updatedTeam = state.playerTeam;\n\n  if (state.queuedDjinn.length === 0) {\n    return { state, events };\n  }\n\n  const djinnCount = state.queuedDjinn.length as 1 | 2 | 3;\n  const preBonuses = snapshotDjinnBonuses(state.playerTeam);\n  const queuedDjinnData = state.queuedDjinn\n    .map((id) => DJINN[id])\n    .filter((djinn): djinn is NonNullable<typeof djinn> => Boolean(djinn));\n\n  const activationCount = state.queuedDjinn.length;\n  const recoveryTime = activationCount + 1;\n\n  // Update Djinn states to Standby\n  const updatedTrackers = { ...updatedTeam.djinnTrackers };\n  for (const djinnId of state.queuedDjinn) {\n    const tracker = updatedTrackers[djinnId];\n    if (tracker) {\n      updatedTrackers[djinnId] = {\n        ...tracker,\n        state: 'Standby',\n        lastActivatedTurn: state.roundNumber,\n      };\n    }\n  }\n\n  updatedTeam = updateTeam(updatedTeam, {\n    djinnTrackers: updatedTrackers,\n  });\n\n  const unitsWithUpdatedAbilities = updatedTeam.units.map(unit =>\n    mergeDjinnAbilitiesIntoUnit(unit, updatedTeam)\n  );\n\n  // Clamp HP after Djinn state change (stat bonuses may have changed)\n  const unitsWithClampedHP = unitsWithUpdatedAbilities.map(unit => {\n    const effectiveStats = calculateEffectiveStats(unit, updatedTeam);\n    const newMaxHp = effectiveStats.hp;\n    if (unit.currentHp > newMaxHp) {\n      return { ...unit, currentHp: newMaxHp };\n    }\n    return unit;\n  });\n\n  updatedTeam = updateTeam(updatedTeam, {\n    units: unitsWithClampedHP,\n  });\n\n  const postBonuses = snapshotDjinnBonuses(updatedTeam);\n  const standbyEvents = buildDjinnStateChangeEvents(\n    preBonuses,\n    postBonuses,\n    updatedTeam.units,\n    'djinn-standby',\n    state.queuedDjinn\n  );\n\n  events.push(...standbyEvents);\n\n  const newRecoveryTimers = { ...state.djinnRecoveryTimers };\n  for (const djinnId of state.queuedDjinn) {\n    newRecoveryTimers[djinnId] = recoveryTime;\n  }\n\n  currentState = updateBattleState(currentState, {\n    playerTeam: updatedTeam,\n    djinnRecoveryTimers: newRecoveryTimers,\n  });\n\n  for (const djinn of queuedDjinnData) {\n    const summonEffect = djinn.summonEffect;\n    const targetsHit: string[] = [];\n    const targetsHealed: string[] = [];\n\n    if (summonEffect.type === 'damage') {\n      const damageAmount = summonEffect.damage ?? calculateSummonDamage(djinnCount);\n      if (djinnCount === 3) {\n        const updatedEnemies = currentState.enemies.map(enemy => {\n          if (isUnitKO(enemy)) return enemy;\n          const newHp = Math.max(0, enemy.currentHp - damageAmount);\n          events.push({\n            type: 'hit',\n            targetId: enemy.id,\n            amount: damageAmount,\n          });\n          targetsHit.push(enemy.id);\n          return { ...enemy, currentHp: newHp };\n        });\n        currentState = updateBattleState(currentState, {\n          enemies: updatedEnemies,\n        });\n      } else {\n        const aliveEnemies = currentState.enemies.filter(e => !isUnitKO(e));\n        if (aliveEnemies.length > 0) {\n          const targetIndex = Math.floor(rng.next() * aliveEnemies.length);\n          const target = aliveEnemies[targetIndex]!;\n          const newHp = Math.max(0, target.currentHp - damageAmount);\n          events.push({\n            type: 'hit',\n            targetId: target.id,\n            amount: damageAmount,\n          });\n          targetsHit.push(target.id);\n          const updatedEnemies = currentState.enemies.map(e =>\n            e.id === target.id ? { ...e, currentHp: newHp } : e\n          );\n          currentState = updateBattleState(currentState, {\n            enemies: updatedEnemies,\n          });\n        }\n      }\n    } else if (summonEffect.type === 'heal') {\n      const healAmount = summonEffect.healAmount;\n      const healedUnits = currentState.playerTeam.units.map((unit) => {\n        const maxHp = calculateEffectiveStats(unit, currentState.playerTeam).hp;\n        const newHp = Math.min(unit.currentHp + healAmount, maxHp);\n        if (newHp !== unit.currentHp) {\n          targetsHealed.push(unit.id);\n        }\n        return { ...unit, currentHp: newHp };\n      });\n      const updatedTeamAfterHeal = updateTeam(currentState.playerTeam, { units: healedUnits });\n      currentState = updateBattleState(currentState, { playerTeam: updatedTeamAfterHeal });\n    } else if (summonEffect.type === 'buff') {\n      const statBonus = summonEffect.statBonus;\n      const buffedUnits = currentState.playerTeam.units.map((unit) => {\n        let updated = unit;\n        (Object.entries(statBonus) as Array<[keyof typeof statBonus, number | undefined]>).forEach(([stat, value]) => {\n          if (value !== undefined) {\n            const status: typeof unit.statusEffects[number] = {\n              type: 'buff',\n              stat: stat as keyof typeof unit.baseStats,\n              modifier: value,\n              duration: 3,\n            };\n            updated = applyStatusToUnit(updated, status);\n          }\n        });\n        return updated;\n      });\n      const updatedTeamAfterBuff = updateTeam(currentState.playerTeam, { units: buffedUnits });\n      currentState = updateBattleState(currentState, { playerTeam: updatedTeamAfterBuff });\n    } else if (summonEffect.type === 'special') {\n      // Apply a light paralyze effect to all enemies as a placeholder special\n      const updatedEnemies = currentState.enemies.map((enemy) => {\n        if (isUnitKO(enemy)) return enemy;\n        const status: typeof enemy.statusEffects[number] = {\n          type: 'paralyze',\n          duration: 1,\n        };\n        return applyStatusToUnit(enemy, status);\n      });\n      currentState = updateBattleState(currentState, { enemies: updatedEnemies });\n    }\n\n    const abilityTargets =\n      summonEffect.type === 'heal'\n        ? targetsHealed\n        : summonEffect.type === 'damage'\n          ? targetsHit\n          : summonEffect.type === 'buff'\n            ? currentState.playerTeam.units.map((u) => u.id)\n            : currentState.enemies.filter((e) => !isUnitKO(e)).map((e) => e.id);\n\n    if (abilityTargets.length > 0) {\n      events.push({\n        type: 'ability',\n        casterId: 'djinn-summon',\n        abilityId: `summon-${djinn.id}`,\n        targets: abilityTargets,\n      });\n    }\n\n    if (summonEffect.type === 'heal') {\n      for (const id of targetsHealed) {\n        events.push({ type: 'heal', targetId: id, amount: summonEffect.healAmount });\n      }\n    }\n  }\n\n  return { state: currentState, events };\n}\n\n/**\n * Sort actions by SPD (fastest first)\n * PR-QUEUE-BATTLE: Orders actions by effective SPD\n * BUG FIX: Correctly calculate SPD for enemy units without applying player team Djinn bonuses\n */\nfunction sortActionsBySPD(\n  actions: readonly QueuedAction[],\n  playerTeam: Team,\n  enemies: readonly Unit[]\n): QueuedAction[] {\n  const allUnits = [...playerTeam.units, ...enemies];\n\n  // Create an empty team for enemy stat calculations (no Djinn bonuses)\n  const emptyTeam: Team = {\n    equippedDjinn: [],\n    djinnTrackers: {},\n    units: [],\n    collectedDjinn: [],\n    currentTurn: 0,\n    activationsThisTurn: {},\n    djinnStates: {},\n  };\n\n  return [...actions].sort((a, b) => {\n    const unitA = allUnits.find(u => u.id === a.unitId);\n    const unitB = allUnits.find(u => u.id === b.unitId);\n\n    if (!unitA || !unitB) return 0;\n\n    // Determine if each unit is a player unit or enemy\n    const isPlayerA = playerTeam.units.some(u => u.id === a.unitId);\n    const isPlayerB = playerTeam.units.some(u => u.id === b.unitId);\n\n    // Calculate SPD with correct team context\n    // Player units: use playerTeam for Djinn bonuses\n    // Enemy units: use emptyTeam (no Djinn bonuses)\n    const spdA = isPlayerA\n      ? getEffectiveSPD(unitA, playerTeam)\n      : getEffectiveSPD(unitA, emptyTeam);\n    const spdB = isPlayerB\n      ? getEffectiveSPD(unitB, playerTeam)\n      : getEffectiveSPD(unitB, emptyTeam);\n\n    if (spdB !== spdA) {\n      return spdB - spdA; // Descending (fastest first)\n    }\n\n    // Tie-breaker: player units before enemies, then by ID\n    if (isPlayerA !== isPlayerB) {\n      return isPlayerA ? -1 : 1;\n    }\n\n    return a.unitId.localeCompare(b.unitId);\n  });\n}\n\n/**\n * Resolve valid targets for an action\n * PR-QUEUE-BATTLE: Retargets if original target is KO'd, preserving ability target type\n */\nfunction resolveValidTargets(\n  action: QueuedAction,\n  state: BattleState\n): readonly string[] {\n  const allUnits = [...state.playerTeam.units, ...state.enemies];\n  const actor = allUnits.find(u => u.id === action.unitId);\n  \n  // Filter out KO'd targets\n  const validTargets = action.targetIds.filter(id => {\n    const unit = allUnits.find(u => u.id === id);\n    return unit && !isUnitKO(unit);\n  });\n\n  // If we have valid targets, return them\n  if (validTargets.length > 0) {\n    return validTargets;\n  }\n\n  // No valid targets - need to retarget\n  // Determine the ability's target side (allies vs enemies) and targeting mode (single vs all)\n  type TargetSide = 'ally' | 'enemy';\n  type TargetMode = 'single' | 'all';\n\n  let targetSide: TargetSide = 'enemy'; // Default to enemy targeting\n  let targetMode: TargetMode = 'single'; // Default to single-target\n\n  if (actor && action.abilityId) {\n    // First try to find ability in actor's abilities array\n    let ability = actor.abilities.find(a => a.id === action.abilityId);\n\n    // Fallback to global ABILITIES record if not found in actor's abilities\n    // (This handles cases where ability is from Djinn or temporary effects)\n    if (!ability) {\n      ability = ABILITIES[action.abilityId];\n    }\n\n    if (ability) {\n      // Determine target side and mode based on ability's targets field\n      const targets = ability.targets;\n\n      if (targets === 'single-ally' || targets === 'all-allies' || targets === 'self') {\n        targetSide = 'ally';\n      } else {\n        targetSide = 'enemy';\n      }\n\n      if (targets === 'all-enemies' || targets === 'all-allies') {\n        targetMode = 'all';\n      } else {\n        targetMode = 'single';\n      }\n    } else {\n      // Ability not found anywhere - this is unexpected, but we can try to infer from ability type\n      // This is a defensive fallback to prevent heals/buffs from targeting enemies\n      console.warn(`[QueueBattle] Ability ${action.abilityId} not found for actor ${actor.id}`);\n    }\n  } else if (action.abilityId === null) {\n    // Basic attack is always single-target enemy\n    targetSide = 'enemy';\n    targetMode = 'single';\n  }\n\n  // Retarget based on ability's intended target side, NOT action side\n  const isPlayerAction = state.playerTeam.units.some(u => u.id === action.unitId);\n\n  if (targetSide === 'ally') {\n    // Ability targets allies - retarget to actor's allies\n    const allies = isPlayerAction\n      ? state.playerTeam.units.filter(u => !isUnitKO(u))\n      : state.enemies.filter(e => !isUnitKO(e));\n\n    if (allies.length === 0) {\n      return [];\n    }\n\n    if (targetMode === 'all') {\n      // Multi-target: return all alive allies\n      return allies.map(u => u.id);\n    } else {\n      // Single-target: return first alive ally\n      return [allies[0]!.id];\n    }\n  } else {\n    // Ability targets enemies - retarget to actor's enemies\n    const enemies = isPlayerAction\n      ? state.enemies.filter(e => !isUnitKO(e))\n      : state.playerTeam.units.filter(u => !isUnitKO(u));\n\n    if (enemies.length === 0) {\n      return [];\n    }\n\n    if (targetMode === 'all') {\n      // Multi-target: return all alive enemies\n      return enemies.map(u => u.id);\n    } else {\n      // Single-target: return first alive enemy\n      return [enemies[0]!.id];\n    }\n  }\n}\n\n/**\n * Generate enemy actions using AI\n * PR-QUEUE-BATTLE: Creates queued actions for all enemies\n */\nfunction generateEnemyActions(\n  state: BattleState,\n  rng: PRNG\n): readonly QueuedAction[] {\n  const actions: QueuedAction[] = [];\n\n  for (const enemy of state.enemies) {\n    if (isUnitKO(enemy)) continue;\n\n    try {\n      const decision = makeAIDecision(state, enemy.id, rng);\n      if (decision) {\n        actions.push({\n          unitId: enemy.id,\n          abilityId: decision.abilityId,\n          targetIds: decision.targetIds,\n          manaCost: 0, // Enemies don't use mana\n        });\n      }\n    } catch (error) {\n      // Fallback to basic attack if AI decision fails (e.g., no usable abilities)\n      console.warn(`AI decision failed for enemy ${enemy.id}, using basic attack:`, error);\n      const alivePlayers = state.playerTeam.units.filter(u => !isUnitKO(u));\n      if (alivePlayers.length > 0) {\n        actions.push({\n          unitId: enemy.id,\n          abilityId: null,\n          targetIds: [alivePlayers[0]!.id],\n          manaCost: 0,\n        });\n      }\n    }\n  }\n\n  return actions;\n}\n\n/**\n * Check if battle has ended\n * PR-QUEUE-BATTLE: Determines victory/defeat\n */\nfunction checkBattleEnd(state: BattleState): 'PLAYER_VICTORY' | 'PLAYER_DEFEAT' | null {\n  const allEnemiesKO = state.enemies.every(e => isUnitKO(e));\n  const allPlayersKO = state.playerTeam.units.every(u => isUnitKO(u));\n\n  // BUG FIX: Defensive check - verify that allPlayersKO is actually correct\n  // If we detect a mismatch (allPlayersKO is true but some units have HP > 0),\n  // this indicates a bug - log and return null to prevent incorrect defeat\n  const aliveUnits = state.playerTeam.units.filter(u => !isUnitKO(u));\n  if (allPlayersKO && aliveUnits.length > 0) {\n    console.warn('[QueueBattle] BUG: checkBattleEnd detected all players KO but some units are alive!', {\n      units: state.playerTeam.units.map(u => ({ id: u.id, currentHp: u.currentHp, isKO: isUnitKO(u) })),\n      aliveUnits: aliveUnits.map(u => ({ id: u.id, currentHp: u.currentHp })),\n      allPlayersKO,\n    });\n    return null; // Continue battle - this is a false positive\n  }\n\n  // Check for simultaneous wipe-out (rare but possible)\n  if (allEnemiesKO && allPlayersKO) {\n    return 'PLAYER_DEFEAT'; // Treat simultaneous wipe-out as defeat\n  }\n\n  if (allEnemiesKO) {\n    return 'PLAYER_VICTORY';\n  }\n  if (allPlayersKO) {\n    return 'PLAYER_DEFEAT';\n  }\n  return null;\n}\n\ntype DjinnStateChange = 'djinn-standby' | 'djinn-recovered';\n\nfunction snapshotDjinnBonuses(team: Team): Record<string, Partial<Stats>> {\n  const snapshot: Record<string, Partial<Stats>> = {};\n  for (const unit of team.units) {\n    snapshot[unit.id] = calculateDjinnBonusesForUnit(unit, team);\n  }\n  return snapshot;\n}\n\nfunction buildDjinnStateChangeEvents(\n  before: Record<string, Partial<Stats>>,\n  after: Record<string, Partial<Stats>>,\n  units: readonly Unit[],\n  type: DjinnStateChange,\n  djinnIds: readonly string[]\n): BattleEvent[] {\n  if (djinnIds.length === 0) {\n    return [];\n  }\n\n  const events: BattleEvent[] = [];\n  for (const unit of units) {\n    const prev = before[unit.id];\n    const next = after[unit.id];\n    const atkDelta = (next?.atk ?? 0) - (prev?.atk ?? 0);\n    const defDelta = (next?.def ?? 0) - (prev?.def ?? 0);\n    if (atkDelta === 0 && defDelta === 0) {\n      continue;\n    }\n\n    events.push({\n      type,\n      unitId: unit.id,\n      djinnIds,\n      atkDelta,\n      defDelta,\n    });\n  }\n\n  return events;\n}\n\nfunction getRecoveredDjinnIds(before: Team, after: Team): string[] {\n  const recovered: string[] = [];\n  for (const [djinnId, tracker] of Object.entries(after.djinnTrackers)) {\n    const previousState = before.djinnTrackers[djinnId]?.state;\n    if (previousState && previousState !== 'Set' && tracker.state === 'Set') {\n      recovered.push(djinnId);\n    }\n  }\n  return recovered;\n}\n\n/**\n * Get planning phase turn order (indices of player units sorted by SPD)\n * PR-QUEUE-BATTLE: Helps UI guide player through units in speed order\n */\nexport function getPlanningTurnOrder(state: BattleState): number[] {\n  // Create array of { index, spd } objects\n  const unitSpeeds = state.playerTeam.units.map((unit, index) => ({\n    index,\n    spd: isUnitKO(unit) ? -1 : getEffectiveSPD(unit, state.playerTeam),\n    isKo: isUnitKO(unit)\n  }));\n\n  // Sort by SPD descending\n  unitSpeeds.sort((a, b) => {\n    // Move KO'd units to end\n    if (a.isKo && !b.isKo) return 1;\n    if (!a.isKo && b.isKo) return -1;\n    \n    if (b.spd !== a.spd) {\n      return b.spd - a.spd; // Descending\n    }\n    // Stable sort by index for ties\n    return a.index - b.index;\n  });\n\n  return unitSpeeds.map(u => u.index);\n}\n\nexport const queueBattleServiceInternals = {\n  validateQueueForExecution,\n  transitionToExecutingPhase,\n  executeAllActionsPhase,\n  checkBattleEndPhase,\n  transitionToVictoryOrDefeat,\n  transitionToPlanningPhase,\n};\n","/**\n * Healing algorithms\n * Pure utilities for restoring unit HP/status\n */\n\nimport type { Unit } from '../models/Unit';\nimport { calculateMaxHp } from '../models/Unit';\n\n/**\n * Auto-heal all units after battle\n * Restores HP to max and clears status effects (pure)\n */\nexport function autoHealUnits(units: readonly Unit[]): readonly Unit[] {\n  return units.map(unit => {\n    const maxHp = calculateMaxHp(unit);\n    return {\n      ...unit,\n      currentHp: maxHp,\n      statusEffects: [],\n    };\n  });\n}\n","import { z } from 'zod';\n\n/**\n * Zod schema for Stats validation\n */\nexport const StatsSchema = z.object({\n  hp: z.number().int().min(0),\n  pp: z.number().int().min(0),\n  atk: z.number().int().min(0),\n  def: z.number().int().min(0),\n  mag: z.number().int().min(0),\n  spd: z.number().int().min(0),\n});\n\nexport type Stats = z.infer<typeof StatsSchema>;\n\n","import { z } from 'zod';\n\nexport const ContentAvailabilitySchema = z.array(z.enum(['campaign', 'tower'])).min(1);\n\nexport type ContentAvailability = z.infer<typeof ContentAvailabilitySchema>;\n\n","import { z } from 'zod';\nimport { ContentAvailabilitySchema } from './ContentAvailabilitySchema';\n\n/**\n * Element type for equipment restrictions\n * Defined here to avoid circular dependency with UnitSchema\n */\nconst ElementSchema = z.enum(['Venus', 'Mars', 'Mercury', 'Jupiter', 'Neutral']);\n\n/**\n * Stat bonus schema for equipment (allows negative values for penalties)\n * Unlike StatsSchema, this allows negative values since equipment can have penalties\n */\nexport const EquipmentStatBonusSchema = z.object({\n  hp: z.number().int(),\n  pp: z.number().int(),\n  atk: z.number().int(),\n  def: z.number().int(),\n  mag: z.number().int(),\n  spd: z.number().int(),\n}).partial();\n\n/**\n * Zod schema for EquipmentSlot\n */\nexport const EquipmentSlotSchema = z.enum(['weapon', 'armor', 'helm', 'boots', 'accessory']);\n\n/**\n * Zod schema for EquipmentTier\n */\nexport const EquipmentTierSchema = z.enum([\n  'basic',\n  'bronze',\n  'iron',\n  'steel',\n  'silver',\n  'mythril',\n  'legendary',\n  'artifact',\n]);\n\n/**\n * Zod schema for Equipment validation\n * CHANGED: allowedUnits â†’ allowedElements for element-based equipment restrictions\n */\nexport const EquipmentSchema = z.object({\n  id: z.string().min(1),\n  name: z.string().min(1),\n  slot: EquipmentSlotSchema,\n  tier: EquipmentTierSchema,\n  cost: z.number().int().min(0),\n  statBonus: EquipmentStatBonusSchema.default({}), // Default to empty object if missing\n  allowedElements: z.array(ElementSchema).min(1).readonly(), // CHANGED: Make readonly for compatibility with Equipment type\n  unlocksAbility: z.string().optional(),\n  equipmentUnlocksPermanent: z.boolean().optional(),\n  elementalResist: z.number().min(0).max(1).optional(), // 0-1 range (0% to 100%)\n  alwaysFirstTurn: z.boolean().optional(),\n  availableIn: ContentAvailabilitySchema.optional().readonly(),\n});\n\nexport type Equipment = z.infer<typeof EquipmentSchema>;\n\n/**\n * Zod schema for EquipmentLoadout\n */\nexport const EquipmentLoadoutSchema = z.object({\n  weapon: EquipmentSchema.nullable(),\n  armor: EquipmentSchema.nullable(),\n  helm: EquipmentSchema.nullable(),\n  boots: EquipmentSchema.nullable(),\n  accessory: EquipmentSchema.nullable(),\n});\n\nexport type EquipmentLoadout = z.infer<typeof EquipmentLoadoutSchema>;\n","import { z } from 'zod';\n\n/**\n * Zod schema for Ability validation\n * Single source of truth for ability data structure\n */\n\n/**\n * Regex pattern for kebab-case ability IDs\n * Enforces: lowercase alphanumerics and hyphens only\n */\nexport const abilityIdRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;\n\nexport const AbilitySchema = z.object({\n  id: z.string().regex(abilityIdRegex, {\n    message: \"Ability ID must be kebab-case (lowercase alphanumerics and hyphens only)\",\n  }),\n  name: z.string().min(1),\n  type: z.enum(['physical', 'psynergy', 'healing', 'buff', 'debuff', 'summon']),\n  element: z.enum(['Venus', 'Mars', 'Jupiter', 'Mercury', 'Neutral']).optional(),\n  manaCost: z.number().int().min(0).max(5), // Cannot be negative! Max 5 for mana pool system\n  basePower: z.number().int().min(0), // Cannot be negative!\n  targets: z.enum(['single-enemy', 'all-enemies', 'single-ally', 'all-allies', 'self']),\n  unlockLevel: z.number().int().min(1).max(20),\n  kind: z.enum(['attack', 'psynergy']).optional(),\n  description: z.string(),\n  \n  // Optional properties\n  chainDamage: z.boolean().optional(),\n  revivesFallen: z.boolean().optional(),\n  buffEffect: z.object({\n    atk: z.number().optional(),\n    def: z.number().optional(),\n    mag: z.number().optional(),\n    spd: z.number().optional(),\n  }).optional(),\n  duration: z.number().int().min(1).optional(),\n  \n  // Status effect applied on hit (for physical/psynergy abilities)\n  statusEffect: z.object({\n    type: z.enum(['poison', 'burn', 'freeze', 'paralyze', 'stun']),\n    duration: z.number().int().min(1),\n    chance: z.number().min(0).max(1).optional(), // Probability of applying (0-1), defaults to 1.0\n  }).optional(),\n\n  // Debuff effects (stat reductions applied to targets)\n  debuffEffect: z.object({\n    atk: z.number().optional(),\n    def: z.number().optional(),\n    mag: z.number().optional(),\n    spd: z.number().optional(),\n    hp: z.number().optional(), // Max HP reduction\n  }).optional(),\n\n  // Heal over time effect\n  healOverTime: z.object({\n    amount: z.number().int().min(1), // HP restored per turn\n    duration: z.number().int().min(1), // Number of turns\n  }).optional(),\n\n  // Multi-hit attacks\n  hitCount: z.number().int().min(1).max(10).optional(), // Number of hits (2-4 typical)\n\n  // Revive mechanics\n  revive: z.boolean().optional(), // Can revive KO'd units\n  reviveHPPercent: z.number().min(0).max(1).optional(), // HP% restored when reviving (0-1)\n\n  // Phase 2: Advanced offense mechanics\n  ignoreDefensePercent: z.number().min(0).max(1).optional(), // % of target DEF to ignore (default 0)\n  splashDamagePercent: z.number().min(0).max(1).optional(), // % damage dealt to non-primary targets (default 0)\n\n  // Phase 2: Shield granting\n  shieldCharges: z.number().int().min(1).max(99).optional(), // Number of hit charges granted when cast\n\n  // Phase 2: Status cleanse\n  removeStatusEffects: z.union([\n    z.object({ type: z.literal('all') }),\n    z.object({ type: z.literal('negative') }),\n    z.object({\n      type: z.literal('byType'),\n      statuses: z.array(z.enum(['poison', 'burn', 'freeze', 'paralyze', 'stun', 'debuff'])),\n    }),\n  ]).optional(),\n\n  // Phase 2: Damage reduction granting\n  damageReductionPercent: z.number().min(0).max(1).optional(), // % damage reduction granted to target(s)\n\n  // Phase 2: Elemental resistance granting\n  elementalResistance: z.object({\n    element: z.enum(['Venus', 'Mars', 'Mercury', 'Jupiter']),\n    modifier: z.number(), // Positive = resistance, negative = weakness\n  }).optional(),\n\n  // Phase 2: Immunity granting\n  grantImmunity: z.object({\n    all: z.boolean(), // If true, immune to all negative statuses\n    types: z.array(z.enum(['poison', 'burn', 'freeze', 'paralyze', 'stun', 'debuff'])).optional(), // Specific immunities\n    duration: z.number().int().min(1), // Duration in turns\n  }).optional(),\n\n  // AI hints (optional metadata for AI decision-making)\n  aiHints: z.object({\n    priority: z.number().min(0).max(3).optional(),\n    target: z.enum(['weakest', 'random', 'lowestRes', 'healerFirst', 'highestDef']).optional(),\n    avoidOverkill: z.boolean().optional(),\n    opener: z.boolean().optional(),\n  }).optional(),\n});\n\nexport type Ability = z.infer<typeof AbilitySchema>;\n","import { z } from 'zod';\nimport { StatsSchema } from './StatsSchema';\nimport { EquipmentLoadoutSchema } from './EquipmentSchema';\nimport { AbilitySchema } from './AbilitySchema';\nimport { ContentAvailabilitySchema } from './ContentAvailabilitySchema';\n\n/**\n * Zod schema for Element\n */\nexport const ElementSchema = z.enum(['Venus', 'Mars', 'Mercury', 'Jupiter', 'Neutral']);\n\nexport type Element = z.infer<typeof ElementSchema>;\n\n/**\n * Zod schema for UnitRole\n */\nexport const UnitRoleSchema = z.enum([\n  'Balanced Warrior',\n  'Pure DPS',\n  'Elemental Mage',\n  'Healer',\n  'Rogue Assassin',\n  'AoE Fire Mage',\n  'Support Buffer',\n  'Defensive Tank',\n  'Versatile Scholar',\n  'Master Warrior',\n]);\n\nexport type UnitRole = z.infer<typeof UnitRoleSchema>;\n\n/**\n * Zod schema for DjinnState\n */\nexport const DjinnStateSchema = z.enum(['Set', 'Standby', 'Recovery']);\n\nexport type DjinnState = z.infer<typeof DjinnStateSchema>;\n\n/**\n * Zod schema for StatKey\n */\nconst StatKeySchema = z.enum(['hp', 'pp', 'atk', 'def', 'mag', 'spd']);\n\n/**\n * Zod schema for StatusEffect (discriminated union)\n */\nexport const StatusEffectSchema = z.discriminatedUnion('type', [\n  z.object({\n    type: z.literal('buff'),\n    stat: StatKeySchema,\n    modifier: z.number().positive(),\n    duration: z.number().int().positive(),\n  }),\n  z.object({\n    type: z.literal('debuff'),\n    stat: StatKeySchema,\n    modifier: z.number().negative(),\n    duration: z.number().int().positive(),\n  }),\n  z.object({\n    type: z.enum(['poison', 'burn']),\n    damagePerTurn: z.number().int().positive(),\n    duration: z.number().int().positive(),\n  }),\n  z.object({\n    type: z.enum(['freeze', 'paralyze', 'stun']),\n    duration: z.number().int().positive(),\n  }),\n  z.object({\n    type: z.literal('healOverTime'),\n    healPerTurn: z.number().int().positive(),\n    duration: z.number().int().positive(),\n  }),\n  // Phase 2: Elemental resistance/weakness\n  // Convention: modifier > 0 = resistance (reduces damage), modifier < 0 = weakness (increases damage)\n  // Damage factor = 1 - modifier: 0.4 = 40% resist â†’ damage Ã— 0.6, -0.2 = 20% weakness â†’ damage Ã— 1.2\n  z.object({\n    type: z.literal('elementalResistance'),\n    element: ElementSchema,\n    modifier: z.number(), // Can be positive (resist) or negative (weakness)\n    duration: z.number().int().positive(),\n  }),\n  // Phase 2: Global damage reduction\n  z.object({\n    type: z.literal('damageReduction'),\n    percent: z.number().min(0).max(1), // 0-1, e.g. 0.3 = 30% reduction\n    duration: z.number().int().positive(),\n  }),\n  // Phase 2: Hit-based shield\n  z.object({\n    type: z.literal('shield'),\n    remainingCharges: z.number().int().min(0), // Consumed per hit\n    duration: z.number().int().positive(),\n  }),\n  // Phase 2: Invulnerability (blocks damage only, NOT statuses)\n  z.object({\n    type: z.literal('invulnerable'),\n    duration: z.number().int().positive(),\n  }),\n  // Phase 2: Status immunity\n  z.object({\n    type: z.literal('immunity'),\n    all: z.boolean(), // If true, immune to all negative statuses\n    types: z.array(z.enum(['poison', 'burn', 'freeze', 'paralyze', 'stun', 'debuff'])).optional(), // Specific immunities\n    duration: z.number().int().positive(),\n  }),\n  // Phase 2: Auto-revive (uses-based, not time-based)\n  z.object({\n    type: z.literal('autoRevive'),\n    hpPercent: z.number().min(0).max(1), // HP% restored when triggered\n    usesRemaining: z.number().int().min(1), // Usually 1\n  }),\n]);\n\n/**\n * Zod schema for UnitDefinition\n */\nexport const UnitDefinitionSchema = z.object({\n  id: z.string().min(1),\n  name: z.string().min(1),\n  element: ElementSchema,\n  role: UnitRoleSchema,\n  baseStats: StatsSchema,\n  growthRates: StatsSchema,\n  abilities: z.array(AbilitySchema),\n  manaContribution: z.number().int().min(0),\n  description: z.string(),\n  autoAttackTiming: z.enum(['same-turn', 'next-turn']).optional(),\n  availableIn: ContentAvailabilitySchema.optional().readonly(),\n});\n\n/**\n * Zod schema for Unit\n */\nexport const UnitSchema = z.object({\n  id: z.string().min(1),\n  name: z.string().min(1),\n  element: ElementSchema,\n  role: UnitRoleSchema,\n  baseStats: StatsSchema,\n  growthRates: StatsSchema,\n  description: z.string(),\n  manaContribution: z.number().int().min(0),\n  level: z.number().int().min(1).max(20),\n  xp: z.number().int().min(0),\n  currentHp: z.number().int().min(0),\n  autoAttackTiming: z.enum(['same-turn', 'next-turn']).optional(),\n  equipment: EquipmentLoadoutSchema,\n  storeUnlocked: z.boolean(),\n  djinn: z.array(z.string().min(1)),\n  djinnStates: z.record(z.string(), DjinnStateSchema),\n  abilities: z.array(AbilitySchema),\n  unlockedAbilityIds: z.array(z.string().min(1)),\n  statusEffects: z.array(StatusEffectSchema),\n  actionsTaken: z.number().int().min(0),\n  battleStats: z.object({\n    damageDealt: z.number().int().min(0),\n    damageTaken: z.number().int().min(0),\n  }),\n}).superRefine((u, ctx) => {\n  // Unit HP cannot exceed max HP\n  const maxHp = u.baseStats.hp + (u.level - 1) * u.growthRates.hp;\n  if (u.currentHp > maxHp) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: `currentHp (${u.currentHp}) exceeds maxHp (${maxHp})`,\n      path: ['currentHp'],\n    });\n  }\n});\n\nexport type Unit = z.infer<typeof UnitSchema>;\nexport type UnitDefinition = z.infer<typeof UnitDefinitionSchema>;\nexport type StatusEffect = z.infer<typeof StatusEffectSchema>;\n","import { z } from 'zod';\nimport { UnitSchema, DjinnStateSchema } from './UnitSchema';\nimport { EquipmentSchema } from './EquipmentSchema';\nimport { MIN_PARTY_SIZE, MAX_PARTY_SIZE } from '../../core/constants';\n\n/**\n * Djinn Tracker schema for team-wide Djinn state\n */\nconst DjinnTrackerSchema = z.object({\n  djinnId: z.string().min(1),\n  state: DjinnStateSchema,\n  lastActivatedTurn: z.number().int(),\n});\n\n/**\n * NPC State schema\n * Defines valid states for NPCs in the overworld\n */\nconst NPCStateSchema = z.object({\n  defeated: z.boolean().optional(),\n  dialogueSeen: z.boolean().optional(),\n  questProgress: z.number().int().min(0).optional(),\n  lastInteraction: z.number().int().optional(),\n  customData: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])).optional(),\n});\n\nconst TowerRecordSchema = z.object({\n  highestFloorEver: z.number().int().min(0).default(0),\n  totalRuns: z.number().int().min(0).default(0),\n  bestRunTurns: z.number().int().min(0).nullable().default(null),\n  bestRunDamageDealt: z.number().int().min(0).nullable().default(null),\n});\n\n/**\n * Save file version 1 schema\n * This is the initial save format for the v2 app\n */\nexport const SaveV1Schema = z.object({\n  version: z.literal('1.0.0'),\n  timestamp: z.number().int().positive(),\n  chapter: z.number().int().min(1).default(1),  // Story chapter (defaults to 1 for backward compatibility)\n\n  // Player progress\n  playerData: z.object({\n    unitsCollected: z.array(UnitSchema).max(10),  // Up to 10 units\n    activeParty: z.array(z.string().min(1)).min(MIN_PARTY_SIZE).max(MAX_PARTY_SIZE),  // 1-4 unit IDs\n    inventory: z.array(EquipmentSchema),  // Equipment inventory\n    gold: z.number().int().min(0),\n    djinnCollected: z.array(z.string().min(1)).max(12),  // Up to 12 Djinn IDs\n    equippedDjinn: z.array(z.string().min(1)).max(3).optional(),  // Up to 3 equipped Djinn IDs\n    djinnTrackers: z.record(z.string(), DjinnTrackerSchema).optional(),  // Djinn state tracking\n    recruitmentFlags: z.record(z.string(), z.boolean()),\n    storyFlags: z.record(z.string(), z.boolean()),\n  }),\n\n  // Overworld state\n  overworldState: z.object({\n    playerPosition: z.object({\n      x: z.number(),\n      y: z.number(),\n    }),\n    currentScene: z.string().min(1),\n    npcStates: z.record(z.string(), NPCStateSchema),  // Properly typed NPC states\n  }),\n\n  // Statistics\n  stats: z.object({\n    battlesWon: z.number().int().min(0),\n    battlesLost: z.number().int().min(0),\n    totalDamageDealt: z.number().int().min(0),\n    totalHealingDone: z.number().int().min(0),\n    playtime: z.number().int().min(0),  // Seconds\n  }),\n  towerStats: TowerRecordSchema.optional(),\n});\n\nexport type SaveV1 = z.infer<typeof SaveV1Schema>;\n\n","import { z } from 'zod';\nimport { UnitSchema, DjinnStateSchema } from './UnitSchema';\nimport { MIN_PARTY_SIZE, MAX_PARTY_SIZE } from '../../core/constants';\n\n/**\n * Zod schema for DjinnTracker\n */\nexport const DjinnTrackerSchema = z.object({\n  djinnId: z.string().min(1),\n  state: DjinnStateSchema,\n  lastActivatedTurn: z.number().int().min(0),\n});\n\n/**\n * Zod schema for Team\n */\nexport const TeamSchema = z.object({\n  equippedDjinn: z.array(z.string().min(1)).max(3),  // Up to 3 Djinn slots (can be empty initially)\n  djinnTrackers: z.record(z.string(), DjinnTrackerSchema),\n  units: z.array(UnitSchema).min(MIN_PARTY_SIZE).max(MAX_PARTY_SIZE),  // 1-4 units\n  collectedDjinn: z.array(z.string().min(1)).max(12),  // Up to 12 Djinn\n  currentTurn: z.number().int().min(0),\n  activationsThisTurn: z.record(z.string(), z.number().int().min(0)),\n  djinnStates: z.record(z.string(), DjinnStateSchema),\n}).superRefine((t, ctx) => {\n  // Team djinn sanity check\n  if (t.equippedDjinn.length > 3) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.too_big,\n      maximum: 3,\n      type: 'array',\n      inclusive: true,\n      path: ['equippedDjinn'],\n    });\n  }\n});\n\nexport type Team = z.infer<typeof TeamSchema>;\nexport type DjinnTracker = z.infer<typeof DjinnTrackerSchema>;\n\n","import { z } from 'zod';\nimport { TeamSchema } from './TeamSchema';\nimport { UnitSchema } from './UnitSchema';\nimport { MIN_PARTY_SIZE, MAX_PARTY_SIZE } from '../../core/constants';\n\n/**\n * Zod schema for BattleResult\n */\nexport const BattleResultSchema = z.enum(['PLAYER_VICTORY', 'PLAYER_DEFEAT']);\n\n/**\n * Zod schema for BattleStatus\n */\nexport const BattleStatusSchema = z.union([\n  z.literal('ongoing'),\n  BattleResultSchema,\n]);\n\n/**\n * Zod schema for QueuedAction\n */\nexport const QueuedActionSchema = z.object({\n  unitId: z.string().min(1),\n  abilityId: z.string().nullable(),\n  targetIds: z.array(z.string().min(1)),\n  manaCost: z.number().int().min(0).max(10),\n});\n\n/**\n * Zod schema for BattlePhase\n */\nexport const BattlePhaseSchema = z.enum(['planning', 'executing', 'victory', 'defeat']);\n\n/**\n * Zod schema for BattleState\n * PR-QUEUE-BATTLE: Extended with queue-based battle system fields\n */\nexport const BattleStateSchema = z.object({\n  playerTeam: TeamSchema,\n  enemies: z.array(UnitSchema).min(1),  // At least 1 enemy\n  currentTurn: z.number().int().min(0),\n  roundNumber: z.number().int().min(1),\n  phase: BattlePhaseSchema,\n  turnOrder: z.array(z.string().min(1)),  // Array of unit IDs\n  currentActorIndex: z.number().int().min(0),\n  status: BattleStatusSchema,\n  log: z.array(z.string()),\n  \n  // Queue-based battle system fields\n  currentQueueIndex: z.number().int().min(0), // Max validated in superRefine\n  queuedActions: z.array(QueuedActionSchema.nullable()).min(MIN_PARTY_SIZE).max(MAX_PARTY_SIZE), // 1-4 actions\n  queuedDjinn: z.array(z.string().min(1)),\n  remainingMana: z.number().int().min(0),\n  maxMana: z.number().int().min(0),\n  executionIndex: z.number().int().min(0),\n  djinnRecoveryTimers: z.record(z.string(), z.number().int().min(0)),\n  rngSnapshot: z.object({\n    state: z.number().int(),\n    initialSeed: z.number().int(),\n    draws: z.number().int(),\n  }).optional(),\n  \n  // Legacy fields\n  isBossBattle: z.boolean().optional(),\n  npcId: z.string().optional(),\n  encounterId: z.string().optional(),\n  meta: z.object({\n    encounterId: z.string(),\n    difficulty: z.enum(['normal', 'elite', 'boss']).optional(),\n  }).optional(),\n}).superRefine((b, ctx) => {\n  // BattleState turn order IDs must exist\n  const teamIds = b.playerTeam.units.map(u => u.id);\n  const enemyIds = b.enemies.map(u => u.id);\n  const known = new Set([...teamIds, ...enemyIds]);\n  \n  for (const [i, id] of b.turnOrder.entries()) {\n    if (!known.has(id)) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        path: ['turnOrder', i],\n        message: `Unknown actor id: ${id}`,\n      });\n    }\n  }\n  \n  const teamSize = b.playerTeam.units.length;\n  \n  // Validate currentQueueIndex doesn't exceed team size\n  if (b.currentQueueIndex >= teamSize) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.too_big,\n      maximum: teamSize - 1,\n      type: 'number',\n      inclusive: true,\n      path: ['currentQueueIndex'],\n      message: `currentQueueIndex (${b.currentQueueIndex}) exceeds team size (${teamSize})`,\n    });\n  }\n  \n  // Validate queuedActions length matches team size\n  if (b.queuedActions.length !== teamSize) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      path: ['queuedActions'],\n      message: `queuedActions length (${b.queuedActions.length}) must match team size (${teamSize})`,\n    });\n  }\n  \n  // Validate queued actions reference valid unit IDs\n  for (const [i, action] of b.queuedActions.entries()) {\n    if (action && !teamIds.includes(action.unitId)) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        path: ['queuedActions', i, 'unitId'],\n        message: `Queued action references unknown unit: ${action.unitId}`,\n      });\n    }\n    \n    // Validate queuedActions reference valid unit indices\n    if (action && i >= teamSize) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        path: ['queuedActions', i],\n        message: `Queued action at index ${i} exceeds team size (${teamSize})`,\n      });\n    }\n  }\n  \n  // Validate remainingMana doesn't exceed maxMana\n  if (b.remainingMana > b.maxMana) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      path: ['remainingMana'],\n      message: `remainingMana (${b.remainingMana}) exceeds maxMana (${b.maxMana})`,\n    });\n  }\n});\n\nexport type BattleState = z.infer<typeof BattleStateSchema>;\nexport type BattleResult = z.infer<typeof BattleResultSchema>;\nexport type BattleStatus = z.infer<typeof BattleStatusSchema>;\n","/**\n * Migration system scaffold\n * Ready for future migrations when save format changes\n */\n\nimport type { Result } from '../utils/result';\nimport { Ok, Err } from '../utils/result';\nimport type { Migration, MigrationRegistry } from './types';\nimport { SaveV1Schema } from '../../data/schemas/SaveV1Schema';\n\n/**\n * Current save version\n */\nexport const CURRENT_SAVE_VERSION = '1.0.0';\n\n/**\n * Migration registry\n * Add migrations here as new versions are introduced\n */\nconst migrations: readonly Migration[] = [\n  // Future migrations will go here\n  // Example:\n  // {\n  //   fromVersion: '1.0.0',\n  //   toVersion: '1.1.0',\n  //   migrate: (data) => {\n  //     // Transform data from 1.0.0 to 1.1.0\n  //     return Ok(transformedData);\n  //   },\n  // },\n];\n\nexport const migrationRegistry: MigrationRegistry = {\n  migrations,\n  currentVersion: CURRENT_SAVE_VERSION,\n};\n\n/**\n * Migrate save data to current version\n * Applies all necessary migrations in sequence\n */\nexport function migrateSaveData(data: unknown): Result<unknown, string> {\n  // For now, just validate as SaveV1\n  // In the future, this will check version and apply migrations\n  const result = SaveV1Schema.safeParse(data);\n  \n  if (!result.success) {\n    return Err(`Invalid save data: ${result.error.message}`);\n  }\n\n  return Ok(result.data);\n}\n\n/**\n * Get migration path from version to target version\n */\nexport function getMigrationPath(\n  fromVersion: string,\n  toVersion: string,\n  registry: MigrationRegistry\n): readonly Migration[] {\n  if (fromVersion === toVersion) {\n    return [];\n  }\n\n  // Simple linear migration path (for now)\n  // In the future, this could handle branching migration paths\n  return registry.migrations.filter(\n    (m) => m.fromVersion === fromVersion && m.toVersion === toVersion\n  );\n}\n\n","/**\n * Save File Validation (PLACEHOLDER - Issue #20)\n * To be implemented when building save system\n *\n * This file provides the infrastructure for save file validation.\n * Implementation will be completed as part of the save/load system.\n *\n * Planned Features:\n * - Checksum validation (detect tampering/corruption)\n * - Version migration support\n * - Schema validation using Zod\n * - Graceful degradation on corruption\n * - Recovery suggestions for corrupted saves\n */\n\nimport type { ZodSchema } from 'zod';\nimport { Result, Err, Ok } from '../utils/result';\nimport { SaveV1Schema, type SaveV1 } from '../../data/schemas/SaveV1Schema';\nimport { CURRENT_SAVE_VERSION, migrateSaveData } from '../migrations';\n\n/**\n * Save file metadata\n */\nexport interface SaveFileMetadata {\n  version: string;\n  timestamp: number;\n  checksum: string;\n}\n\n/**\n * Save file validation error types\n */\nexport type SaveFileValidationError =\n  | { type: 'CORRUPTED'; reason: string; recoverable: boolean }\n  | { type: 'VERSION_MISMATCH'; saveVersion: string; currentVersion: string; canMigrate: boolean }\n  | { type: 'CHECKSUM_FAILED'; expected: string; actual: string }\n  | { type: 'MISSING_DATA'; missingFields: string[] }\n  | { type: 'INVALID_FORMAT'; message: string };\n\n/**\n * TODO (Issue #20): Implement save file validation\n *\n * @param data - Unknown data from storage (localStorage, file, etc.)\n * @returns Validated save file or validation error\n *\n * Implementation checklist:\n * 1. Parse JSON safely (try/catch)\n * 2. Validate save file structure (has version, timestamp, checksum, data)\n * 3. Validate checksum (calculateChecksum(data) === stored checksum)\n * 4. Validate version (compare with CURRENT_VERSION)\n * 5. Migrate if needed (runMigrations(data, saveVersion, currentVersion))\n * 6. Validate game state using Zod schemas\n * 7. Return validated data or detailed error\n */\nexport function validateSaveFile<T>(\n  wrapper: unknown,\n  schema: ZodSchema<unknown>,\n  currentVersion: string = CURRENT_SAVE_VERSION,\n  migrate?: (data: unknown) => Result<unknown, string>\n): Result<T, SaveFileValidationError> {\n  if (!wrapper || typeof wrapper !== 'object') {\n    return Err({\n      type: 'INVALID_FORMAT',\n      message: 'Save file is not an object',\n    });\n  }\n\n  const file = wrapper as Partial<{\n    version: string;\n    timestamp: number;\n    checksum: string;\n    data: unknown;\n  }>;\n\n  const missingFields = [\n    !file.version ? 'version' : null,\n    !file.timestamp ? 'timestamp' : null,\n    !file.checksum ? 'checksum' : null,\n    typeof file.data === 'undefined' ? 'data' : null,\n  ].filter((f): f is string => f !== null);\n\n  if (missingFields.length > 0) {\n    return Err({\n      type: 'MISSING_DATA',\n      missingFields,\n    });\n  }\n\n  let data = file.data;\n  const saveVersion = file.version!;\n\n  if (saveVersion !== currentVersion) {\n    if (migrate) {\n      const migrated = migrate(data);\n      if (!migrated.ok) {\n        return Err({\n          type: 'VERSION_MISMATCH',\n          saveVersion,\n          currentVersion,\n          canMigrate: true,\n        });\n      }\n      data = migrated.value;\n    } else {\n      return Err({\n        type: 'VERSION_MISMATCH',\n        saveVersion,\n        currentVersion,\n        canMigrate: false,\n      });\n    }\n  }\n\n  if (!verifyChecksum(data, file.checksum!)) {\n    return Err({\n      type: 'CHECKSUM_FAILED',\n      expected: file.checksum!,\n      actual: calculateChecksum(data),\n    });\n  }\n\n  const result = schema.safeParse(data);\n  if (!result.success) {\n    return Err({\n      type: 'INVALID_FORMAT',\n      message: result.error.message,\n    });\n  }\n\n  return Ok(result.data as T);\n}\n\n/**\n * Calculate checksum for save data (synchronous hash)\n *\n * Uses a simple but deterministic hash function for save file integrity.\n * For full cryptographic security, use crypto.subtle.digest (async).\n *\n * @param data - Save data to checksum\n * @returns Checksum string (hex hash)\n */\nexport function calculateChecksum(data: unknown): string {\n  // Serialize with sorted keys at all levels for deterministic output\n  const serialized = JSON.stringify(data, (_key, value) => {\n    // Sort object keys recursively\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\n      return Object.keys(value)\n        .sort()\n        .reduce((sorted: Record<string, unknown>, k) => {\n          sorted[k] = value[k];\n          return sorted;\n        }, {});\n    }\n    return value;\n  });\n\n  // Simple hash function (FNV-1a 32-bit)\n  let hash = 2166136261;\n  for (let i = 0; i < serialized.length; i++) {\n    hash ^= serialized.charCodeAt(i);\n    hash = Math.imul(hash, 16777619);\n  }\n\n  // Convert to unsigned 32-bit and hex\n  return (hash >>> 0).toString(16).padStart(8, '0');\n}\n\n/**\n * Verify save file checksum\n *\n * @param data - Save data\n * @param expectedChecksum - Stored checksum\n * @returns True if checksum matches\n */\nexport function verifyChecksum(data: unknown, expectedChecksum: string): boolean {\n  const actualChecksum = calculateChecksum(data);\n  return actualChecksum === expectedChecksum;\n}\n\n/**\n * TODO (Issue #20): Load save file with validation and recovery\n *\n * @param slot - Save slot number (1-3)\n * @returns Validated game state or error with recovery options\n *\n * Recovery strategy:\n * 1. Try to load save\n * 2. If corrupted, check for backup save\n * 3. If backup corrupted, offer to start new game\n * 4. Never crash - always provide graceful fallback\n */\nexport function loadSaveFileSafe(slot: number): Result<SaveV1, SaveFileValidationError> {\n  if (slot < 0 || slot >= 3) {\n    return Err({\n      type: 'INVALID_FORMAT',\n      message: `Invalid slot: ${slot}`,\n    });\n  }\n\n  const key = `vale_chronicles_v2_save_slot_${slot}`;\n  const backupKey = `${key}_backup`;\n\n  const tryLoad = (storageKey: string): Result<SaveV1, SaveFileValidationError> => {\n    const raw = localStorage.getItem(storageKey);\n    if (!raw) {\n      return Err({\n        type: 'MISSING_DATA',\n        missingFields: ['data'],\n      });\n    }\n\n    let parsed: unknown;\n    try {\n      parsed = JSON.parse(raw);\n    } catch (error) {\n      return Err({\n        type: 'INVALID_FORMAT',\n        message: error instanceof Error ? error.message : 'Invalid JSON',\n      });\n    }\n\n    return validateSaveFile(parsed, SaveV1Schema, CURRENT_SAVE_VERSION, migrateSaveData);\n  };\n\n  const primaryResult = tryLoad(key);\n  if (primaryResult.ok) {\n    return primaryResult;\n  }\n\n  // Attempt backup if primary fails\n  const backupResult = tryLoad(backupKey);\n  if (backupResult.ok) {\n    // Restore backup to primary key for future loads\n    localStorage.setItem(key, JSON.stringify({\n      version: CURRENT_SAVE_VERSION,\n      timestamp: Date.now(),\n      checksum: calculateChecksum(backupResult.value),\n      data: backupResult.value,\n    }));\n    return backupResult;\n  }\n\n  return primaryResult;\n}\n\n/**\n * TODO (Issue #20): Format validation error for user display\n *\n * @param error - Validation error\n * @returns User-friendly error message with recovery suggestions\n *\n * Example output:\n * \"Your save file is corrupted. Would you like to:\n *  1. Load backup save (from 2 hours ago)\n *  2. Start new game\n *  3. Report issue to developers\"\n */\nexport function formatSaveFileError(error: SaveFileValidationError): string {\n  switch (error.type) {\n    case 'CORRUPTED':\n      return `Save file is corrupted: ${error.reason}. ${\n        error.recoverable ? 'Recovery may be possible.' : 'Cannot recover.'\n      }`;\n    case 'VERSION_MISMATCH':\n      return `Save file is from version ${error.saveVersion}, current version is ${error.currentVersion}. ${\n        error.canMigrate ? 'Migration available.' : 'Migration not available.'\n      }`;\n    case 'CHECKSUM_FAILED':\n      return 'Save file integrity check failed. File may be corrupted or tampered with.';\n    case 'MISSING_DATA':\n      return `Save file is incomplete. Missing: ${error.missingFields.join(', ')}`;\n    case 'INVALID_FORMAT':\n      return `Invalid save file format: ${error.message}`;\n  }\n}\n\n/**\n * NOTE: This file is a placeholder for the save system (Issue #20)\n *\n * When implementing the save system, refer to:\n * - docs/architect/save-system-spec.md (if exists)\n * - src/data/schemas/SaveV1Schema.ts (for schema)\n * - src/core/services/SaveService.ts (for implementation)\n *\n * Key requirements:\n * - Versioned save format (support migration)\n * - Checksum validation (detect corruption)\n * - Graceful error handling (never crash)\n * - Backup saves (auto-create on save)\n * - User-friendly error messages\n */\n","/**\n * Save Service (Enhanced)\n * Handles save/load with checksums, backups, and validation\n *\n * Features:\n * - Checksum validation (detect corruption)\n * - Auto-backup on save\n * - Backup restoration on corruption\n * - Battle state save/load\n * - Progress save/load (full game state)\n * - Auto-save functionality\n */\n\nimport type { ZodSchema } from 'zod';\nimport type { Result } from '../utils/result';\nimport { Ok, Err } from '../utils/result';\nimport { SaveV1Schema, type SaveV1 } from '../../data/schemas/SaveV1Schema';\nimport { BattleStateSchema, type BattleState } from '../../data/schemas/BattleStateSchema';\nimport { buildUnitIndex } from '../models/BattleState';\nimport { migrateSaveData } from '../migrations';\nimport {\n  calculateChecksum,\n  validateSaveFile,\n  type SaveFileValidationError,\n} from '../validation/saveFileValidation';\n\nconst SAVE_SLOT_PREFIX = 'vale_chronicles_v2_save_slot_';\nconst BACKUP_SUFFIX = '_backup';\nconst BATTLE_SAVE_KEY = 'vale_chronicles_v2_battle';\nconst AUTO_SAVE_SLOT = 0;\n\n/**\n * BattleState without unitById (for JSON serialization)\n * The unitById Map is rebuilt on load using buildUnitIndex()\n */\ntype BattleStateSerializable = Omit<BattleState, 'unitById'>;\n\n/**\n * Save file wrapper with checksum\n */\ninterface SaveFileWrapper {\n  version: string;\n  timestamp: number;\n  checksum: string;\n  data: SaveV1 | BattleStateSerializable;\n}\n\n/**\n * Get localStorage key for a specific save slot\n */\nfunction getSaveSlotKey(slot: number): string {\n  if (slot < 0 || slot >= 3) {\n    throw new Error(`Invalid save slot: ${slot}. Must be 0-2.`);\n  }\n  return `${SAVE_SLOT_PREFIX}${slot}`;\n}\n\n/**\n * Get backup key for a save slot\n */\nfunction getBackupKey(key: string): string {\n  return `${key}${BACKUP_SUFFIX}`;\n}\n\n/**\n * Create backup of existing save before overwriting\n *\n * @param key - localStorage key for the save file\n * @returns Ok if backup created or no existing save, Err if backup fails\n */\nfunction createBackup(key: string): Result<void, string> {\n  try {\n    const existing = localStorage.getItem(key);\n    if (existing) {\n      localStorage.setItem(getBackupKey(key), existing);\n    }\n    return Ok(undefined);\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return Err(`Failed to create backup: ${message}`);\n  }\n}\n\n/**\n * Wrap data with checksum for integrity validation\n */\nfunction wrapWithChecksum(data: SaveV1 | BattleStateSerializable, version: string): SaveFileWrapper {\n  const checksum = calculateChecksum(data);\n  return {\n    version,\n    timestamp: Date.now(),\n    checksum,\n    data,\n  };\n}\n\n/**\n * Validate and unwrap save file\n */\nfunction unwrapAndValidate<T>(\n  wrapper: unknown,\n  expectedVersion: string,\n  schema: ZodSchema<unknown>,\n  migrate?: (data: unknown) => Result<unknown, string>\n): Result<T, SaveFileValidationError> {\n  return validateSaveFile<T>(wrapper, schema, expectedVersion, migrate);\n}\n\n// ============================================================================\n// Progress Save/Load (Full Game State)\n// ============================================================================\n\n/**\n * Save full game progress to slot with checksum and backup\n */\nexport function saveProgress(slot: number, data: SaveV1): Result<void, string> {\n  try {\n    if (slot < 0 || slot >= 3) {\n      return Err(`Invalid save slot: ${slot}. Must be 0-2.`);\n    }\n\n    // Validate data matches SaveV1 schema\n    const validationResult = SaveV1Schema.safeParse(data);\n    if (!validationResult.success) {\n      return Err(`Invalid save data: ${validationResult.error.message}`);\n    }\n\n    const key = getSaveSlotKey(slot);\n\n    // Create backup of existing save (mandatory for data safety)\n    const backupResult = createBackup(key);\n    if (!backupResult.ok) {\n      return backupResult; // Forward the error\n    }\n\n    // Wrap with checksum\n    const wrapped = wrapWithChecksum(validationResult.data, '1.0.0');\n    const serialized = JSON.stringify(wrapped);\n\n    // Save to localStorage\n    localStorage.setItem(key, serialized);\n\n    return Ok(undefined);\n  } catch (error) {\n    return Err(`Failed to save progress: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Load game progress from slot with validation and backup fallback\n */\nexport function loadProgress(slot: number): Result<SaveV1, string> {\n  try {\n    if (slot < 0 || slot >= 3) {\n      return Err(`Invalid save slot: ${slot}. Must be 0-2.`);\n    }\n\n    const key = getSaveSlotKey(slot);\n    const serialized = localStorage.getItem(key);\n\n    if (!serialized) {\n      return Err('No save file found in this slot');\n    }\n\n    // Parse JSON\n    let wrapper: unknown;\n    try {\n      wrapper = JSON.parse(serialized);\n    } catch (parseError) {\n      // Try backup with error context\n      const errorMsg = parseError instanceof Error ? parseError.message : 'Invalid JSON';\n      return loadProgressFromBackup(slot, `JSON parse failed: ${errorMsg}`);\n    }\n\n    // Validate and unwrap\n    const unwrapResult = unwrapAndValidate<SaveV1>(wrapper, '1.0.0', SaveV1Schema, migrateSaveData);\n    if (!unwrapResult.ok) {\n      // Try backup with error context\n      const errorMsg = unwrapResult.error.type;\n      return loadProgressFromBackup(slot, `Validation failed: ${errorMsg}`);\n    }\n\n    // Final schema validation\n    const schemaResult = SaveV1Schema.safeParse(unwrapResult.value);\n    if (!schemaResult.success) {\n      return Err(`Save file validation failed: ${schemaResult.error.message}`);\n    }\n\n    return Ok(schemaResult.data);\n  } catch (error) {\n    return Err(`Failed to load progress: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Load progress from backup (fallback)\n *\n * @param slot - Save slot number\n * @param mainError - Error from main save (for debugging context)\n */\nfunction loadProgressFromBackup(slot: number, mainError?: string): Result<SaveV1, string> {\n  try {\n    const key = getSaveSlotKey(slot);\n    const backupKey = getBackupKey(key);\n    const serialized = localStorage.getItem(backupKey);\n\n    if (!serialized) {\n      const context = mainError ? ` Main save error: ${mainError}` : '';\n      return Err(`Save file corrupted and no backup found.${context}`);\n    }\n\n    const wrapper = JSON.parse(serialized);\n    const unwrapResult = unwrapAndValidate<SaveV1>(wrapper, '1.0.0', SaveV1Schema, migrateSaveData);\n\n    if (!unwrapResult.ok) {\n      const context = mainError ? ` Main save error: ${mainError}` : '';\n      return Err(`Both main save and backup are corrupted.${context}`);\n    }\n\n    const schemaResult = SaveV1Schema.safeParse(unwrapResult.value);\n    if (!schemaResult.success) {\n      const context = mainError ? ` Main save error: ${mainError}` : '';\n      return Err(`Backup validation failed.${context}`);\n    }\n\n    // Restore backup to main slot\n    localStorage.setItem(key, serialized);\n\n    return Ok(schemaResult.data);\n  } catch (error) {\n    const context = mainError ? ` Main save error: ${mainError}` : '';\n    return Err(`Failed to load backup: ${error instanceof Error ? error.message : String(error)}.${context}`);\n  }\n}\n\n// ============================================================================\n// Battle State Save/Load (Quick Save)\n// ============================================================================\n\n/**\n * Save battle state (quick save during battle)\n */\nexport function saveBattle(state: BattleState): Result<void, string> {\n  try {\n    // Validate battle state\n    const validationResult = BattleStateSchema.safeParse(state);\n    if (!validationResult.success) {\n      return Err(`Invalid battle state: ${validationResult.error.message}`);\n    }\n\n    // Create backup (mandatory for data safety)\n    const backupResult = createBackup(BATTLE_SAVE_KEY);\n    if (!backupResult.ok) {\n      return backupResult; // Forward the error\n    }\n\n    // Wrap with checksum\n    const wrapped = wrapWithChecksum(validationResult.data, '1.0.0');\n    const serialized = JSON.stringify(wrapped);\n\n    localStorage.setItem(BATTLE_SAVE_KEY, serialized);\n\n    return Ok(undefined);\n  } catch (error) {\n    return Err(`Failed to save battle: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Load battle state with validation\n */\nexport function loadBattle(): Result<BattleState, string> {\n  try {\n    const serialized = localStorage.getItem(BATTLE_SAVE_KEY);\n\n    if (!serialized) {\n      return Err('No battle save found');\n    }\n\n    // Parse JSON\n    let wrapper: unknown;\n    try {\n      wrapper = JSON.parse(serialized);\n    } catch {\n      return Err('Battle save corrupted (invalid JSON)');\n    }\n\n    // Validate and unwrap (loads BattleStateSerializable without unitById)\n    const unwrapResult = unwrapAndValidate<BattleStateSerializable>(wrapper, '1.0.0', BattleStateSchema);\n    if (!unwrapResult.ok) {\n      return Err('Battle save validation failed');\n    }\n\n    // Final schema validation\n    const schemaResult = BattleStateSchema.safeParse(unwrapResult.value);\n    if (!schemaResult.success) {\n      return Err(`Battle state validation failed: ${schemaResult.error.message}`);\n    }\n\n    const serializable = schemaResult.data;\n\n    // Rebuild unitById index from player and enemy units\n    const unitById = buildUnitIndex(\n      serializable.playerTeam?.units ?? [],\n      serializable.enemies ?? []\n    );\n\n    // Reconstruct full BattleState with unitById\n    const battleState = {\n      ...serializable,\n      unitById,\n    } as BattleState;\n\n    return Ok(battleState);\n  } catch (error) {\n    return Err(`Failed to load battle: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Delete battle save\n */\nexport function deleteBattleSave(): Result<void, string> {\n  try {\n    localStorage.removeItem(BATTLE_SAVE_KEY);\n    localStorage.removeItem(getBackupKey(BATTLE_SAVE_KEY));\n    return Ok(undefined);\n  } catch (error) {\n    return Err(`Failed to delete battle save: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n// ============================================================================\n// Auto-Save\n// ============================================================================\n\n/**\n * Auto-save to slot 0\n */\nexport function autoSave(data: SaveV1): Result<void, string> {\n  return saveProgress(AUTO_SAVE_SLOT, data);\n}\n\n/**\n * Load auto-save from slot 0\n */\nexport function loadAutoSave(): Result<SaveV1, string> {\n  return loadProgress(AUTO_SAVE_SLOT);\n}\n\n/**\n * Check if auto-save exists\n */\nexport function hasAutoSave(): boolean {\n  return hasSaveSlot(AUTO_SAVE_SLOT);\n}\n\n// ============================================================================\n// Slot Management\n// ============================================================================\n\n/**\n * Check if save file exists in a specific slot\n */\nexport function hasSaveSlot(slot: number): boolean {\n  if (slot < 0 || slot >= 3) {\n    return false;\n  }\n  return localStorage.getItem(getSaveSlotKey(slot)) !== null;\n}\n\n/**\n * Delete save file from a specific slot\n */\nexport function deleteSaveSlot(slot: number): Result<void, string> {\n  try {\n    if (slot < 0 || slot >= 3) {\n      return Err(`Invalid save slot: ${slot}. Must be 0-2.`);\n    }\n\n    const key = getSaveSlotKey(slot);\n    localStorage.removeItem(key);\n    localStorage.removeItem(getBackupKey(key));\n\n    return Ok(undefined);\n  } catch (error) {\n    return Err(`Failed to delete save: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n// ============================================================================\n// Slot Metadata (for save/load UI)\n// ============================================================================\n\nexport interface SaveSlotMetadata {\n  exists: boolean;\n  timestamp?: number;\n  playtime?: number;\n  teamLevel?: number;\n  gold?: number;\n  chapter?: number;\n  corrupted?: boolean;\n}\n\n/**\n * Get metadata for a save slot (without loading full save)\n */\nexport function getSaveSlotMetadata(slot: number): SaveSlotMetadata {\n  if (slot < 0 || slot >= 3) {\n    return { exists: false };\n  }\n\n  const serialized = localStorage.getItem(getSaveSlotKey(slot));\n  if (!serialized) {\n    return { exists: false };\n  }\n\n  try {\n    const wrapper = JSON.parse(serialized) as SaveFileWrapper;\n\n    // Quick validation\n    if (!wrapper.data || !wrapper.checksum) {\n      return { exists: true, corrupted: true };\n    }\n\n    const data = wrapper.data as SaveV1;\n\n    // Defensive checks for corrupted metadata\n    if (!data.playerData || !data.stats || !Array.isArray(data.playerData.unitsCollected)) {\n      return { exists: true, corrupted: true };\n    }\n\n    // Calculate average level with defensive checks\n    const avgLevel = data.playerData.unitsCollected.length > 0\n      ? Math.round(\n          data.playerData.unitsCollected.reduce((sum, u) => {\n            const level = typeof u?.level === 'number' ? u.level : 1;\n            return sum + level;\n          }, 0) / data.playerData.unitsCollected.length\n        )\n      : 1;\n\n    return {\n      exists: true,\n      timestamp: typeof wrapper.timestamp === 'number' ? wrapper.timestamp : Date.now(),\n      playtime: typeof data.stats.playtime === 'number' ? data.stats.playtime : 0,\n      teamLevel: avgLevel,\n      gold: typeof data.playerData.gold === 'number' ? data.playerData.gold : 0,\n      chapter: 1, // TODO: Add chapter to SaveV1Schema\n      corrupted: false,\n    };\n  } catch {\n    return { exists: true, corrupted: true };\n  }\n}\n\n/**\n * Get metadata for all save slots\n */\nexport function listSaveSlots(): SaveSlotMetadata[] {\n  return [0, 1, 2].map(slot => getSaveSlotMetadata(slot));\n}\n\n// ============================================================================\n// Legacy Compatibility (keep existing functions working)\n// ============================================================================\n\n/**\n * @deprecated Use saveProgress(0, data) instead\n */\nexport function saveGame(data: SaveV1): Result<void, string> {\n  return saveProgress(0, data);\n}\n\n/**\n * @deprecated Use loadProgress(0) instead\n */\nexport function loadGame(): Result<SaveV1, string> {\n  return loadProgress(0);\n}\n\n/**\n * @deprecated Use hasSaveSlot(0) instead\n */\nexport function hasSave(): boolean {\n  return hasSaveSlot(0);\n}\n\n/**\n * @deprecated Use deleteSaveSlot(0) instead\n */\nexport function deleteSave(): Result<void, string> {\n  return deleteSaveSlot(0);\n}\n\n/**\n * @deprecated Use saveProgress(slot, data) instead\n */\nexport function saveGameSlot(slot: number, data: SaveV1): Result<void, string> {\n  return saveProgress(slot, data);\n}\n\n/**\n * @deprecated Use loadProgress(slot) instead\n */\nexport function loadGameSlot(slot: number): Result<SaveV1, string> {\n  return loadProgress(slot);\n}\n","// [BT-CONFIG][BT-01] Battle Tower configuration\n\nexport type TowerDifficulty = 'normal' | 'hard';\n\nexport interface TowerConfig {\n  restFloorInterval: number;\n  targetMaxFloor: number;\n  healFractionAtRest: number;\n  enemyScalingPerFloor: number;\n  bossFloorInterval: number;\n  maxTeamSize: number;\n}\n\nexport const DEFAULT_TOWER_CONFIG: TowerConfig = {\n  restFloorInterval: 4,\n  targetMaxFloor: 100,\n  healFractionAtRest: 0.5,\n  enemyScalingPerFloor: 0.04,\n  bossFloorInterval: 5,\n  maxTeamSize: 4,\n} as const;\n\nexport const TOWER_REST_FLOOR_INTERVAL = DEFAULT_TOWER_CONFIG.restFloorInterval;\nexport const TOWER_TARGET_MAX_FLOOR = DEFAULT_TOWER_CONFIG.targetMaxFloor;\nexport const TOWER_HP_RESTORE_FRACTION_AT_REST = DEFAULT_TOWER_CONFIG.healFractionAtRest;\nexport const TOWER_ENEMY_SCALING_PER_FLOOR = DEFAULT_TOWER_CONFIG.enemyScalingPerFloor;\nexport const TOWER_BOSS_FLOOR_INTERVAL = DEFAULT_TOWER_CONFIG.bossFloorInterval;\nexport const TOWER_MAX_TEAM_SIZE = DEFAULT_TOWER_CONFIG.maxTeamSize;\n\n","// [BT-CORE][BT-01] Battle Tower core service\n\nimport type { TowerFloor } from '../../data/schemas/TowerFloorSchema';\nimport type { TowerRewardEntry } from '../../data/schemas/TowerRewardSchema';\nimport type { Unit } from '../../data/schemas/UnitSchema';\nimport {\n  DEFAULT_TOWER_CONFIG,\n  type TowerConfig,\n  type TowerDifficulty,\n  TOWER_ENEMY_SCALING_PER_FLOOR,\n} from '../config/towerConfig';\nimport {\n  normalizePartyForFloor,\n  type NormalizedUnit,\n  type NormalizationCurve,\n} from './LevelNormalizationService';\n\nexport type TowerBattleOutcome = 'victory' | 'defeat' | 'retreat';\n\nexport interface TowerBattleSummary {\n  turnsTaken: number;\n  damageDealt: number;\n  damageTaken: number;\n  manaSpent: number;\n}\n\nexport interface TowerRestSummary {\n  healedFraction: number;\n  loadoutAdjusted: boolean;\n}\n\nexport interface TowerRunStats {\n  highestFloor: number;\n  totalBattles: number;\n  victories: number;\n  defeats: number;\n  retreats: number;\n  turnsTaken: number;\n  totalDamageDealt: number;\n  totalDamageTaken: number;\n}\n\nexport interface TowerFloorHistoryEntry {\n  floorId: string;\n  floorNumber: number;\n  type: TowerFloor['type'];\n  outcome: 'pending' | 'victory' | 'defeat' | 'retreat' | 'rested';\n  rewardsGranted: readonly TowerRewardEntry[];\n  restSummary?: TowerRestSummary;\n}\n\nexport interface TowerRunState {\n  seed: number;\n  difficulty: TowerDifficulty;\n  floorIndex: number;\n  floorIds: readonly string[];\n  isCompleted: boolean;\n  isFailed: boolean;\n  stats: TowerRunStats;\n  history: readonly TowerFloorHistoryEntry[];\n  pendingRewards: readonly TowerRewardEntry[];\n  config: TowerConfig;\n  rentalTeamId?: string; // Optional rental team ID\n}\n\nexport interface ScalingParams {\n  statMultiplier: number;\n  levelDelta: number;\n}\n\nexport interface CreateTowerRunOptions {\n  config?: TowerConfig;\n  rentalTeamId?: string;\n}\n\nexport function createTowerRun(\n  seed: number,\n  difficulty: TowerDifficulty,\n  floors: readonly TowerFloor[],\n  options: CreateTowerRunOptions = {}\n): TowerRunState {\n  if (!floors.length) {\n    throw new Error('TOWER_FLOORS must contain at least one entry');\n  }\n\n  const sortedFloors = [...floors].sort((a, b) => a.floorNumber - b.floorNumber);\n  const floorIds = sortedFloors.map(floor => floor.id) as readonly string[];\n\n  return {\n    seed,\n    difficulty,\n    floorIndex: 0,\n    floorIds,\n    isCompleted: false,\n    isFailed: false,\n    stats: {\n      highestFloor: 0,\n      totalBattles: 0,\n      victories: 0,\n      defeats: 0,\n      retreats: 0,\n      turnsTaken: 0,\n      totalDamageDealt: 0,\n      totalDamageTaken: 0,\n    },\n    history: sortedFloors.map(floor => ({\n      floorId: floor.id,\n      floorNumber: floor.floorNumber,\n      type: floor.type,\n      outcome: 'pending',\n      rewardsGranted: [],\n    })),\n    pendingRewards: [],\n    config: options.config ?? DEFAULT_TOWER_CONFIG,\n    rentalTeamId: options.rentalTeamId,\n  };\n}\n\nexport function getCurrentFloor(run: TowerRunState, floors: readonly TowerFloor[]): TowerFloor | null {\n  if (run.floorIndex >= run.floorIds.length) {\n    return null;\n  }\n  const currentId = run.floorIds[run.floorIndex] as string;\n  return getFloorById(floors, currentId);\n}\n\nexport function isRestFloor(floor: TowerFloor | null): boolean {\n  return Boolean(floor && floor.type === 'rest');\n}\n\nexport function advanceToNextFloor(run: TowerRunState): TowerRunState {\n  if (run.isCompleted) {\n    return run;\n  }\n  const nextIndex = Math.min(run.floorIndex + 1, run.floorIds.length);\n  const completed = nextIndex >= run.floorIds.length;\n  return {\n    ...run,\n    floorIndex: nextIndex,\n    isCompleted: completed,\n    isFailed: run.isFailed,\n  };\n}\n\nexport interface RecordBattleResultParams {\n  run: TowerRunState;\n  floors: readonly TowerFloor[];\n  outcome: TowerBattleOutcome;\n  summary: TowerBattleSummary;\n  rewards?: readonly TowerRewardEntry[];\n}\n\nexport function recordBattleResult({\n  run,\n  floors,\n  outcome,\n  summary,\n  rewards = [],\n}: RecordBattleResultParams): TowerRunState {\n  const currentFloor = getCurrentFloor(run, floors);\n  if (!currentFloor) {\n    return run;\n  }\n  if (currentFloor.type === 'rest') {\n    throw new Error(`Cannot record battle result for rest floor ${currentFloor.id}`);\n  }\n\n  const nextStats = updateStatsForBattle(run.stats, currentFloor.floorNumber, outcome, summary);\n  const nextHistory: TowerFloorHistoryEntry[] = run.history.map(entry => {\n    if (entry.floorId !== currentFloor.id) {\n      return entry;\n    }\n    return {\n      ...entry,\n      outcome,\n      rewardsGranted: rewards,\n    };\n  });\n\n  const didWin = outcome === 'victory';\n  const didRetreat = outcome === 'retreat';\n  const nextFloorIndex = didWin ? Math.min(run.floorIndex + 1, run.floorIds.length) : run.floorIndex;\n  const hasClearedAllFloors = nextFloorIndex >= run.floorIds.length;\n  const isFailed = outcome === 'defeat';\n  const isCompleted = hasClearedAllFloors || didRetreat || isFailed;\n\n  return {\n    ...run,\n    stats: nextStats,\n    history: nextHistory,\n    floorIndex: nextFloorIndex,\n    isCompleted,\n    isFailed,\n    pendingRewards: rewards.length ? [...run.pendingRewards, ...rewards] : run.pendingRewards,\n    // Retreating ends the run but is not a failure\n  };\n}\n\nexport function completeRestFloor(\n  run: TowerRunState,\n  floors: readonly TowerFloor[],\n  summary: TowerRestSummary\n): TowerRunState {\n  const currentFloor = getCurrentFloor(run, floors);\n  if (!currentFloor) {\n    return run;\n  }\n  if (currentFloor.type !== 'rest') {\n    throw new Error(`completeRestFloor called for non-rest floor ${currentFloor.id}`);\n  }\n\n  const nextHistory = run.history.map(entry => {\n    if (entry.floorId !== currentFloor.id) {\n      return entry;\n    }\n    const updated: TowerFloorHistoryEntry = {\n      ...entry,\n      outcome: 'rested' as const,\n      rewardsGranted: [],\n      restSummary: summary,\n    };\n    return updated;\n  });\n\n  return {\n    ...run,\n    history: nextHistory,\n    floorIndex: Math.min(run.floorIndex + 1, run.floorIds.length),\n    stats: {\n      ...run.stats,\n      highestFloor: Math.max(run.stats.highestFloor, currentFloor.floorNumber),\n    },\n  };\n}\n\nexport function clearPendingRewards(run: TowerRunState): TowerRunState {\n  if (!run.pendingRewards.length) {\n    return run;\n  }\n  return {\n    ...run,\n    pendingRewards: [],\n  };\n}\n\nexport function calculateEnemyScaling(\n  floorNumber: number,\n  difficulty: TowerDifficulty,\n  config: TowerConfig = DEFAULT_TOWER_CONFIG\n): ScalingParams {\n  const baseMultiplier =\n    1 + (floorNumber - 1) * (config.enemyScalingPerFloor ?? TOWER_ENEMY_SCALING_PER_FLOOR);\n  const difficultyBonus = difficulty === 'hard' ? 0.25 : 0;\n  const statMultiplier = baseMultiplier + difficultyBonus;\n  const levelDelta = Math.max(0, Math.floor((floorNumber - 1) * (difficulty === 'hard' ? 1.5 : 1)));\n  return {\n    statMultiplier,\n    levelDelta,\n  };\n}\n\nfunction getFloorById(floors: readonly TowerFloor[], id: string): TowerFloor {\n  const floor = floors.find(entry => entry.id === id);\n  if (!floor) {\n    throw new Error(`Tower floor ${id} not found`);\n  }\n  return floor;\n}\n\nfunction updateStatsForBattle(\n  stats: TowerRunStats,\n  floorNumber: number,\n  outcome: TowerBattleOutcome,\n  summary: TowerBattleSummary\n): TowerRunStats {\n  return {\n    highestFloor: outcome === 'victory' ? Math.max(stats.highestFloor, floorNumber) : stats.highestFloor,\n    totalBattles: stats.totalBattles + 1,\n    victories: stats.victories + (outcome === 'victory' ? 1 : 0),\n    defeats: stats.defeats + (outcome === 'defeat' ? 1 : 0),\n    retreats: stats.retreats + (outcome === 'retreat' ? 1 : 0),\n    turnsTaken: stats.turnsTaken + summary.turnsTaken,\n    totalDamageDealt: stats.totalDamageDealt + summary.damageDealt,\n    totalDamageTaken: stats.totalDamageTaken + summary.damageTaken,\n  };\n}\n\n/**\n * Prepare a floor battle by normalizing the party to the floor's level\n *\n * @param run - Current tower run state\n * @param floors - All tower floors\n * @param playerParty - Player's party units\n * @param curve - Normalization curve to use (default: 'stepped')\n * @returns Normalized party and current floor\n *\n * @throws Error if current floor is not found or is a rest floor\n *\n * @example\n * const { normalizedParty, floor } = prepareFloorBattle(\n *   run,\n *   TOWER_FLOORS,\n *   playerParty,\n *   'stepped'\n * );\n * // Use normalizedParty for battle\n */\nexport function prepareFloorBattle(\n  run: TowerRunState,\n  floors: readonly TowerFloor[],\n  playerParty: readonly Unit[],\n  curve: NormalizationCurve = 'stepped'\n): { normalizedParty: NormalizedUnit[]; floor: TowerFloor } {\n  const floor = getCurrentFloor(run, floors);\n  if (!floor) {\n    throw new Error('No current floor found');\n  }\n  if (floor.type === 'rest') {\n    throw new Error('Cannot prepare battle for rest floor');\n  }\n\n  const normalizedParty = normalizePartyForFloor(playerParty, floor, curve);\n\n  return { normalizedParty, floor };\n}\n\n","/**\n * Djinn Service\n * Handles Djinn collection, equipping, and management\n */\n\nimport type { Team } from '../models/Team';\nimport { updateTeam } from '../models/Team';\nimport { DJINN } from '../../data/definitions/djinn';\nimport type { Result } from '../utils/result';\nimport { Ok, Err } from '../utils/result';\n\n/**\n * Add a Djinn to collected list\n * @throws Error if Djinn doesn't exist or already collected\n */\nexport function collectDjinn(team: Team, djinnId: string): Result<Team, string> {\n  // Validate Djinn exists\n  if (!DJINN[djinnId]) {\n    return Err(`Djinn ${djinnId} does not exist`);\n  }\n\n  // Check if already collected\n  if (team.collectedDjinn.includes(djinnId)) {\n    return Err(`Djinn ${djinnId} already collected`);\n  }\n\n  // Check max collection limit (12)\n  if (team.collectedDjinn.length >= 12) {\n    return Err('Cannot collect more than 12 Djinn');\n  }\n\n  // Add to collected list\n  const newCollectedDjinn = [...team.collectedDjinn, djinnId];\n\n  return Ok(updateTeam(team, {\n    collectedDjinn: newCollectedDjinn,\n  }));\n}\n\n/**\n * Equip a Djinn to team slot (max 3)\n * @throws Error if Djinn not collected, already equipped, or slots full\n */\nexport function equipDjinn(team: Team, djinnId: string, slotIndex: number = -1): Result<Team, string> {\n  // Validate Djinn is collected\n  if (!team.collectedDjinn.includes(djinnId)) {\n    return Err(`Djinn ${djinnId} not collected`);\n  }\n\n  // Check if already equipped\n  if (team.equippedDjinn.includes(djinnId)) {\n    return Err(`Djinn ${djinnId} already equipped`);\n  }\n\n  // Check max slots (3)\n  if (team.equippedDjinn.length >= 3) {\n    if (slotIndex < 0 || slotIndex >= 3) {\n      return Err('All 3 Djinn slots are full. Unequip one first.');\n    }\n\n    // Replace Djinn at slotIndex\n    const newEquippedDjinn = [...team.equippedDjinn];\n    const oldDjinnId = newEquippedDjinn[slotIndex];\n    newEquippedDjinn[slotIndex] = djinnId;\n\n    // Update trackers\n    const newTrackers = { ...team.djinnTrackers };\n    if (oldDjinnId) {\n      delete newTrackers[oldDjinnId];\n    }\n    if (!newTrackers[djinnId]) {\n      newTrackers[djinnId] = {\n        djinnId,\n        state: 'Set',\n        lastActivatedTurn: -1,\n      };\n    }\n\n    return Ok(updateTeam(team, {\n      equippedDjinn: newEquippedDjinn,\n      djinnTrackers: newTrackers,\n    }));\n  }\n\n  // Add to next available slot\n  const newEquippedDjinn = [...team.equippedDjinn, djinnId];\n  const newTrackers = { ...team.djinnTrackers };\n  if (!newTrackers[djinnId]) {\n    newTrackers[djinnId] = {\n      djinnId,\n      state: 'Set',\n      lastActivatedTurn: -1,\n    };\n  }\n\n  return Ok(updateTeam(team, {\n    equippedDjinn: newEquippedDjinn,\n    djinnTrackers: newTrackers,\n  }));\n}\n\n/**\n * Unequip a Djinn from team\n */\nexport function unequipDjinn(team: Team, djinnId: string): Result<Team, string> {\n  if (!team.equippedDjinn.includes(djinnId)) {\n    return Err(`Djinn ${djinnId} not equipped`);\n  }\n\n  const newEquippedDjinn = team.equippedDjinn.filter(id => id !== djinnId);\n  const newTrackers = { ...team.djinnTrackers };\n  delete newTrackers[djinnId];\n\n  return Ok(updateTeam(team, {\n    equippedDjinn: newEquippedDjinn,\n    djinnTrackers: newTrackers,\n  }));\n}\n\n","/**\n * Story Model\n * Tracks chapter progression and story flags\n */\n\n/**\n * Story flag ID\n */\nexport type FlagId = string;\n\n/**\n * Story state\n * Tracks current chapter and flags\n */\nexport interface StoryState {\n  /** Current chapter number */\n  chapter: number;\n  \n  /** Story flags (booleans and counters) */\n  flags: Record<FlagId, boolean | number>;\n}\n\n/**\n * Create initial story state\n */\nexport function createStoryState(chapter: number = 1): StoryState {\n  return {\n    chapter,\n    flags: {},\n  };\n}\n\n/**\n * Set a story flag\n */\nexport function setFlag(state: StoryState, flag: FlagId, value: boolean | number = true): StoryState {\n  return {\n    ...state,\n    flags: {\n      ...state.flags,\n      [flag]: value,\n    },\n  };\n}\n\n/**\n * Get a story flag value\n */\nexport function getFlag(state: StoryState, flag: FlagId): boolean | number | undefined {\n  return state.flags[flag];\n}\n\n/**\n * Check if a flag is set (truthy)\n */\nexport function hasFlag(state: StoryState, flag: FlagId): boolean {\n  return Boolean(state.flags[flag]);\n}\n\n/**\n * Increment a numeric flag\n */\nexport function incrementFlag(state: StoryState, flag: FlagId, amount: number = 1): StoryState {\n  const current = typeof state.flags[flag] === 'number' ? state.flags[flag] as number : 0;\n  return setFlag(state, flag, current + amount);\n}\n\n","/**\n * Story Service\n * Pure functions for story progression and gating\n */\n\nimport type { StoryState, FlagId } from '../models/story';\nimport type { Result } from '../utils/result';\nimport type { Team } from '../models/Team';\nimport type { Unit } from '../models/Unit';\nimport { setFlag, hasFlag } from '../models/story';\nimport { collectDjinn } from './DjinnService';\nimport { createUnit } from '../models/Unit';\nimport { STORY_FLAG_TO_DJINN, STORY_FLAG_TO_UNIT } from '../../data/definitions/storyFlags';\nimport { UNIT_DEFINITIONS } from '../../data/definitions/units';\n\n/**\n * Check if a requirement is met\n */\nexport function canAccess(state: StoryState, requirement: FlagId | FlagId[]): boolean {\n  if (Array.isArray(requirement)) {\n    // All flags must be set\n    return requirement.every(flag => hasFlag(state, flag));\n  }\n  return hasFlag(state, requirement);\n}\n\n/**\n * Advance to next chapter\n * Accepts either encounter ID (e.g., 'c1_boss') or flag key (e.g., 'boss:ch1')\n */\nexport function advanceChapter(\n  state: StoryState,\n  completedKey: string\n): Result<StoryState, string> {\n  // Normalize to flag key\n  const flagKey = encounterIdToFlagKey(completedKey);\n  \n  // Chapter 1 -> Chapter 2: Beat Chapter 1 boss\n  if (flagKey === 'boss:ch1' && state.chapter === 1) {\n    const newState = setFlag(state, 'boss:ch1', true);\n    return {\n      ok: true,\n      value: {\n        ...newState,\n        chapter: 2,\n      },\n    };\n  }\n  \n  // Chapter 2 -> Chapter 3: Beat Chapter 2 boss\n  if (flagKey === 'boss:ch2' && state.chapter === 2) {\n    const newState = setFlag(state, 'boss:ch2', true);\n    return {\n      ok: true,\n      value: {\n        ...newState,\n        chapter: 3,\n      },\n    };\n  }\n  \n  // Chapter 3 -> Credits: Beat Chapter 3 boss\n  if (flagKey === 'boss:ch3' && state.chapter === 3) {\n    const newState = setFlag(state, 'boss:ch3', true);\n    return {\n      ok: true,\n      value: {\n        ...newState,\n        chapter: 4, // Credits chapter\n      },\n    };\n  }\n  \n  return {\n    ok: false,\n    error: `No chapter transition available for ${completedKey} (${flagKey}) at chapter ${state.chapter}`,\n  };\n}\n\n/**\n * Map encounter ID to flag key\n * Centralized mapping for encounter IDs to story flag keys\n */\nexport function encounterIdToFlagKey(encounterId: string): string {\n  // House-based encounters (Chapter 1: Liberation of Vale)\n  if (encounterId === 'house-20') return 'boss:ch1'; // Final boss\n  if (encounterId.startsWith('house-')) {\n    const match = encounterId.match(/^house-(\\d+)$/);\n    if (match) {\n      const houseNum = parseInt(match[1]!, 10);\n      return `encounter:ch1:${houseNum}`;\n    }\n  }\n  \n  // Legacy boss encounters\n  if (encounterId === 'c1_boss') return 'boss:ch1';\n  if (encounterId === 'c2_boss') return 'boss:ch2';\n  if (encounterId === 'c3_boss') return 'boss:ch3';\n  \n  // Legacy mini-boss encounters\n  if (encounterId === 'c1_mini_boss' || encounterId === 'c1_miniboss') return 'miniboss:ch1';\n  if (encounterId === 'c2_mini_boss' || encounterId === 'c2_miniboss') return 'miniboss:ch2';\n  if (encounterId === 'c3_mini_boss' || encounterId === 'c3_miniboss') return 'miniboss:ch3';\n  \n  // Legacy normal encounters (track by chapter and number)\n  if (encounterId.startsWith('c1_normal_')) {\n    const encounterNum = encounterId.replace('c1_normal_', '');\n    return `encounter:ch1:${encounterNum}`;\n  }\n  if (encounterId.startsWith('c2_normal_')) {\n    const encounterNum = encounterId.replace('c2_normal_', '');\n    return `encounter:ch2:${encounterNum}`;\n  }\n  if (encounterId.startsWith('c3_normal_')) {\n    const encounterNum = encounterId.replace('c3_normal_', '');\n    return `encounter:ch3:${encounterNum}`;\n  }\n  \n  // If already a flag key, return as-is\n  if (encounterId.startsWith('boss:') || encounterId.startsWith('miniboss:') || encounterId.startsWith('encounter:')) {\n    return encounterId;\n  }\n  \n  // Fallback: use encounter ID as flag key\n  return encounterId;\n}\n\n/**\n * Process encounter completion\n * Sets flags based on encounter ID\n * For house encounters, sets both the encounter flag and the house flag\n */\nexport function processEncounterCompletion(\n  state: StoryState,\n  encounterId: string\n): StoryState {\n  const flagKey = encounterIdToFlagKey(encounterId);\n  let updatedState = setFlag(state, flagKey, true);\n  \n  // For house encounters, also set the house flag directly (e.g., 'house-02')\n  // This is needed for:\n  // 1. House unlocking (isHouseUnlocked checks house-XX flags)\n  // 2. Story joins (STORY_FLAG_TO_UNIT uses house-XX keys)\n  if (encounterId.startsWith('house-')) {\n    updatedState = setFlag(updatedState, encounterId, true);\n  }\n  \n  return updatedState;\n}\n\n/**\n * Check if a house encounter is unlocked\n * House 1 is always unlocked\n * House N is unlocked if House N-1 is defeated\n * \n * @param story - Current story state\n * @param houseId - House encounter ID (e.g., 'house-03')\n * @returns true if house is unlocked, false otherwise\n */\nexport function isHouseUnlocked(story: StoryState, houseId: string): boolean {\n  // House 1 always unlocked\n  if (houseId === 'house-01') return true;\n\n  // Extract house number from ID (e.g., 'house-03' â†’ 3)\n  const match = houseId.match(/^house-(\\d+)$/);\n  if (!match) return false;\n\n  const [, houseNumRaw] = match;\n  if (!houseNumRaw) return false;\n  const houseNum = parseInt(houseNumRaw, 10);\n\n  // House N unlocked if House N-1 defeated\n  const prevHouseId = `house-${String(houseNum - 1).padStart(2, '0')}`;\n  return story.flags[prevHouseId] === true;\n}\n\n/**\n * Process story flag and grant Djinn if applicable\n * Pure function - no side effects\n * \n * @param story - Current story state\n * @param team - Current team state\n * @param flagId - Story flag being set\n * @param flagValue - Value being set (only grants Djinn if true)\n * @returns Updated story and team (team unchanged if no Djinn granted)\n */\nexport function processStoryFlagForDjinn(\n  story: StoryState,\n  team: Team,\n  flagId: string,\n  flagValue: boolean | number\n): { story: StoryState; team: Team; djinnGranted: string | null } {\n  // Update story flag first\n  const updatedStory = setFlag(story, flagId, flagValue);\n  \n  // Only grant Djinn if flag is being set to true\n  if (flagValue !== true) {\n    return { story: updatedStory, team, djinnGranted: null };\n  }\n  \n  // Check if this flag grants a Djinn\n  const djinnId = STORY_FLAG_TO_DJINN[flagId];\n  if (!djinnId) {\n    return { story: updatedStory, team, djinnGranted: null };\n  }\n  \n  // Try to collect Djinn (pure function)\n  const collectResult = collectDjinn(team, djinnId);\n  if (collectResult.ok) {\n    return { story: updatedStory, team: collectResult.value, djinnGranted: djinnId };\n  }\n  \n  // Already collected or error - return unchanged team\n  // This is safe - collectDjinn returns error if already collected, which we ignore\n  return { story: updatedStory, team, djinnGranted: null };\n}\n\n/**\n * Process story flag and recruit unit if applicable\n * Pure function - no side effects\n *\n * @param story - Current story state\n * @param flagId - Story flag being set\n * @param flagValue - Value being set (only recruits unit if true)\n * @param currentLevel - Current party level (for unit creation)\n * @returns Updated story and recruited unit (null if no unit recruited)\n */\nexport function processStoryFlagForUnit(\n  story: StoryState,\n  flagId: string,\n  flagValue: boolean | number,\n  currentLevel: number = 1\n): { story: StoryState; recruitedUnit: Unit | null } {\n  // Update story flag first\n  const updatedStory = setFlag(story, flagId, flagValue);\n\n  // Only recruit unit if flag is being set to true\n  if (flagValue !== true) {\n    return { story: updatedStory, recruitedUnit: null };\n  }\n\n  // Check if this flag recruits a unit\n  const unitId = STORY_FLAG_TO_UNIT[flagId];\n  if (!unitId) {\n    return { story: updatedStory, recruitedUnit: null };\n  }\n\n  // Get unit definition\n  const unitDef = UNIT_DEFINITIONS[unitId];\n  if (!unitDef) {\n    console.error(`Unit definition ${unitId} not found`);\n    return { story: updatedStory, recruitedUnit: null };\n  }\n\n  // Create unit at current party level (level 1 for Houses 2-3)\n  const recruitedUnit = createUnit(unitDef, currentLevel, 0);\n\n  return { story: updatedStory, recruitedUnit };\n}\n\n","/**\n * XP and leveling algorithms\n * Pure functions, deterministic\n */\n\nimport type { Unit } from '../models/Unit';\n\n/**\n * XP curve from GAME_MECHANICS.md Section 1.1\n * Maps level â†’ cumulative XP needed to reach that level\n * Extended to level 20 for PR-SCHEMA-20\n */\nconst XP_CURVE: Readonly<Record<number, number>> = {\n  1: 0,      // Starting XP\n  2: 100,    // Level 1 â†’ 2\n  3: 350,    // Level 1 â†’ 3  (100 + 250)\n  4: 850,    // Level 1 â†’ 4  (100 + 250 + 500)\n  5: 1850,   // Level 1 â†’ 5  (100 + 250 + 500 + 1000)\n  6: 3100,   // Level 1 â†’ 6\n  7: 4700,   // Level 1 â†’ 7\n  8: 6700,   // Level 1 â†’ 8\n  9: 9200,   // Level 1 â†’ 9\n  10: 12300, // Level 1 â†’ 10\n  11: 16000, // Level 1 â†’ 11\n  12: 20400, // Level 1 â†’ 12\n  13: 25600, // Level 1 â†’ 13\n  14: 31700, // Level 1 â†’ 14\n  15: 38800, // Level 1 â†’ 15\n  16: 47000, // Level 1 â†’ 16\n  17: 56400, // Level 1 â†’ 17\n  18: 67100, // Level 1 â†’ 18\n  19: 79200, // Level 1 â†’ 19\n  20: 92800, // Level 1 â†’ 20\n};\n\n/**\n * Get XP required for a specific level\n * Monotonic: returns clamped values for out-of-range levels\n */\nexport function getXpForLevel(level: number): number {\n  if (level < 1) {\n    return 0; // Below level 1\n  }\n  if (level > 20) {\n    return XP_CURVE[20] || 0; // Clamp to level 20 max\n  }\n  return XP_CURVE[level] || 0;\n}\n\n/**\n * Calculate level from XP\n * Returns the highest level achievable with given XP\n * Uses binary search for efficiency with extended level cap\n * Clamps below level 1 and above level 20\n */\nexport function calculateLevelFromXp(xp: number): number {\n  if (xp < 0) return 1; // Clamp below level 1\n  \n  // Binary search for level\n  let low = 1;\n  let high = 20;\n  let result = 1;\n  \n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    const midXp = XP_CURVE[mid];\n    \n    if (midXp === undefined) {\n      // Shouldn't happen, but handle gracefully\n      break;\n    }\n    \n    if (xp >= midXp) {\n      result = mid;\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  \n  return result; // Already clamped to 1-20 by binary search bounds\n}\n\n/**\n * Add XP to unit and check for level up\n * Returns new unit with updated XP and level, plus level-up info\n */\nexport function addXp(\n  unit: Unit,\n  xpGain: number\n): {\n  unit: Unit;\n  leveledUp: boolean;\n  newLevel: number;\n  unlockedAbilities: readonly string[];\n} {\n  // Clamp XP to minimum 0 to prevent negative values\n  const newXp = Math.max(0, unit.xp + xpGain);\n  const oldLevel = unit.level;\n  const newLevel = calculateLevelFromXp(newXp);\n  const leveledUp = newLevel > oldLevel;\n  \n  // If XP loss causes level down, recalculate unlocked abilities\n  const leveledDown = newLevel < oldLevel;\n\n  // Find abilities that should be unlocked at new level\n  const unlockedAbilities: string[] = [];\n  if (leveledUp) {\n    for (let level = oldLevel + 1; level <= newLevel; level++) {\n      const abilitiesAtLevel = unit.abilities.filter(\n        a => a.unlockLevel === level\n      );\n      unlockedAbilities.push(...abilitiesAtLevel.map(a => a.id));\n    }\n  }\n\n  // If level decreased, remove abilities unlocked at higher levels\n  let finalUnlockedAbilities = unit.unlockedAbilityIds;\n  if (leveledDown) {\n    // Keep only abilities unlocked at or below the new level\n    finalUnlockedAbilities = unit.abilities\n      .filter(a => a.unlockLevel <= newLevel)\n      .map(a => a.id);\n  } else if (leveledUp) {\n    // Add newly unlocked abilities\n    finalUnlockedAbilities = [...unit.unlockedAbilityIds, ...unlockedAbilities];\n  }\n\n  const updatedUnit: Unit = {\n    ...unit,\n    xp: newXp,\n    level: newLevel,\n    unlockedAbilityIds: finalUnlockedAbilities,\n  };\n\n  return {\n    unit: updatedUnit,\n    leveledUp,\n    newLevel,\n    unlockedAbilities,\n  };\n}\n\n/**\n * Calculate max HP for a unit at a given level\n */\nexport function calculateMaxHpAtLevel(\n  baseHp: number,\n  growthRate: number,\n  level: number\n): number {\n  return baseHp + (level - 1) * growthRate;\n}\n\n/**\n * Get XP progress to next level\n * Returns current level, XP progress, and XP needed for next level\n * Useful for UI progress bars\n */\nexport function getXpProgress(xp: number): {\n  level: number;\n  current: number;\n  needed: number;\n  progress: number; // 0.0 to 1.0\n} {\n  const level = calculateLevelFromXp(xp);\n  const currentLevelXp = getXpForLevel(level);\n  const nextLevelXp = getXpForLevel(level + 1);\n  \n  const current = xp - currentLevelXp;\n  const needed = nextLevelXp > currentLevelXp ? nextLevelXp - currentLevelXp : 0;\n  const progress = needed > 0 ? current / needed : 1.0;\n  \n  return {\n    level,\n    current,\n    needed,\n    progress: Math.max(0, Math.min(1, progress)), // Clamp to [0, 1]\n  };\n}\n\n","/**\n * Reward calculation algorithms\n * Ported from original Vale Chronicles, adapted for vale-v2\n * Fully deterministic now â€” all gold/xp/equipment come from encounter data\n */\n\nimport type { Unit } from '../models/Unit';\nimport type { Team } from '../models/Team';\nimport type { BattleRewards, LevelUpEvent, RewardDistribution, StatGains } from '../models/Rewards';\nimport { addXp } from './xp';\nimport { isUnitKO } from '../models/Unit';\nimport { ENCOUNTERS } from '../../data/definitions/encounters';\n\n/**\n * Calculate total rewards from a predetermined encounter\n *\n * @param encounterId - Encounter identifier\n * @param survivorCount - Number of surviving party members\n * @returns Predetermined battle rewards\n */\nexport function calculateBattleRewards(\n  encounterId: string,\n  survivorCount: number\n): BattleRewards {\n  const encounter = ENCOUNTERS[encounterId];\n  if (!encounter) {\n    throw new Error(`Encounter ${encounterId} not found`);\n  }\n\n  const allSurvived = survivorCount === 4;\n  const xpPerUnit = survivorCount > 0 ? Math.floor(encounter.reward.xp / survivorCount) : 0;\n\n  return {\n    totalXp: encounter.reward.xp,\n    totalGold: encounter.reward.gold,\n    xpPerUnit,\n    survivorCount,\n    allSurvived,\n    enemiesDefeated: encounter.enemies.length,\n    equipmentReward: encounter.reward.equipment,\n  };\n}\n\n/**\n * Calculate stat gains from leveling up\n * \n * Used to populate LevelUpEvent.statGains by comparing\n * stats before and after level-up.\n * \n * @param unit - Unit that leveled up\n * @param oldLevel - Level before gaining XP\n * @param newLevel - Level after gaining XP\n * @returns Stat gains per level\n */\nexport function calculateStatGains(\n  unit: Unit,\n  oldLevel: number,\n  newLevel: number\n): StatGains {\n  // Calculate total stat gains across all level-ups\n  const levelDiff = newLevel - oldLevel;\n\n  return {\n    hp: unit.growthRates.hp * levelDiff,\n    pp: unit.growthRates.pp * levelDiff,\n    atk: unit.growthRates.atk * levelDiff,\n    def: unit.growthRates.def * levelDiff,\n    mag: unit.growthRates.mag * levelDiff,\n    spd: unit.growthRates.spd * levelDiff,\n  };\n}\n\n/**\n * Distribute rewards to team and handle level-ups\n * \n * Process:\n * 1. Give XP to each surviving unit using addXp()\n * 2. Track level-up events with stat gains\n * 3. Track newly unlocked abilities\n * 4. Return complete distribution report with updated team\n * \n * @param team - Player's team\n * @param rewards - Calculated battle rewards\n * @returns Distribution result with level-up events and updated team\n */\nexport function distributeRewards(\n  team: Team,\n  rewards: BattleRewards\n): RewardDistribution & { updatedTeam: Team } {\n  const levelUps: LevelUpEvent[] = [];\n  const updatedUnits: Unit[] = [];\n\n  // Distribute XP to surviving units\n  for (const unit of team.units) {\n    // Skip KO'd units\n    if (isUnitKO(unit)) {\n      updatedUnits.push(unit);\n      continue;\n    }\n\n    // Skip max level units (level 20 cap)\n    if (unit.level >= 20) {\n      updatedUnits.push(unit);\n      continue;\n    }\n\n    // Track before state\n    const oldLevel = unit.level;\n\n    // Give XP using addXp() function (returns new unit)\n    const xpResult = addXp(unit, rewards.xpPerUnit);\n    const updatedUnit = xpResult.unit;\n    updatedUnits.push(updatedUnit);\n\n    // Check if leveled up\n    if (xpResult.leveledUp) {\n      // Calculate stat gains\n      const statGains = calculateStatGains(updatedUnit, oldLevel, xpResult.newLevel);\n\n      // Record level-up event\n      levelUps.push({\n        unitId: updatedUnit.id,\n        unitName: updatedUnit.name,\n        oldLevel,\n        newLevel: xpResult.newLevel,\n        statGains,\n        newAbilitiesUnlocked: xpResult.unlockedAbilities,\n      });\n    }\n  }\n\n  // Create updated team with new unit states\n  const updatedTeam: Team = {\n    ...team,\n    units: updatedUnits,\n  };\n\n  return {\n    rewards,\n    levelUps,\n    goldEarned: rewards.totalGold,\n    updatedTeam,\n  };\n}\n","/**\n * Rewards Service\n * Handles post-battle reward processing (no RNG)\n */\n\nimport type { BattleState } from '../models/BattleState';\nimport type { RewardDistribution } from '../models/Rewards';\nimport type { Team } from '../models/Team';\nimport { isUnitKO } from '../models/Unit';\nimport { calculateBattleRewards, distributeRewards } from '../algorithms/rewards';\nimport { getEncounterId } from '../models/BattleState';\nimport { EQUIPMENT } from '../../data/definitions/equipment';\nimport type { EquipmentReward } from '../../data/schemas/EncounterSchema';\n\ntype EquipmentResolution =\n  | { type: 'none' }\n  | { type: 'fixed'; equipment: typeof EQUIPMENT[keyof typeof EQUIPMENT] }\n  | { type: 'choice'; options: (typeof EQUIPMENT[keyof typeof EQUIPMENT])[] };\n\nexport function processVictory(\n  battle: BattleState\n): { distribution: RewardDistribution; updatedTeam: Team } {\n  const encounterId = getEncounterId(battle);\n  if (!encounterId) {\n    throw new Error('Cannot process victory without encounter ID');\n  }\n\n  const survivors = battle.playerTeam.units.filter(u => !isUnitKO(u));\n  const rewards = calculateBattleRewards(encounterId, survivors.length);\n\n  const distribution = distributeRewards(battle.playerTeam, rewards);\n  const equipmentResolution = resolveEquipmentReward(rewards.equipmentReward);\n\n  // NOTE: Djinn rewards and unit recruitment are now handled via post-battle recruitment dialogues\n  // The encounter.reward.djinn and encounter.reward.unlockUnit fields are kept for validation\n  // but not processed here. All rewards are narrative-driven via dialogue effects.\n\n  let updatedTeam = distribution.updatedTeam;\n\n  // Reset all Djinn to Set state after battle (like units heal to full)\n  const resetDjinnTrackers = { ...updatedTeam.djinnTrackers };\n  for (const djinnId in resetDjinnTrackers) {\n    const tracker = resetDjinnTrackers[djinnId];\n    if (tracker) {\n      resetDjinnTrackers[djinnId] = {\n        djinnId: tracker.djinnId,\n        state: 'Set',\n        lastActivatedTurn: tracker.lastActivatedTurn,\n      };\n    }\n  }\n  updatedTeam = {\n    ...updatedTeam,\n    djinnTrackers: resetDjinnTrackers,\n  };\n\n  // NOTE: Unit recruitment is now handled via post-battle recruitment dialogues\n  // The encounter.reward.unlockUnit field is kept for validation but not processed here\n  // All recruitment is narrative-driven via dialogue effects (recruitUnit)\n\n  const resolvedDistribution: RewardDistribution = {\n    ...distribution,\n    fixedEquipment: equipmentResolution.type === 'fixed' ? equipmentResolution.equipment : undefined,\n    equipmentChoice: equipmentResolution.type === 'choice' ? equipmentResolution.options : undefined,\n  };\n\n  return {\n    distribution: resolvedDistribution,\n    updatedTeam,\n    // No recruitedUnit - all recruitment is narrative-driven\n  };\n}\n\nexport function resolveEquipmentReward(reward: EquipmentReward): EquipmentResolution {\n  switch (reward.type) {\n    case 'none':\n      return { type: 'none' };\n    case 'fixed': {\n      const equipment = EQUIPMENT[reward.itemId];\n      if (!equipment) {\n        throw new Error(`Equipment ${reward.itemId} not found`);\n      }\n      return { type: 'fixed', equipment };\n    }\n    case 'choice': {\n      const options = reward.options.map(id => {\n        const equipment = EQUIPMENT[id];\n        if (!equipment) {\n          throw new Error(`Equipment ${id} not found`);\n        }\n        return equipment;\n      });\n      return { type: 'choice', options };\n    }\n  }\n}\n","/**\n * Utility to convert UnitDefinition to Enemy definition\n * Calculates stats at a given level: baseStats + (level - 1) * growthRates\n * \n * This ensures enemy stats match what the unit would have at that level\n * when recruited (for consistency).\n */\n\nimport type { UnitDefinition } from '../../data/schemas/UnitSchema';\nimport type { Enemy } from '../../data/schemas/EnemySchema';\nimport type { Stats } from '../models/types';\n\n/**\n * Calculate unit stats at a specific level\n * Formula: baseStats + (level - 1) * growthRates\n * \n * @param unitDef - Unit definition\n * @param level - Target level (1-20)\n * @returns Stats at that level\n */\nfunction calculateStatsAtLevel(unitDef: UnitDefinition, level: number): Stats {\n  const levelBonus = level - 1; // Level 1 = 0 bonus, Level 2 = 1 bonus, etc.\n  \n  return {\n    hp: unitDef.baseStats.hp + (levelBonus * unitDef.growthRates.hp),\n    pp: unitDef.baseStats.pp + (levelBonus * unitDef.growthRates.pp),\n    atk: unitDef.baseStats.atk + (levelBonus * unitDef.growthRates.atk),\n    def: unitDef.baseStats.def + (levelBonus * unitDef.growthRates.def),\n    mag: unitDef.baseStats.mag + (levelBonus * unitDef.growthRates.mag),\n    spd: unitDef.baseStats.spd + (levelBonus * unitDef.growthRates.spd),\n  };\n}\n\n/**\n * Convert a UnitDefinition to an Enemy definition\n * \n * @param unitDef - Unit definition to convert\n * @param level - Enemy level (defaults to 2 for VS1, can be customized per encounter)\n * @param baseXp - Base XP reward (defaults to 60)\n * @param baseGold - Base gold reward (defaults to 19)\n * @returns Enemy definition with stats calculated at the given level\n */\ninterface UnitToEnemyOptions {\n  id?: string;\n  stats?: Partial<Stats>;\n}\n\nexport function unitDefinitionToEnemy(\n  unitDef: UnitDefinition,\n  level: number = 2,\n  baseXp: number = 60,\n  baseGold: number = 19,\n  options: UnitToEnemyOptions = {}\n): Enemy {\n  // Calculate stats at target level\n  const statsAtLevel = calculateStatsAtLevel(unitDef, level);\n  \n  // Apply stat overrides if provided\n  const finalStats = options.stats \n    ? { ...statsAtLevel, ...options.stats }\n    : statsAtLevel;\n  \n  // Get abilities unlocked at this level\n  const abilitiesAtLevel = unitDef.abilities.filter(\n    ability => level >= (ability.unlockLevel ?? 1)\n  );\n  \n  // Ensure at least 1 ability (fallback to first ability if none unlocked)\n  const enemyAbilities = abilitiesAtLevel.length > 0 \n    ? abilitiesAtLevel \n    : [unitDef.abilities[0]!];\n  \n  return {\n    id: options.id ?? `${unitDef.id}-enemy`,\n    name: unitDef.name, // Use same name (e.g., \"Garet\" not \"Garet Enemy\")\n    level,\n    element: unitDef.element,\n    stats: finalStats,\n    abilities: enemyAbilities,\n    baseXp,\n    baseGold,\n  };\n}\n\n","/**\n * Utility to convert Enemy definitions to Unit instances for battle\n * Enemies are simpler data structures that get converted to full Unit objects\n */\n\nimport type { Enemy } from '../../data/schemas/EnemySchema';\nimport type { UnitDefinition } from '../../data/schemas/UnitSchema';\nimport { createUnit } from '../models/Unit';\n\n/**\n * Convert an Enemy definition to a Unit instance for battle\n * Enemies have fixed stats (no growth rates) and simplified structure\n */\nexport function enemyToUnit(enemy: Enemy, level?: number): ReturnType<typeof createUnit> {\n  const unitDef: UnitDefinition = {\n    id: enemy.id,\n    name: enemy.name,\n    element: enemy.element,\n    role: 'Pure DPS', // Enemies use generic role\n    baseStats: enemy.stats,\n    growthRates: {\n      hp: 0,\n      pp: 0,\n      atk: 0,\n      def: 0,\n      mag: 0,\n      spd: 0,\n    }, // No growth for enemies\n    abilities: enemy.abilities,\n    manaContribution: 0, // Enemies don't contribute to player mana pool\n    description: `A ${enemy.name} enemy`,\n    autoAttackTiming: 'same-turn',\n  };\n\n  return createUnit(unitDef, level ?? enemy.level, 0);\n}\n","/**\n * Encounter Service\n * Handles loading encounters and converting them to battle state\n */\n\nimport type { Encounter } from '../../data/schemas/EncounterSchema';\nimport type { BattleState } from '../models/BattleState';\nimport type { Team } from '../models/Team';\nimport type { PRNG } from '../random/prng';\nimport { ENEMIES } from '../../data/definitions/enemies';\nimport { ENCOUNTERS } from '../../data/definitions/encounters';\nimport { enemyToUnit } from '../utils/enemyToUnit';\nimport { startBattle } from './BattleService';\n\n/**\n * Load an encounter by ID\n * Returns the encounter definition or null if not found\n */\nexport function loadEncounter(encounterId: string): Encounter | null {\n  return ENCOUNTERS[encounterId] || null;\n}\n\n/**\n * Create battle state from an encounter\n * Converts encounter enemy IDs to Unit instances and initializes battle\n */\nexport function createBattleFromEncounter(\n  encounterId: string,\n  playerTeam: Team,\n  rng: PRNG\n): { battle: BattleState; encounter: Encounter } | null {\n  const encounter = loadEncounter(encounterId);\n  if (!encounter) {\n    return null;\n  }\n\n  // Convert enemy IDs to Unit instances with unique IDs\n  const enemyUnits = encounter.enemies\n    .map((enemyId, index) => {\n      const enemyDef = ENEMIES[enemyId];\n      if (!enemyDef) {\n        console.error(`Enemy not found: ${enemyId}`);\n        return null;\n      }\n      const enemy = enemyToUnit(enemyDef);\n      // Give each enemy a unique ID (e.g., wolf_0, wolf_1)\n      return { ...enemy, id: `${enemy.id}_${index}` };\n    })\n    .filter((u): u is ReturnType<typeof enemyToUnit> => u !== null);\n\n  if (enemyUnits.length === 0) {\n    console.error(`No valid enemies found for encounter: ${encounterId}`);\n    return null;\n  }\n\n  // Create battle state with encounter metadata\n  const battleResult = startBattle(playerTeam, enemyUnits, rng);\n\n  if (!battleResult.ok) {\n    console.error(`Failed to start battle: ${battleResult.error}`);\n    return null;\n  }\n\n  // Add encounter metadata\n  const battleWithMeta: BattleState = {\n    ...battleResult.value,\n    encounterId: encounter.id, // Legacy field\n    meta: {\n      encounterId: encounter.id,\n      difficulty: encounter.difficulty === 'boss' ? 'boss' : 'normal',\n    },\n    isBossBattle: encounter.difficulty === 'boss',\n  };\n\n  return { battle: battleWithMeta, encounter };\n}\n\n/**\n * Get the next encounter in a chapter sequence\n * For now, returns hardcoded Chapter 1 sequence\n */\nexport function getChapter1Encounters(): readonly string[] {\n  const baseOrder = [\n    'c1_normal_1',\n    'c1_normal_2',\n    'c1_normal_3',\n    'c1_mini_boss',\n    'c1_boss',\n  ] as const;\n\n  // Include any additional Chapter 1 encounters declared in ENCOUNTERS (c1_ prefix),\n  // preserving the preferred base order and appending any extras in sorted order.\n  const discovered = Object.keys(ENCOUNTERS)\n    .filter((id) => id.startsWith('c1_'))\n    .sort();\n\n  const merged = [\n    ...baseOrder,\n    ...discovered.filter((id) => !baseOrder.includes(id as typeof baseOrder[number])),\n  ];\n\n  return merged;\n}\n\n/**\n * Check if an encounter is a boss encounter\n */\nexport function isBossEncounter(encounterId: string): boolean {\n  const encounter = loadEncounter(encounterId);\n  return encounter?.id.includes('boss') ?? false;\n}\n\n/**\n * Roll for a random encounter based on map encounter rate\n * Returns true if an encounter should trigger\n */\nexport function rollForRandomEncounter(encounterRate: number, rng: PRNG): boolean {\n  if (encounterRate <= 0) return false;\n  const roll = rng.next();\n  return roll < encounterRate;\n}\n\n/**\n * Select a random encounter from a pool of encounter IDs\n * Returns null if pool is empty or invalid\n */\nexport function selectRandomEncounter(\n  encounterPool: readonly string[],\n  rng: PRNG\n): string | null {\n  if (!encounterPool || encounterPool.length === 0) {\n    return null;\n  }\n\n  const index = Math.floor(rng.next() * encounterPool.length);\n  const encounterId = encounterPool[index];\n  return encounterId ?? null;\n}\n\n/**\n * Process random encounter logic for a map\n * Returns encounter ID if one triggers, null otherwise\n */\nexport function processRandomEncounter(\n  mapEncounterRate: number | undefined,\n  mapEncounterPool: readonly string[] | undefined,\n  rng: PRNG\n): string | null {\n  if (!mapEncounterRate || !mapEncounterPool) {\n    return null;\n  }\n\n  if (!rollForRandomEncounter(mapEncounterRate, rng)) {\n    return null;\n  }\n\n  return selectRandomEncounter(mapEncounterPool, rng);\n}\n\n","import type { GameMap, MapTrigger, Position, Tile } from '../models/overworld';\n\nfunction getTile(map: GameMap, position: Position): Tile | undefined {\n  const withinX = position.x >= 0 && position.x < map.width;\n  const withinY = position.y >= 0 && position.y < map.height;\n  if (!withinX || !withinY) return undefined;\n  const row = map.tiles[position.y];\n  if (!row) return undefined;\n  return row[position.x];\n}\n\nexport function canMoveTo(map: GameMap, position: Position): boolean {\n  const tile = getTile(map, position);\n  if (!tile) return false;\n  if (!tile.walkable) return false;\n  const npcCollision = map.npcs.find(npc => npc.position.x === position.x && npc.position.y === position.y);\n  if (npcCollision) {\n    const hasNpcTrigger = map.triggers.some(trigger =>\n      trigger.type === 'npc' && trigger.position.x === position.x && trigger.position.y === position.y\n    );\n    if (!hasNpcTrigger) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function getTriggerAt(map: GameMap, position: Position): MapTrigger | undefined {\n  return map.triggers.find(trigger => trigger.position.x === position.x && trigger.position.y === position.y);\n}\n\nexport function processMovement(\n  currentMap: GameMap,\n  currentPos: Position,\n  direction: 'up' | 'down' | 'left' | 'right'\n): { newPos: Position; blocked: boolean; trigger?: MapTrigger } {\n  const delta: Record<'up' | 'down' | 'left' | 'right', Position> = {\n    up: { x: 0, y: -1 },\n    down: { x: 0, y: 1 },\n    left: { x: -1, y: 0 },\n    right: { x: 1, y: 0 },\n  };\n  const nextPos: Position = {\n    x: currentPos.x + delta[direction].x,\n    y: currentPos.y + delta[direction].y,\n  };\n\n  if (!canMoveTo(currentMap, nextPos)) {\n    return { newPos: currentPos, blocked: true };\n  }\n\n  const trigger = getTriggerAt(currentMap, nextPos);\n  return { newPos: nextPos, blocked: false, trigger };\n}\n","import type {\n  DialogueTree,\n  DialogueNode,\n  DialogueChoice,\n  DialogueCondition,\n  DialogueState,\n} from '../models/dialogue';\n\nexport function startDialogue(tree: DialogueTree): DialogueState {\n  return {\n    treeId: tree.id,\n    currentNodeId: tree.startNodeId,\n    history: [tree.startNodeId],\n    variables: {},\n  };\n}\n\nexport function getCurrentNode(tree: DialogueTree, state: DialogueState): DialogueNode | undefined {\n  return tree.nodes.find(node => node.id === state.currentNodeId);\n}\n\ntype DialogueContext = {\n  flags: Record<string, boolean>;\n  inventory: { items: string[] };\n  gold: number;\n  level: number;\n};\n\nexport function evaluateCondition(condition: DialogueCondition, context: DialogueContext): boolean {\n  switch (condition.type) {\n    case 'flag':\n      return context.flags[condition.key] === condition.value;\n    case 'item':\n      return context.inventory.items.includes(condition.key);\n    case 'gold':\n      if (condition.operator === 'greaterThan') return context.gold > (condition.value as number);\n      if (condition.operator === 'lessThan') return context.gold < (condition.value as number);\n      return context.gold === condition.value;\n    case 'level':\n      if (condition.operator === 'greaterThan') return context.level > (condition.value as number);\n      if (condition.operator === 'lessThan') return context.level < (condition.value as number);\n      return context.level === condition.value;\n    default:\n      return false;\n  }\n}\n\nexport function getAvailableChoices(node: DialogueNode, context: DialogueContext): DialogueChoice[] {\n  if (!node.choices) return [];\n  return node.choices.filter(choice => {\n    if (!choice.condition) return true;\n    return evaluateCondition(choice.condition, context);\n  });\n}\n\nexport function selectChoice(tree: DialogueTree, state: DialogueState, choiceId: string): DialogueState {\n  const currentNode = getCurrentNode(tree, state);\n  if (!currentNode) return state;\n\n  const choice = currentNode.choices?.find(c => c.id === choiceId);\n  if (!choice) return state;\n\n  return {\n    ...state,\n    currentNodeId: choice.nextNodeId,\n    history: [...state.history, choice.nextNodeId],\n    variables: choice.effects ? { ...state.variables, ...choice.effects } : state.variables,\n  };\n}\n\nexport function advanceDialogue(tree: DialogueTree, state: DialogueState): DialogueState | null {\n  const currentNode = getCurrentNode(tree, state);\n  if (!currentNode) return null;\n  if (currentNode.choices && currentNode.choices.length > 0) return null;\n  if (currentNode.nextNodeId) {\n    return {\n      ...state,\n      currentNodeId: currentNode.nextNodeId,\n      history: [...state.history, currentNode.nextNodeId],\n      // Copy effects from current node to state variables so they get processed\n      variables: currentNode.effects ? { ...state.variables, ...currentNode.effects } : state.variables,\n    };\n  }\n  return null;\n}\n\nexport function isDialogueComplete(tree: DialogueTree, state: DialogueState): boolean {\n  const currentNode = getCurrentNode(tree, state);\n  if (!currentNode) return true;\n  return !currentNode.choices && !currentNode.nextNodeId;\n}\n","import type { Equipment } from '../../data/schemas/EquipmentSchema';\nimport type { Unit } from '../models/Unit';\n\n/**\n * Determine whether a unit can equip the specified item.\n * REFACTORED: Element-based restrictions (not unit-specific)\n * Pure helper used by UI/service layers before applying equipment.\n */\nexport function canEquipItem(unit: Unit, equipment: Equipment): boolean {\n  return equipment.allowedElements.includes(unit.element);\n}\n\n/**\n * Filter the provided equipment list by unit element.\n * REFACTORED: Uses element instead of unit ID\n */\nexport function getEquippableItems(\n  equipmentList: readonly Equipment[],\n  unit: Unit\n): Equipment[] {\n  return equipmentList.filter(eq => eq.allowedElements.includes(unit.element));\n}\n","/**\n * Shop Service\n * Handles buying equipment\n * REFACTORED: Element-based equipment system\n */\n\nimport type { Result } from '../utils/result';\nimport { Ok, Err } from '../utils/result';\nimport type { Equipment } from '../models/Equipment';\nimport type { Unit } from '../models/Unit';\nimport type { Element } from '../models/types';\nimport { EQUIPMENT } from '../../data/definitions/equipment';\nimport { getStarterKit } from '../../data/definitions/starterKits';\nimport { canEquipItem } from '../algorithms/equipment';\n\n/**\n * Check if player can afford an item\n */\nexport function canAffordItem(gold: number, itemId: string): boolean {\n  const item = EQUIPMENT[itemId];\n  if (!item) {\n    return false;\n  }\n  return gold >= item.cost;\n}\n\n/**\n * Buy an item\n * Returns new gold amount and success status\n */\nexport function buyItem(gold: number, itemId: string): Result<{ success: boolean; newGold: number; item: Equipment }, string> {\n  const item = EQUIPMENT[itemId];\n  if (!item) {\n    return Err(`Item ${itemId} not found`);\n  }\n\n  if (gold < item.cost) {\n    return Err(`Cannot afford ${item.name}. Need ${item.cost}g, have ${gold}g`);\n  }\n\n  return Ok({\n    success: true,\n    newGold: gold - item.cost,\n    item,\n  });\n}\n\n/**\n * Purchase starter kit for a unit based on element\n * REFACTORED: Element-based kit system (not unit-specific)\n */\nexport function purchaseStarterKit(\n  unit: { id: string; element: Element },\n  currentGold: number\n): Result<{ newGold: number; equipment: Equipment[] }, string> {\n  const kit = getStarterKit(unit);\n\n  if (currentGold < kit.cost) {\n    return Err(`Insufficient gold. Need ${kit.cost}g, have ${currentGold}g`);\n  }\n\n  const equipmentIds = Object.values(kit.equipment);\n  const equipmentList: Equipment[] = [];\n  for (const id of equipmentIds) {\n    const item = EQUIPMENT[id];\n    if (!item) {\n      return Err(`Equipment ${id} not found for ${kit.name}`);\n    }\n    equipmentList.push(item);\n  }\n\n  return Ok({\n    newGold: currentGold - kit.cost,\n    equipment: equipmentList,\n  });\n}\n\nexport function purchaseUnitEquipment(\n  unit: Unit,\n  gold: number,\n  itemId: string\n): Result<{ newGold: number; item: Equipment }, string> {\n  const item = EQUIPMENT[itemId];\n  if (!item) {\n    return Err(`Item ${itemId} not found`);\n  }\n\n  if (!canEquipItem(unit, item)) {\n    return Err(`${unit.name} cannot equip ${item.name}`);\n  }\n\n  if (gold < item.cost) {\n    return Err(`Cannot afford ${item.name}. Need ${item.cost}g, have ${gold}g`);\n  }\n\n  return Ok({\n    newGold: gold - item.cost,\n    item,\n  });\n}\n\n/**\n * Get price for an item by tier (for reference)\n * Tier 1 = 100g, Tier 2 = 300g, Tier 3 = 800g, Tier 4 = 2000g\n */\nexport function getPriceByTier(tier: Equipment['tier']): number {\n  const tierPrices: Record<Equipment['tier'], number> = {\n    basic: 100,\n    bronze: 300,\n    iron: 800,\n    steel: 2000,\n    silver: 2000, // Same as steel\n    mythril: 2000, // Same as steel\n    legendary: 2000, // Same as steel\n    artifact: 2000, // Same as steel\n  };\n  return tierPrices[tier] ?? 100;\n}\n\n"],"names":["MIN_PARTY_SIZE","MAX_PARTY_SIZE","RNG_STREAMS","RNG_STREAM_BASE_MULTIPLIER","BATTLE_CONSTANTS","createEmptyQueue","size","createRNGStream","rngSeed","turnNumber","stream","offset","createTeam","units","updateTeam","team","updates","DJINN_SUMMON_DAMAGE","calculateDjinnSynergy","djinnElements","elementCounts","element","uniqueElements","maxCount","primaryElement","count","getSetDjinnIds","djinnId","calculateSummonDamage","djinnCount","canActivateDjinn","COUNTER_PAIRS","getElementCompatibility","unitElement","djinnElement","calculateDjinnBonusesForUnit","unit","setDjinnIds","totals","getDjinnElementFromId","compatibility","addStat","key","value","DJINN","getStandbyDjinnIds","getDjinnGrantedAbilitiesForUnit","standbyDjinnIds","granted","djinn","abilityGroup","abilitiesToGrant","mergeDjinnAbilitiesIntoUnit","abilityIds","existingIds","ability","baseAbilities","DJINN_ABILITIES","baseUnlocked","id","djinnAbilities","mergedAbilities","mergedUnlocked","getDjinnAbilityMetadataForUnit","djinnIds","targetDjinn","seen","metadata","abilityList","abilityId","getLockedDjinnAbilityMetadataForUnit","lockedDjinnIds","lockedSet","meta","buildUnitIndex","playerUnits","enemyUnits","index","calculateTeamManaPool","total","createBattleState","playerTeam","enemies","turnOrder","unitsWithDjinnAbilities","updatedTeam","maxMana","unitById","updateBattleState","state","newState","getEncounterId","battle","calculateMaxHp","levelBonus","isUnitKO","createUnit","definition","level","initialXp","maxHp","unlockedAbilityIds","updateUnit","createEmptyLoadout","calculateEquipmentBonuses","loadout","item","stat","calculateLevelBonuses","calculateStatusModifiers","modifiers","status","statKey","modifier","current","calculateEffectiveStats","base","equipment","getEffectiveSPD","ELEMENT_ADVANTAGE","getElementModifier","attackElement","defenseElement","reverseKey","applyDamageModifiers","baseDamage","abilityElement","defender","modifiedDamage","resistanceFactor","effect","sum","mod","totalDamageReduction","pct","clampedReduction","calculatePhysicalDamage","attacker","attackerEffective","defenderEffective","attackPower","ignoreDefensePercent","effectiveDefense","rawDamage","calculatePsynergyDamage","basePower","magicPower","magicDefense","elementModifier","resist","calculateHealAmount","caster","baseHeal","rawHeal","isInvulnerable","hasShieldCharges","consumeShieldCharge","chargeConsumed","updatedStatusEffects","applyDamage","damage","newHp","applyDamageWithShields","updatedUnit","finalUnit","revived","checkAutoRevive","cleanedStatusEffects","autoReviveStatus","reviveHp","foundFirst","applyHealing","healing","abilityRevivesFallen","calculateTurnOrder","rng","aliveUnits","u","priorityUnits","regularUnits","tieRng","i","sortedPriority","a","b","aSpd","spdDiff","aIsPlayer","bIsPlayer","sortedRegular","processStatusEffectTick","totalDamage","totalHealing","messages","modifiedUnit","checkParalyzeFailure","e","isFrozen","isImmuneToStatus","statusType","immunities","t","isNegativeStatus","applyStatusToUnit","newStatus","resolveTargets","isPlayerUnit","filterValidTargets","targets","getValidTargets","Ok","Err","error","BattleTransaction","REMOVABLE_STATUS_TYPES","isRemovableStatusType","type","startBattle","allUnits","performAction","actorId","targetIds","transaction","actorEntry","actor","freezeStatus","events","paralyzeStatus","potentialTargets","aliveTargets","statusEffectsBefore","target","abilityResult","executeAbility","result","updatedPlayerUnits","up","updatedEnemies","updatedState","targetId","updatedTarget","beforeStatuses","afterUnit","afterStatuses","beforeTypes","s","applyPhase2Effects","modifiedTarget","shieldStatus","damageReductionStatus","elementalResistanceStatus","immunityStatus","removeSpec","filteredStatuses","typesToRemove","message","updatedUnits","hitCount","currentTarget","targetDamage","hit","actualDamage","existingIndex","statusDuration","statusChance","newDebuffs","validStats","debuff","primaryTargetId","splashPercent","secondaryTargets","enemy","secondaryTarget","currentSecondary","splashDamage","unitsWithPhase2Effects","finalUnits","reviveHPPercent","healAmount","hotEffect","_exhaustive","endTurn","workingState","currentActorId","nextIndex","updated","currentActorEntry","currentActor","statusResult","newTurn","newTurnOrder","checkBattleEnd","allPlayerKO","allEnemiesKO","startTurnTick","updatedAllUnits","pu","updatedBattle","newEvents","makeStatusKey","oldStatusIds","newStatusIds","statusKey","scoreAbility","score","enemyTeam","casterTeam","casterStats","validTargets","estimatedValue","casterStat","avgTargetDef","targetTeam","def","avgDamage","avgElementMod","casterMag","v","selectTargets","scored","currentHp","hpRatio","effectiveHp","resistMod","estimatedDamage","nonOverkill","healers","makeAIDecision","availableAbilities","chosenAbility","topTwo","XorShiftPRNG","seed","cloned","snapshot","prng","makePRNG","canAffordAction","remainingMana","manaCost","getAbilityManaCost","calculateTotalQueuedManaCost","queuedActions","action","validateQueuedActions","isBasicAttack","shouldGenerateMana","__actionResult","queueAction","unitId","unitIndex","teamSize","previousAction","availableMana","newQueuedActions","clearQueuedAction","queueDjinn","unqueueDjinn","refreshMana","validateQueueForExecution","aliveUnitCount","aliveUnitActions","transitionToExecutingPhase","executeAllActionsPhase","playerActions","enemyActions","generateEnemyActions","allActions","sortedActions","sortActionsBySPD","currentState","resolveValidTargets","actionResult","newMana","checkBattleEndPhase","transitionToVictoryOrDefeat","transitionToPlanningPhase","updatedTimers","updatedTrackers","timer","tracker","unitsWithClampedStats","newMaxHp","nextState","executeRound","allEvents","djinnResult","executeDjinnSummons","actionsResult","battleEnd","prePlanningState","recoveredDjinnIds","getRecoveredDjinnIds","preBonuses","snapshotDjinnBonuses","postBonuses","recoveryEvents","buildDjinnStateChangeEvents","queuedDjinnData","recoveryTime","unitsWithClampedHP","standbyEvents","newRecoveryTimers","summonEffect","targetsHit","targetsHealed","damageAmount","aliveEnemies","targetIndex","healedUnits","updatedTeamAfterHeal","statBonus","buffedUnits","updatedTeamAfterBuff","abilityTargets","actions","emptyTeam","unitA","unitB","isPlayerA","isPlayerB","spdA","spdB","targetSide","targetMode","ABILITIES","isPlayerAction","allies","decision","alivePlayers","allPlayersKO","before","after","prev","next","atkDelta","defDelta","recovered","previousState","getPlanningTurnOrder","unitSpeeds","autoHealUnits","StatsSchema","z.object","z.number","ContentAvailabilitySchema","z.array","z.enum","ElementSchema","EquipmentStatBonusSchema","EquipmentSlotSchema","EquipmentTierSchema","EquipmentSchema","z.string","z.boolean","EquipmentLoadoutSchema","abilityIdRegex","AbilitySchema","z.union","z.literal","UnitRoleSchema","DjinnStateSchema","StatKeySchema","StatusEffectSchema","z.discriminatedUnion","UnitDefinitionSchema","UnitSchema","z.record","ctx","z.ZodIssueCode","DjinnTrackerSchema","NPCStateSchema","TowerRecordSchema","SaveV1Schema","TeamSchema","BattleResultSchema","BattleStatusSchema","QueuedActionSchema","BattlePhaseSchema","teamIds","enemyIds","known","CURRENT_SAVE_VERSION","migrateSaveData","data","validateSaveFile","wrapper","schema","currentVersion","migrate","file","missingFields","f","saveVersion","migrated","verifyChecksum","calculateChecksum","serialized","_key","sorted","k","hash","expectedChecksum","SAVE_SLOT_PREFIX","BACKUP_SUFFIX","getSaveSlotKey","slot","getBackupKey","createBackup","existing","wrapWithChecksum","version","checksum","unwrapAndValidate","expectedVersion","saveProgress","validationResult","backupResult","wrapped","loadProgress","parseError","errorMsg","loadProgressFromBackup","unwrapResult","schemaResult","mainError","backupKey","context","hasSaveSlot","deleteSaveSlot","getSaveSlotMetadata","avgLevel","saveGame","loadGame","hasSave","deleteSave","saveGameSlot","loadGameSlot","DEFAULT_TOWER_CONFIG","createTowerRun","difficulty","floors","options","sortedFloors","floorIds","floor","getCurrentFloor","run","currentId","getFloorById","recordBattleResult","outcome","summary","rewards","currentFloor","nextStats","updateStatsForBattle","nextHistory","entry","didWin","didRetreat","nextFloorIndex","hasClearedAllFloors","isFailed","completeRestFloor","clearPendingRewards","stats","floorNumber","collectDjinn","newCollectedDjinn","equipDjinn","slotIndex","newEquippedDjinn","oldDjinnId","newTrackers","createStoryState","chapter","setFlag","flag","advanceChapter","completedKey","flagKey","encounterIdToFlagKey","encounterId","match","processEncounterCompletion","isHouseUnlocked","story","houseId","houseNumRaw","houseNum","prevHouseId","processStoryFlagForDjinn","flagId","flagValue","updatedStory","STORY_FLAG_TO_DJINN","collectResult","processStoryFlagForUnit","currentLevel","STORY_FLAG_TO_UNIT","unitDef","UNIT_DEFINITIONS","recruitedUnit","XP_CURVE","calculateLevelFromXp","xp","low","high","mid","midXp","addXp","xpGain","newXp","oldLevel","newLevel","leveledUp","leveledDown","unlockedAbilities","abilitiesAtLevel","finalUnlockedAbilities","calculateBattleRewards","survivorCount","encounter","ENCOUNTERS","allSurvived","xpPerUnit","calculateStatGains","levelDiff","distributeRewards","levelUps","xpResult","statGains","processVictory","survivors","distribution","equipmentResolution","resolveEquipmentReward","resetDjinnTrackers","reward","EQUIPMENT","calculateStatsAtLevel","unitDefinitionToEnemy","baseXp","baseGold","statsAtLevel","finalStats","enemyAbilities","enemyToUnit","loadEncounter","createBattleFromEncounter","enemyId","enemyDef","ENEMIES","battleResult","getTile","map","position","withinX","withinY","row","canMoveTo","tile","npc","trigger","getTriggerAt","processMovement","currentMap","currentPos","direction","delta","nextPos","startDialogue","tree","getCurrentNode","node","evaluateCondition","condition","getAvailableChoices","choice","selectChoice","choiceId","currentNode","c","advanceDialogue","canEquipItem","canAffordItem","gold","itemId","buyItem","purchaseStarterKit","currentGold","kit","getStarterKit","equipmentIds","equipmentList","purchaseUnitEquipment"],"mappings":"2OAQO,MAAMA,EAAiB,EAKjBC,EAAiB,EAkBjBC,GAAc,CAEzB,eAAgB,EAEhB,QAAS,EAET,QAAS,IAET,SAAU,EAEV,YAAa,GACf,EAMaC,GAA6B,IAK7BC,EAAmB,CAE9B,qBAAsB,GAEtB,mBAAoB,GAEpB,4BAA6B,GAE7B,6BAA8B,IAE9B,gCAAiC,IAMjC,eAAgB,EAEhB,gBAAiB,CACnB,EAOO,SAASC,GAAiBC,EAAeL,EAAiC,CAC/E,GAAIK,EAAON,GAAkBM,EAAOL,EAClC,MAAM,IAAI,MAAM,8BAA8BD,CAAc,QAAQC,CAAc,SAASK,CAAI,EAAE,EAEnG,OAAO,MAAMA,CAAI,EAAE,KAAK,IAAI,CAC9B,CAQO,SAASC,GACdC,EACAC,EACAC,EACQ,CACR,MAAMC,EAAS,OAAOD,GAAW,SAAWA,EAASR,GAAYQ,CAAM,EACvE,OAAOF,EAAUC,EAAaN,GAA6BQ,CAC7D,CC/CO,SAASC,GAAWC,EAA8B,CACvD,GAAIA,EAAM,OAASb,GAAkBa,EAAM,OAASZ,EAClD,MAAM,IAAI,MAAM,0BAA0BD,CAAc,QAAQC,CAAc,eAAeY,EAAM,MAAM,EAAE,EAG7G,MAAO,CACL,cAAe,CAAA,EACf,cAAe,CAAA,EACf,MAAAA,EACA,eAAgB,CAAA,EAChB,YAAa,EACb,oBAAqB,CAAA,EACrB,YAAa,CAAA,CAAC,CAElB,CASO,SAASC,EAAWC,EAAYC,EAA8B,CAEnE,GAAIA,EAAQ,gBAAkB,OAAW,CAGvC,GADiB,IAAI,IAAIA,EAAQ,aAAa,EACjC,OAASA,EAAQ,cAAc,OAC1C,MAAM,IAAI,MAAM,2CAA2CA,EAAQ,cAAc,KAAK,IAAI,CAAC,EAAE,EAI/F,GAAIA,EAAQ,cAAc,OAAS,EACjC,MAAM,IAAI,MAAM,8CAA8CA,EAAQ,cAAc,MAAM,EAAE,CAEhG,CAEA,MAAO,CACL,GAAGD,EACH,GAAGC,EACH,cAAeA,EAAQ,cAAgB,CAAE,GAAGD,EAAK,cAAe,GAAGC,EAAQ,eAAkBD,EAAK,cAClG,oBAAqBC,EAAQ,oBAAsB,CAAE,GAAGD,EAAK,oBAAqB,GAAGC,EAAQ,qBAAwBD,EAAK,oBAC1H,YAAaC,EAAQ,YAAc,CAAE,GAAGD,EAAK,YAAa,GAAGC,EAAQ,WAAA,EAAgBD,EAAK,WAAA,CAE9F,CCxEO,MAAME,GAAsB,CACjC,EAAG,GACH,EAAG,IACH,EAAG,GACL,EAOO,SAASC,GAAsBC,EAAiD,CACrF,GAAIA,EAAc,SAAW,EAC3B,MAAO,CACL,IAAK,EACL,IAAK,EACL,YAAa,OACb,kBAAmB,CAAA,CAAC,EAIxB,MAAMC,MAAoB,IAE1B,UAAWC,KAAWF,EACpBC,EAAc,IAAIC,GAAUD,EAAc,IAAIC,CAAO,GAAK,GAAK,CAAC,EAGlE,MAAMC,EAAiBF,EAAc,KAC/BG,EAAW,KAAK,IAAI,GAAG,MAAM,KAAKH,EAAc,OAAA,CAAQ,CAAC,EACzDI,EAAiB,MAAM,KAAKJ,EAAc,QAAA,CAAS,EACtD,KAAK,CAAC,CAAA,CAAGK,CAAK,IAAMA,IAAUF,CAAQ,IAAI,CAAC,EAG9C,OAAIJ,EAAc,SAAW,EACpB,CACL,IAAK,EACL,IAAK,EACL,YAAa,QACb,kBAAmB,CAAA,CAAC,EAKpBA,EAAc,SAAW,GAAKG,IAAmB,EAC5C,CACL,IAAK,EACL,IAAK,EACL,YAAa,GAAGE,CAAc,WAC9B,kBAAmB,CAAA,CAAC,EAKpBL,EAAc,SAAW,GAAKG,IAAmB,EAC5C,CACL,IAAK,EACL,IAAK,EACL,YAAa,SACb,kBAAmB,CAAA,CAAC,EAKpBH,EAAc,SAAW,GAAKG,IAAmB,EAC5C,CACL,IAAK,GACL,IAAK,EACL,YAAa,GAAGE,CAAc,SAC9B,kBAAmB,CAAC,GAAGA,CAAc,WAAW,CAAA,EAKhDL,EAAc,SAAW,GAAKG,IAAmB,GAAKC,IAAa,EAC9D,CACL,IAAK,EACL,IAAK,EACL,YAAa,GAAGC,CAAc,UAC9B,kBAAmB,CAAC,cAAc,CAAA,EAK/B,CACL,IAAK,EACL,IAAK,EACL,IAAK,EACL,YAAa,SACb,kBAAmB,CAAC,mBAAmB,CAAA,CAE3C,CASO,SAASE,GAAeX,EAA+B,CAC5D,OAAOA,EAAK,cAAc,OAAOY,GACfZ,EAAK,cAAcY,CAAO,GAC1B,QAAU,KAC3B,CACH,CASO,SAASC,GAAsBC,EAA+B,CACnE,OAAOZ,GAAoBY,CAAU,CACvC,CAUO,SAASC,GAAiBf,EAAYY,EAA0B,CACrE,OAAKZ,EAAK,cAAc,SAASY,CAAO,EAIxBZ,EAAK,cAAcY,CAAO,GAC1B,QAAU,MAJjB,EAKX,CC3IA,MAAMI,GAA0C,CAC9C,MAAO,UACP,QAAS,QACT,KAAM,UACN,QAAS,OACT,QAAS,SACX,EAEO,SAASC,GACdC,EACAC,EACsB,CACtB,OAAID,IAAgBC,EACX,OAGLH,GAAcE,CAAW,IAAMC,EAC1B,UAGF,SACT,CAEO,SAASC,GAA6BC,EAAYrB,EAA4B,CACnF,MAAMsB,EAAcX,GAAeX,CAAI,EACjCuB,EAAyB,CAAA,EAE/B,UAAWX,KAAWU,EAAa,CACjC,MAAMH,EAAeK,GAAsBZ,CAAO,EAClD,GAAI,CAACO,EACH,SAGF,MAAMM,EAAgBR,GAAwBI,EAAK,QAASF,CAAY,EAClEO,EAAU,CAACC,EAAkBC,IAAkB,CACnDL,EAAOI,CAAG,GAAKJ,EAAOI,CAAG,GAAK,GAAKC,CACrC,EAEA,OAAQH,EAAA,CACN,IAAK,OACHC,EAAQ,MAAO,CAAC,EAChBA,EAAQ,MAAO,CAAC,EAChB,MACF,IAAK,UACHA,EAAQ,MAAO,EAAE,EACjBA,EAAQ,MAAO,EAAE,EACjB,MACF,IAAK,UACHA,EAAQ,MAAO,CAAC,EAChBA,EAAQ,MAAO,CAAC,EAChB,KAAA,CAEN,CAEA,OAAOH,CACT,CAEA,SAASC,GAAsBZ,EAAiC,CAC9D,OAAOiB,EAAMjB,CAAO,GAAG,SAAW,IACpC,CAKA,SAASkB,GAAmB9B,EAA+B,CACzD,OAAOA,EAAK,cAAc,OAAOY,GACfZ,EAAK,cAAcY,CAAO,GAC1B,QAAU,SAC3B,CACH,CAEO,SAASmB,GAAgCV,EAAYrB,EAAsB,CAChF,MAAMsB,EAAcX,GAAeX,CAAI,EACjCgC,EAAkBF,GAAmB9B,CAAI,EACzCiC,EAAoB,CAAA,EAG1B,UAAWrB,KAAWU,EAAa,CACjC,MAAMY,EAAQL,EAAMjB,CAAO,EAC3B,GAAI,CAACsB,EAAO,SAEZ,MAAMT,EAAgBR,GAAwBI,EAAK,QAASa,EAAM,OAAO,EACnEC,EAAeD,EAAM,iBAAiBb,EAAK,EAAE,EAInD,GAHI,CAACc,GAGDV,IAAkB,UAAW,SAEjC,IAAIW,EAA6B,CAAA,EAEjC,OAAQX,EAAA,CACN,IAAK,OAEHW,EAAmBD,EAAa,KAAK,MAAM,EAAG,CAAC,EAC/C,MACF,IAAK,UAEHC,EAAmBD,EAAa,QAAQ,MAAM,EAAG,CAAC,EAClD,KAAA,CAGJF,EAAQ,KAAK,GAAGG,CAAgB,CAClC,CAIA,UAAWxB,KAAWoB,EAAiB,CACrC,MAAME,EAAQL,EAAMjB,CAAO,EAC3B,GAAI,CAACsB,EAAO,SAEZ,MAAMT,EAAgBR,GAAwBI,EAAK,QAASa,EAAM,OAAO,EACnEC,EAAeD,EAAM,iBAAiBb,EAAK,EAAE,EAInD,GAHI,CAACc,GAGDV,IAAkB,UAAW,SAGjC,MAAMW,EAAmBD,EAAa,QAAQ,MAAM,EAAG,CAAC,EACxDF,EAAQ,KAAK,GAAGG,CAAgB,CAClC,CAEA,MAAO,CAAC,GAAG,IAAI,IAAIH,CAAO,CAAC,CAC7B,CAEO,SAASI,GAA4BhB,EAAYrB,EAAkB,CACxE,MAAMsC,EAAaP,GAAgCV,EAAMrB,CAAI,EACvDuC,EAAc,IAAI,IAAIlB,EAAK,UAAU,IAAKmB,GAAYA,EAAQ,EAAE,CAAC,EACjEC,EAAgBpB,EAAK,UAAU,OACnCmB,GAAW,CAACE,GAAgBF,EAAQ,EAAE,GAAKF,EAAW,SAASE,EAAQ,EAAE,CAAA,EAErEG,EAAetB,EAAK,mBAAmB,UACrC,CAACqB,GAAgBE,CAAE,GAAKN,EAAW,SAASM,CAAE,CAAA,EAGhDC,EAAiBP,EACpB,IAAKM,GAAOF,GAAgBE,CAAE,CAAC,EAC/B,OAAQJ,GAAuDA,IAAY,MAAS,EACpF,OAAQA,GAAY,CAACD,EAAY,IAAIC,EAAQ,EAAE,CAAC,EAE7CM,EAAkB,CAAC,GAAGL,EAAe,GAAGI,CAAc,EACtDE,EAAiB,MAAM,KAAK,IAAI,IAAI,CAAC,GAAGJ,EAAc,GAAGL,CAAU,CAAC,CAAC,EAE3E,MAAO,CACL,GAAGjB,EACH,UAAWyB,EACX,mBAAoBC,CAAA,CAExB,CAQO,SAASC,GACd3B,EACArB,EACAiD,EACwB,CACxB,MAAMC,EAA0BlD,EAAK,cAC/BmD,MAAW,IACXC,EAAmC,CAAA,EAEzC,UAAWxC,KAAWsC,EAAa,CACjC,MAAMhB,EAAQL,EAAMjB,CAAO,EAC3B,GAAI,CAACsB,EAAO,SAEZ,MAAMC,EAAeD,EAAM,iBAAiBb,EAAK,EAAE,EACnD,GAAI,CAACc,EAAc,SAEnB,MAAMV,EAAgBR,GAAwBI,EAAK,QAASa,EAAM,OAAO,EACnEmB,EACJ5B,IAAkB,OACdU,EAAa,KACbV,IAAkB,UAChBU,EAAa,QACbA,EAAa,QAErB,UAAWmB,KAAaD,EAClBF,EAAK,IAAIG,CAAS,IACtBH,EAAK,IAAIG,CAAS,EAClBF,EAAS,KAAK,CACZ,UAAAE,EACA,QAAA1C,EACA,cAAAa,CAAA,CACD,EAEL,CAEA,OAAO2B,CACT,CAEO,SAASG,GAAqClC,EAAYrB,EAAoC,CACnG,MAAMwD,EAAiBxD,EAAK,cAAc,OAAQY,GAChCZ,EAAK,cAAcY,CAAO,GAC1B,QAAU,KAC3B,EAED,GAAI4C,EAAe,SAAW,EAC5B,MAAO,CAAA,EAGT,MAAMC,EAAY,IAAI,IAAID,CAAc,EACxC,OAAOR,GAA+B3B,EAAMrB,CAAI,EAAE,OAAQ0D,GAASD,EAAU,IAAIC,EAAK,OAAO,CAAC,CAChG,CCrEO,SAASC,GACdC,EACAC,EACgC,CAChC,MAAMC,MAAY,IAElB,UAAWzC,KAAQuC,EACjBE,EAAM,IAAIzC,EAAK,GAAI,CAAE,KAAAA,EAAM,SAAU,GAAM,EAG7C,UAAWA,KAAQwC,EACjBC,EAAM,IAAIzC,EAAK,GAAI,CAAE,KAAAA,EAAM,SAAU,GAAO,EAG9C,OAAOyC,CACT,CAKO,SAASC,GAAsB/D,EAAoB,CACxD,OAAOA,EAAK,MAAM,OAAO,CAACgE,EAAO3C,IAAS2C,EAAQ3C,EAAK,iBAAkB,CAAC,CAC5E,CAOO,SAAS4C,GACdC,EACAC,EACAC,EAA+B,CAAA,EAClB,CACb,MAAMC,EAA0BH,EAAW,MAAM,IAAI7C,GACnDgB,GAA4BhB,EAAM6C,CAAU,CAAA,EAExCI,EAAcvE,EAAWmE,EAAY,CACzC,MAAOG,CAAA,CACR,EACKE,EAAUR,GAAsBO,CAAW,EAC3CE,EAAWb,GAAeW,EAAY,MAAOH,CAAO,EAE1D,MAAO,CACL,WAAYG,EACZ,QAAAH,EACA,SAAAK,EACA,YAAa,EACb,YAAa,EACb,MAAO,WACP,UAAWJ,EAAU,OAAS,EAAIA,EAAY,CAAA,EAC9C,kBAAmB,EACnB,OAAQ,UACR,IAAK,CAAA,EAEL,kBAAmB,EACnB,cAAe9E,GAAiB4E,EAAW,MAAM,MAAM,EACvD,YAAa,CAAA,EACb,cAAeK,EACf,QAAAA,EACA,eAAgB,EAChB,oBAAqB,CAAA,CAAC,CAE1B,CAOO,SAASE,EAAkBC,EAAoBzE,EAA4C,CAChG,MAAM0E,EAAW,CAAE,GAAGD,EAAO,GAAGzE,CAAA,EAGhC,OAAIA,EAAQ,YAAcA,EAAQ,WAChC0E,EAAS,SAAWhB,GAAegB,EAAS,WAAW,MAAOA,EAAS,OAAO,GAsBzEA,CACT,CAMO,SAASC,GAAeC,EAAyC,CACtE,OAAOA,EAAO,MAAM,aAAeA,EAAO,WAC5C,CCnMO,SAASC,GAAezD,EAAoB,CACjD,MAAM0D,GAAc1D,EAAK,MAAQ,GAAKA,EAAK,YAAY,GACvD,OAAOA,EAAK,UAAU,GAAK0D,CAC7B,CAKO,SAASC,EAAS3D,EAAqB,CAC5C,OAAOA,EAAK,WAAa,CAC3B,CAKO,SAAS4D,GACdC,EACAC,EAAgB,EAChBC,EAAoB,EACd,CACN,MAAMC,EAAQH,EAAW,UAAU,IAAMC,EAAQ,GAAKD,EAAW,YAAY,GAGvEI,EAAqBJ,EAAW,UACnC,OAAO1C,GAAW2C,IAAU3C,EAAQ,aAAe,EAAE,EACrD,IAAIA,GAAWA,EAAQ,EAAE,EAE5B,MAAO,CACL,GAAI0C,EAAW,GACf,KAAMA,EAAW,KACjB,QAASA,EAAW,QACpB,KAAMA,EAAW,KACjB,UAAWA,EAAW,UACtB,YAAaA,EAAW,YACxB,YAAaA,EAAW,YACxB,iBAAkBA,EAAW,kBAAoB,YACjD,iBAAkBA,EAAW,iBAC7B,MAAAC,EACA,GAAIC,EACJ,UAAWC,EACX,UAAW,CACT,OAAQ,KACR,MAAO,KACP,KAAM,KACN,MAAO,KACP,UAAW,IAAA,EAEb,cAAe,GACf,MAAO,CAAA,EACP,YAAa,CAAA,EACb,UAAWH,EAAW,UACtB,mBAAAI,EACA,cAAe,CAAA,EACf,aAAc,EACd,YAAa,CACX,YAAa,EACb,YAAa,CAAA,CACf,CAEJ,CAMO,SAASC,GAAWlE,EAAYpB,EAA8B,CACnE,MAAO,CACL,GAAGoB,EACH,GAAGpB,EACH,UAAWA,EAAQ,UAAY,CAAE,GAAGoB,EAAK,UAAW,GAAGpB,EAAQ,WAAcoB,EAAK,UAClF,YAAapB,EAAQ,YAAc,CAAE,GAAGoB,EAAK,YAAa,GAAGpB,EAAQ,WAAA,EAAgBoB,EAAK,WAAA,CAE9F,CCrFO,SAASmE,IAAuC,CACrD,MAAO,CACL,OAAQ,KACR,MAAO,KACP,KAAM,KACN,MAAO,KACP,UAAW,IAAA,CAEf,CAKO,SAASC,GAA0BC,EAA2C,CACnF,MAAMnE,EAA+C,CAAA,EAErD,UAAWoE,KAAQ,OAAO,OAAOD,CAAO,EACtC,GAAKC,EAEL,UAAWC,KAAQ,OAAO,KAAKD,EAAK,SAAS,EAAyB,CACpE,MAAM/D,EAAQ+D,EAAK,UAAUC,CAAI,EACNhE,GAAU,MAAQ,OAAOA,GAAU,WAC5DL,EAAOqE,CAAI,GAAKrE,EAAOqE,CAAI,GAAK,GAAKhE,EAEzC,CAGF,OAAOL,CACT,CC7DO,SAASsE,GAAsBxE,EAA4B,CAChE,MAAM0D,EAAa1D,EAAK,MAAQ,EAEhC,MAAO,CACL,GAAI0D,EAAa1D,EAAK,YAAY,GAClC,GAAI0D,EAAa1D,EAAK,YAAY,GAClC,IAAK0D,EAAa1D,EAAK,YAAY,IACnC,IAAK0D,EAAa1D,EAAK,YAAY,IACnC,IAAK0D,EAAa1D,EAAK,YAAY,IACnC,IAAK0D,EAAa1D,EAAK,YAAY,GAAA,CAEvC,CAYO,SAASyE,GAAyBzE,EAA4B,CACnE,MAAM0E,EAA4B,CAAA,EAElC,UAAWC,KAAU3E,EAAK,cACxB,GAAI2E,EAAO,OAAS,QAAUA,EAAO,OAAS,SAAU,CACtD,MAAMC,EAAUD,EAAO,KACjBE,EAAWF,EAAO,SAGxB,GAAIC,GAAWC,IAAa,OAAW,CAErC,MAAMC,EAAUJ,EAAUE,CAAO,GAAK,EACtCF,EAAUE,CAAO,EAAIE,EAAUD,CACjC,CACF,CAGF,OAAOH,CACT,CAWO,SAASK,EAAwB/E,EAAYrB,EAAmB,CACrE,MAAMqG,EAAOhF,EAAK,UACZ8D,EAAQU,GAAsBxE,CAAI,EAClCiF,EAAYb,GAA0BpE,EAAK,SAAS,EACpDa,EAAQd,GAA6BC,EAAMrB,CAAI,EAC/CgG,EAASF,GAAyBzE,CAAI,EAY5C,MATyB,CACvB,GAAI,KAAK,IAAI,EAAG,KAAK,MAAMgF,EAAK,IAAMlB,EAAM,IAAM,IAAMmB,EAAU,IAAM,IAAMN,EAAO,IAAM,EAAE,CAAC,EAC9F,GAAI,KAAK,IAAI,EAAG,KAAK,MAAMK,EAAK,IAAMlB,EAAM,IAAM,IAAMmB,EAAU,IAAM,IAAMN,EAAO,IAAM,EAAE,CAAC,EAC9F,IAAK,KAAK,IAAI,EAAG,KAAK,MAAMK,EAAK,KAAOlB,EAAM,KAAO,IAAMmB,EAAU,KAAO,IAAMpE,EAAM,KAAO,IAAM8D,EAAO,KAAO,EAAE,CAAC,EACtH,IAAK,KAAK,IAAI,EAAG,KAAK,MAAMK,EAAK,KAAOlB,EAAM,KAAO,IAAMmB,EAAU,KAAO,IAAMpE,EAAM,KAAO,IAAM8D,EAAO,KAAO,EAAE,CAAC,EACtH,IAAK,KAAK,IAAI,EAAG,KAAK,MAAMK,EAAK,KAAOlB,EAAM,KAAO,IAAMmB,EAAU,KAAO,IAAMpE,EAAM,KAAO,IAAM8D,EAAO,KAAO,EAAE,CAAC,EACtH,IAAK,KAAK,IAAI,EAAG,KAAK,MAAMK,EAAK,KAAOlB,EAAM,KAAO,IAAMmB,EAAU,KAAO,IAAMpE,EAAM,KAAO,IAAM8D,EAAO,KAAO,EAAE,CAAC,CAAA,CAI1H,CAUO,SAASO,EAAgBlF,EAAYrB,EAAoB,CAE9D,OADkBoG,EAAwB/E,EAAMrB,CAAI,EACnC,GACnB,CCnFA,MAAMwG,GAA6C,CACjD,gBAAiB,GACjB,aAAc,GACd,eAAgB,GAChB,kBAAmB,EACrB,EAMO,SAASC,GAAmBC,EAAwBC,EAAiC,CAC1F,MAAMhF,EAAM,GAAG+E,CAAa,IAAIC,CAAc,GAC9C,GAAIH,GAAkB7E,CAAG,EACvB,OAAOtC,EAAiB,6BAG1B,MAAMuH,EAAa,GAAGD,CAAc,IAAID,CAAa,GACrD,OAAIF,GAAkBI,CAAU,EACvBvH,EAAiB,gCAGnB,CACT,CAcO,SAASwH,GACdC,EACAC,EACAC,EACQ,CACR,IAAIC,EAAiBH,EAGrB,GAAIC,GAAkBA,IAAmB,UAAW,CAclD,MAAMG,EAAmB,EAbCF,EAAS,cAAc,OAC/CG,GAAUA,EAAO,OAAS,uBAAyBA,EAAO,UAAYJ,CAAA,EAG1B,IAAII,GAAUA,EAAO,QAAQ,EAE3B,OAAO,CAACC,EAAKC,IAAQD,EAAMC,EAAK,CAAC,EAQjFJ,GAAkBC,CACpB,CASA,MAAMI,EANyBN,EAAS,cAAc,OACpDG,GAAUA,EAAO,OAAS,iBAAA,EAG2B,IAAIA,GAAUA,EAAO,OAAO,EAE9B,OAAO,CAACC,EAAKG,IAAQH,EAAMG,EAAK,CAAC,EAEhFC,EAAmB,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGF,CAAoB,CAAC,EAGtE,OAAAL,GAAmB,EAAIO,EAEhBP,CACT,CAWO,SAASQ,GACdC,EACAV,EACAhH,EACAwC,EACQ,CACR,MAAMmF,EAAoBvB,EAAwBsB,EAAU1H,CAAI,EAC1D4H,EAAoBxB,EAAwBY,EAAUhH,CAAI,EAE1D8G,EAAatE,EAAQ,UAAY,EAAIA,EAAQ,UAAYmF,EAAkB,IAC3EE,EAAcF,EAAkB,IAGhCG,EAAuB,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGtF,EAAQ,sBAAwB,CAAC,CAAC,EACjFuF,EAAmBH,EAAkB,KAAO,EAAIE,GAEhDE,EAAYlB,EAAae,EAAeE,EAAmB1I,EAAiB,mBAG5E4H,EAAiBJ,GAAqBmB,EAAWxF,EAAQ,QAASwE,CAAQ,EAIhF,OAFe,KAAK,IAAI3H,EAAiB,eAAgB,KAAK,MAAM4H,CAAc,CAAC,CAGrF,CAWO,SAASgB,GACdP,EACAV,EACAhH,EACAwC,EACQ,CACR,MAAMmF,EAAoBvB,EAAwBsB,EAAU1H,CAAI,EAC1D4H,EAAoBxB,EAAwBY,EAAUhH,CAAI,EAE1DkI,EAAY1F,EAAQ,WAAa,EACjC2F,EAAaR,EAAkB,IAG/BG,EAAuB,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGtF,EAAQ,sBAAwB,CAAC,CAAC,EAEjF4F,EADmBR,EAAkB,KAAO,EAAIE,GACdzI,EAAiB,4BAGnDgJ,EAAkB7F,EAAQ,QAC5BiE,GAAmBjE,EAAQ,QAASwE,EAAS,OAAO,EACpD,EAEJ,IAAIgB,GAAaE,EAAYC,EAAaC,GAAgBC,EAG1D,MAAMC,EAAStB,EAAS,UAAU,OAAO,iBAAmB,EACxDxE,EAAQ,SAAW8F,EAAS,IAC9BN,EAAYA,GAAa,EAAIM,IAI/B,MAAMrB,EAAiBJ,GAAqBmB,EAAWxF,EAAQ,QAASwE,CAAQ,EAIhF,OAFe,KAAK,IAAI3H,EAAiB,eAAgB,KAAK,MAAM4H,CAAc,CAAC,CAGrF,CASO,SAASsB,GACdC,EACAxI,EACAwC,EACQ,CACR,MAAMiG,EAAWjG,EAAQ,WAAa,EAOtC,GAJIiG,EAAW,GAIXA,IAAa,EACf,MAAO,GAIT,MAAMN,EADkB/B,EAAwBoC,EAAQxI,CAAI,EACzB,IAE7B0I,EAAUD,EAAWN,EAG3B,OAFmB,KAAK,IAAI9I,EAAiB,gBAAiB,KAAK,MAAMqJ,CAAO,CAAC,CAGnF,CAKO,SAASC,GAAetH,EAAqB,CAClD,OAAOA,EAAK,cAAc,KAAK8F,GAAUA,EAAO,OAAS,cAAc,CACzE,CAKO,SAASyB,GAAiBvH,EAAqB,CACpD,OAAOA,EAAK,cAAc,KACxB8F,GAAUA,EAAO,OAAS,UAAYA,EAAO,iBAAmB,CAAA,CAEpE,CAOO,SAAS0B,GAAoBxH,EAAkB,CACpD,IAAIyH,EAAiB,GAErB,MAAMC,EAAuB1H,EAAK,cAC/B,IAAI8F,GAECA,EAAO,OAAS,UAAYA,EAAO,iBAAmB,GAAK,CAAC2B,GAC9DA,EAAiB,GACV,CAAE,GAAG3B,EAAQ,iBAAkBA,EAAO,iBAAmB,CAAA,GAE3DA,CACR,EACA,OAAOA,GAEC,EAAEA,EAAO,OAAS,UAAYA,EAAO,mBAAqB,EAClE,EAEH,MAAO,CACL,GAAG9F,EACH,cAAe0H,CAAA,CAEnB,CAUO,SAASC,GAAY3H,EAAY4H,EAAsB,CAC5D,MAAM5D,EAAQP,GAAezD,CAAI,EAC3B6H,EAAQ,KAAK,IAAI,EAAG,KAAK,IAAI7D,EAAOhE,EAAK,UAAY4H,CAAM,CAAC,EAElE,MAAO,CACL,GAAG5H,EACH,UAAW6H,EACX,YAAa,CACX,GAAG7H,EAAK,YACR,YAAaA,EAAK,YAAY,YAAc4H,CAAA,CAC9C,CAEJ,CAcO,SAASE,GACd9H,EACA4H,EACoE,CAEpE,GAAIA,GAAU,EACZ,MAAO,CAAE,YAAa5H,EAAM,aAAc,CAAA,EAI5C,GAAIsH,GAAetH,CAAI,EACrB,MAAO,CAAE,YAAaA,EAAM,aAAc,CAAA,EAI5C,GAAIuH,GAAiBvH,CAAI,EAEvB,MAAO,CAAE,YADWwH,GAAoBxH,CAAI,EACtB,aAAc,CAAA,EAItC,IAAI+H,EAAcJ,GAAY3H,EAAM4H,CAAM,EAG1CG,EAAc,CACZ,GAAGA,EACH,cAAeA,EAAY,cAAc,UAC7B,EAAEjC,EAAO,OAAS,UAAYA,EAAO,mBAAqB,EAAA,CACtE,EAIF,KAAM,CAAE,YAAakC,EAAW,QAAAC,CAAA,EAAYC,GAAgBH,CAAW,EAEvE,OAAOE,EACH,CAAE,YAAaD,EAAW,aAAcJ,EAAQ,YAAa,EAAA,EAC7D,CAAE,YAAaI,EAAW,aAAcJ,CAAA,CAC9C,CASO,SAASM,GAAgBlI,EAAqD,CAEnF,GAAIA,EAAK,UAAY,EAAG,CAKtB,GAH+BA,EAAK,cAAc,KAChD8F,GAAUA,EAAO,OAAS,cAAgBA,EAAO,gBAAkB,CAAA,EAEzC,CAC1B,MAAMqC,EAAuBnI,EAAK,cAAc,UACpC,EAAE8F,EAAO,OAAS,cAAgBA,EAAO,gBAAkB,EAAA,EAEvE,MAAO,CAAE,YAAa,CAAE,GAAG9F,EAAM,cAAemI,CAAA,EAAwB,QAAS,EAAA,CACnF,CACA,MAAO,CAAE,YAAanI,EAAM,QAAS,EAAA,CACvC,CAOA,MAAMoI,EAJoBpI,EAAK,cAAc,OAC3C8F,GAAUA,EAAO,OAAS,cAAgBA,EAAO,cAAgB,CAAA,EAGxB,CAAC,EAE5C,GAAI,CAACsC,EAAkB,CAKrB,GAH+BpI,EAAK,cAAc,KAChD8F,GAAUA,EAAO,OAAS,cAAgBA,EAAO,gBAAkB,CAAA,EAEzC,CAC1B,MAAMqC,EAAuBnI,EAAK,cAAc,UACpC,EAAE8F,EAAO,OAAS,cAAgBA,EAAO,gBAAkB,EAAA,EAEvE,MAAO,CAAE,YAAa,CAAE,GAAG9F,EAAM,cAAemI,CAAA,EAAwB,QAAS,EAAA,CACnF,CACA,MAAO,CAAE,YAAanI,EAAM,QAAS,EAAA,CACvC,CAGA,MAAMgE,EAAQP,GAAezD,CAAI,EAC3BqI,EAAW,KAAK,MAAMrE,EAAQoE,EAAiB,SAAS,EAI9D,IAAIE,EAAa,GACjB,MAAMZ,EAAuB1H,EAAK,cAC/B,IAAI8F,GAECA,EAAO,OAAS,cAAgBA,EAAO,cAAgB,GAAK,CAACwC,GAC/DA,EAAa,GACN,CAAE,GAAGxC,EAAQ,cAAeA,EAAO,cAAgB,CAAA,GAErDA,CACR,EACA,OAAOA,GAEC,EAAEA,EAAO,OAAS,cAAgBA,EAAO,gBAAkB,EACnE,EAQH,MAAO,CAAE,YANiB,CACxB,GAAG9F,EACH,UAAWqI,EACX,cAAeX,CAAA,EAGkB,QAAS,EAAA,CAC9C,CAaO,SAASa,GAAavI,EAAYwI,EAAiBC,EAAgC,GAAa,CAErG,GAAID,EAAU,EACZ,MAAM,IAAI,MAAM,kCAAkCA,CAAO,EAAE,EAI7D,GAAI7E,EAAS3D,CAAI,GAAK,CAACyI,EACrB,MAAM,IAAI,MAAM,qDAAqD,EAGvE,MAAMzE,EAAQP,GAAezD,CAAI,EAC3B6H,EAAQ,KAAK,IAAI7D,EAAO,KAAK,IAAI,EAAGhE,EAAK,UAAYwI,CAAO,CAAC,EAEnE,MAAO,CACL,GAAGxI,EACH,UAAW6H,CAAA,CAEf,CC3ZO,SAASa,GACdjK,EACAE,EACAgK,EACAtK,EAAqB,EACF,CAEnB,MAAMuK,EAAanK,EAAM,UAAY,CAACkF,EAASkF,CAAC,CAAC,EAG3CC,EAAgBF,EAAW,OAAOC,GACtCA,EAAE,UAAU,OAAO,kBAAoB,EAAA,EAGnCE,EAAeH,EAAW,OAAOC,GACrCA,EAAE,UAAU,OAAO,kBAAoB,EAAA,EAKnCG,EAASL,EAAI,MAAA,EACnB,QAASM,EAAI,EAAGA,EAAI5K,EAAY4K,IAC9BD,EAAO,KAAA,EAMT,MAAME,EAAiB,CAAC,GAAGJ,CAAa,EACrC,KAAK,CAACK,EAAGC,IAAMD,EAAE,GAAG,cAAcC,EAAE,EAAE,CAAC,EACvC,KAAK,CAACD,EAAGC,IAAM,CACd,MAAMC,EAAOnE,EAAgBiE,EAAGxK,CAAI,EAE9B2K,EADOpE,EAAgBkE,EAAGzK,CAAI,EACb0K,EAEvB,GAAIC,IAAY,EAAG,CAEjB,MAAMC,EAAY5K,EAAK,MAAM,QAAUkK,EAAE,KAAOM,EAAE,EAAE,EAC9CK,EAAY7K,EAAK,MAAM,QAAUkK,EAAE,KAAOO,EAAE,EAAE,EAEpD,OAAIG,IAAcC,EACTD,EAAY,GAAK,EAInBP,EAAO,OAAS,EACzB,CACA,OAAOM,CACT,CAAC,EAGGG,EAAgB,CAAC,GAAGV,CAAY,EACnC,KAAK,CAACI,EAAGC,IAAMD,EAAE,GAAG,cAAcC,EAAE,EAAE,CAAC,EACvC,KAAK,CAACD,EAAGC,IAAM,CACd,MAAMC,EAAOnE,EAAgBiE,EAAGxK,CAAI,EAE9B2K,EADOpE,EAAgBkE,EAAGzK,CAAI,EACb0K,EAEvB,GAAIC,IAAY,EAAG,CAEjB,MAAMC,EAAY5K,EAAK,MAAM,QAAUkK,EAAE,KAAOM,EAAE,EAAE,EAC9CK,EAAY7K,EAAK,MAAM,QAAUkK,EAAE,KAAOO,EAAE,EAAE,EAEpD,OAAIG,IAAcC,EACTD,EAAY,GAAK,EAInBP,EAAO,OAAS,EACzB,CACA,OAAOM,CACT,CAAC,EAIH,MADmB,CAAC,GAAGJ,EAAgB,GAAGO,CAAa,EACrC,IAAIZ,GAAKA,EAAE,EAAE,CACjC,CCtEO,SAASa,GACd1J,EACA2I,EACqF,CACrF,IAAIgB,EAAc,EACdC,EAAe,EACnB,MAAMC,EAAqB,CAAA,EACrB7F,EAAQhE,EAAK,UAAU,IAAMA,EAAK,MAAQ,GAAKA,EAAK,YAAY,GAEhE0H,EAAuB1H,EAAK,cAAc,IAAI8F,GAAU,CAC5D,GAAIA,EAAO,OAAS,SAAU,CAC5B,MAAM8B,EAAS,KAAK,MAAM5D,EAAQ,GAAI,EACtC,OAAA2F,GAAe/B,EACfiC,EAAS,KAAK,GAAG7J,EAAK,IAAI,UAAU4H,CAAM,iBAAiB,EACpD,CAAE,GAAG9B,EAAQ,SAAUA,EAAO,SAAW,CAAA,CAClD,SAAWA,EAAO,OAAS,OAAQ,CACjC,MAAM8B,EAAS,KAAK,MAAM5D,EAAQ,EAAI,EACtC,OAAA2F,GAAe/B,EACfiC,EAAS,KAAK,GAAG7J,EAAK,IAAI,UAAU4H,CAAM,eAAe,EAClD,CAAE,GAAG9B,EAAQ,SAAUA,EAAO,SAAW,CAAA,CAClD,SAAWA,EAAO,OAAS,eAAgB,CACzC,MAAM0C,EAAU1C,EAAO,YACvB,OAAA8D,GAAgBpB,EAChBqB,EAAS,KAAK,GAAG7J,EAAK,IAAI,aAAawI,CAAO,MAAM,EAC7C,CAAE,GAAG1C,EAAQ,SAAUA,EAAO,SAAW,CAAA,CAClD,KAAA,IAAWA,EAAO,OAAS,SAEzB,OAAI6C,EAAI,KAAA,EAAS,IACfkB,EAAS,KAAK,GAAG7J,EAAK,IAAI,0BAA0B,EAC7C,CAAE,GAAG8F,EAAQ,SAAU,CAAA,IAE9B+D,EAAS,KAAK,GAAG7J,EAAK,IAAI,4BAA4B,EAC/C,CAAE,GAAG8F,EAAQ,SAAUA,EAAO,SAAW,CAAA,GAEpD,GAAWA,EAAO,OAAS,OACzB,OAAA+D,EAAS,KAAK,GAAG7J,EAAK,IAAI,6BAA6B,EAChD,CAAE,GAAG8F,EAAQ,SAAUA,EAAO,SAAW,CAAA,EAClD,GAAWA,EAAO,OAAS,aAEzB,OAAOA,EAGT,MAAI,aAAcA,EACT,CAAE,GAAGA,EAAQ,SAAUA,EAAO,SAAW,CAAA,EAE3CA,CACT,CAAC,EAAE,OAAOA,GAEJ,aAAcA,EACTA,EAAO,SAAW,EAEpB,EACR,EAED,IAAIgE,EAAe9J,EAInB,GAHI2J,EAAc,IAChBG,EAAenC,GAAYmC,EAAcH,CAAW,GAElDC,EAAe,EAAG,CACpB,MAAM/B,EAAQ,KAAK,IAAIiC,EAAa,UAAYF,EAAc5F,CAAK,EACnE8F,EAAe,CAAE,GAAGA,EAAc,UAAWjC,CAAA,CAC/C,CAOA,MAAO,CACL,YANwB,CACxB,GAAGiC,EACH,cAAepC,CAAA,EAKf,OAAQiC,EACR,QAASC,EACT,SAAAC,CAAA,CAEJ,CAOO,SAASE,GACd/J,EACA2I,EACS,CAMT,MAAI,GALoB3I,EAAK,cAAc,OACzCgK,GAAKA,EAAE,OAAS,UAAA,EAGgB,CAAC,GAClBrB,EAAI,KAAA,EAAS,IAIhC,CAKO,SAASsB,GAASjK,EAAqB,CAC5C,OAAOA,EAAK,cAAc,KAAKgK,GAAKA,EAAE,OAAS,UAAYA,EAAE,OAAS,MAAM,CAC9E,CAKO,SAASE,GAAiBlK,EAAYmK,EAA6B,CACxE,MAAMC,EAAapK,EAAK,cAAc,OAAO,GAAK,EAAE,OAAS,UAAU,EAGvE,OAAIoK,EAAW,KAAK,GAAK,EAAE,GAAG,EACrB,GAIFA,EAAW,KAAK,GAAK,EAAE,OAAO,KAAKC,GAAKA,IAAMF,CAAU,CAAC,CAClE,CAQO,SAASG,GAAiB3F,EAAuD,CAOtF,MALI,IAAC,SAAU,OAAQ,SAAU,WAAY,MAAM,EAAE,SAASA,EAAO,IAAI,GAKrEA,EAAO,OAAS,SAKtB,CAMO,SAAS4F,GACdvK,EACAwK,EACM,CAEN,GAAIA,EAAU,OAAS,YAAcN,GAAiBlK,EAAMwK,EAAU,IAAI,EACxE,OAAOxK,EAIT,IAAI0H,EAAuB1H,EAAK,cAChC,OAAIwK,EAAU,OAAS,aAErB9C,EAAuB1H,EAAK,cAAc,OAAO,GAAK,EAAE,OAAS,UAAU,GAItE,CACL,GAAGA,EACH,cAAe,CAAC,GAAG0H,EAAsB8C,CAAS,CAAA,CAEtD,CClLO,SAASC,GACdtJ,EACAgG,EACA5E,EACAC,EACiB,CACjB,MAAMkI,EAAenI,EAAY,QAAUsG,EAAE,KAAO1B,EAAO,EAAE,EAE7D,OAAQhG,EAAQ,QAAA,CACd,IAAK,eACH,OAAOuJ,EACHlI,EAAW,OAAOqG,GAAK,CAAClF,EAASkF,CAAC,CAAC,EACnCtG,EAAY,OAAOsG,GAAK,CAAClF,EAASkF,CAAC,CAAC,EAE1C,IAAK,cACH,OAAO6B,EACHlI,EAAW,OAAOqG,GAAK,CAAClF,EAASkF,CAAC,CAAC,EACnCtG,EAAY,OAAOsG,GAAK,CAAClF,EAASkF,CAAC,CAAC,EAE1C,IAAK,cACH,OAAO6B,EACHnI,EAAY,OAAOsG,GAAK,CAAClF,EAASkF,CAAC,CAAC,EACpCrG,EAAW,OAAOqG,GAAK,CAAClF,EAASkF,CAAC,CAAC,EAEzC,IAAK,aACH,OAAO6B,EACHnI,EAAY,OAAOsG,GAAK,CAAClF,EAASkF,CAAC,CAAC,EACpCrG,EAAW,OAAOqG,GAAK,CAAClF,EAASkF,CAAC,CAAC,EAEzC,IAAK,OACH,MAAO,CAAC1B,CAAM,EAEhB,QACE,MAAO,CAAA,CAAC,CAEd,CAKO,SAASwD,GACdC,EACAzJ,EACiB,CACjB,OAAIA,EAAQ,OAAS,WAAa,CAACA,EAAQ,cAElCyJ,EAAQ,OAAO/B,GAAK,CAAClF,EAASkF,CAAC,CAAC,EAIlC+B,CACT,CAWO,SAASC,GACd1J,EACAgG,EACAtE,EACAC,EACiB,CACjB,GAAI,CAAC3B,EAEH,OAAO2B,EAAQ,OAAOkH,GAAK,CAACrG,EAASqG,CAAC,CAAC,EAGzC,OAAQ7I,EAAQ,QAAA,CACd,IAAK,eACL,IAAK,cACH,OAAO2B,EAAQ,OAAOkH,GAAK,CAACrG,EAASqG,CAAC,CAAC,EACzC,IAAK,cACL,IAAK,aACH,OAAOnH,EAAW,MAAM,UAAY,CAACc,EAASkF,CAAC,CAAC,EAClD,IAAK,OACH,MAAO,CAAC1B,CAAM,EAChB,QACE,MAAO,CAAA,CAAC,CAEd,CC3FO,MAAM2D,EAASvK,IAAgC,CAAE,GAAI,GAAM,MAAAA,CAAA,GAErDwK,EAAUC,IAAgC,CAAE,GAAI,GAAO,MAAAA,CAAA,GCC7D,MAAMC,EAAkB,CACrB,SAA+B,KAMvC,MAAM5H,EAA0B,CAE9B,KAAK,SAAWA,CAClB,CAMA,UAA+B,CAC7B,OAAO,KAAK,QACd,CAMA,QAAe,CACb,KAAK,SAAW,IAClB,CAKA,aAAuB,CACrB,OAAO,KAAK,WAAa,IAC3B,CACF,CCVA,MAAM6H,GAAyB,CAAC,SAAU,OAAQ,SAAU,WAAY,OAAQ,QAAQ,EAGlFC,GAAyBC,GAC5BF,GAA6C,SAASE,CAAI,EAkBtD,SAASC,GACdxI,EACAC,EACA6F,EAC6B,CAC7B,GAAI,CAAC9F,EAAW,OAASA,EAAW,MAAM,SAAW,EACnD,OAAOkI,EAAI,4CAA4C,EAGzD,GAAI,CAACjI,GAAWA,EAAQ,SAAW,EACjC,OAAOiI,EAAI,oCAAoC,EAGjD,MAAMO,EAAW,CAAC,GAAGzI,EAAW,MAAO,GAAGC,CAAO,EAC3CC,EAAY2F,GAAmB4C,EAAUzI,EAAY8F,EAAK,CAAC,EAEjE,OAAOmC,EAAGlI,GAAkBC,EAAYC,EAASC,CAAS,CAAC,CAC7D,CAOO,SAASwI,GACdlI,EACAmI,EACAvJ,EACAwJ,EACA9C,EAC8F,CAC9F,MAAM+C,EAAc,IAAIT,GACxBS,EAAY,MAAMrI,CAAK,EAGvB,MAAMsI,EAAatI,EAAM,SAAS,IAAImI,CAAO,EAC7C,GAAI,CAACG,GAAchI,EAASgI,EAAW,IAAI,EACzC,OAAAD,EAAY,SAAA,EACLX,EAAI,kBAAkBS,CAAO,EAAE,EAExC,MAAMI,EAAQD,EAAW,KAGzB,GAAI1B,GAAS2B,CAAK,EAAG,CACnB,MAAMC,EAAeD,EAAM,cAAc,KAAM5B,GAAkDA,EAAE,OAAS,QAAQ,EAC9G8B,EAAwBD,EAAe,CAAC,CAC5C,KAAM,iBACN,SAAUL,EACV,OAAQK,CAAA,CACT,EAAI,CAAA,EACL,OAAAH,EAAY,OAAA,EACLZ,EAAG,CACR,MAAAzH,EACA,OAAQ,CACN,QAAS,GAAGuI,EAAM,IAAI,6BACtB,UAAW,CAAA,EACX,aAAc,CAAC,GAAGvI,EAAM,WAAW,MAAO,GAAGA,EAAM,OAAO,CAAA,EAE5D,OAAAyI,CAAA,CACD,CACH,CAGA,GAAI/B,GAAqB6B,EAAOjD,CAAG,EAAG,CACpC,MAAMoD,EAAiBH,EAAM,cAAc,KAAM5B,GAAoDA,EAAE,OAAS,UAAU,EACpH8B,EAAwBC,EAAiB,CAAC,CAC9C,KAAM,iBACN,SAAUP,EACV,OAAQO,CAAA,CACT,EAAI,CAAA,EACL,OAAAL,EAAY,OAAA,EACLZ,EAAG,CACR,MAAAzH,EACA,OAAQ,CACN,QAAS,GAAGuI,EAAM,IAAI,gCACtB,UAAW,CAAA,EACX,aAAc,CAAC,GAAGvI,EAAM,WAAW,MAAO,GAAGA,EAAM,OAAO,CAAA,EAE5D,OAAAyI,CAAA,CACD,CACH,CAGA,MAAM3K,EAAUyK,EAAM,UAAU,KAAKzC,GAAKA,EAAE,KAAOlH,CAAS,EAC5D,GAAI,CAACd,EACH,OAAAuK,EAAY,SAAA,EACLX,EAAI,WAAW9I,CAAS,uBAAuBuJ,CAAO,EAAE,EAIjE,MAAMQ,EAAmBvB,GACvBtJ,EACAyK,EACAvI,EAAM,WAAW,MACjBA,EAAM,OAAA,EAGFuH,EADeD,GAAmBqB,EAAkB7K,CAAO,EACpC,OAAOkJ,GAAKoB,EAAU,SAASpB,EAAE,EAAE,CAAC,EAEjE,GAAIO,EAAQ,SAAW,EACrB,OAAAc,EAAY,SAAA,EACLX,EAAI,gCAAgC9I,CAAS,EAAE,EAIxD,MAAMgK,EAAerB,EAAQ,OAAOP,IACnBhH,EAAM,WAAW,MAAM,KAAKwF,GAAKA,EAAE,KAAOwB,EAAE,EAAE,GAC9ChH,EAAM,QAAQ,QAAUwF,EAAE,KAAOwB,EAAE,EAAE,IACnC,CAAC1G,EAAS0G,CAAC,CAC7B,EAED,GAAI4B,EAAa,SAAW,EAC1B,OAAAP,EAAY,SAAA,EACLX,EAAI,iCAAiC,EAI9C,MAAMmB,MAA0B,IAChCD,EAAa,QAAQE,GAAU,CAC7BD,EAAoB,IAAIC,EAAO,GAAIA,EAAO,aAAa,CACzD,CAAC,EAID,MAAMb,EAAW,CAAC,GAAGjI,EAAM,WAAW,MAAO,GAAGA,EAAM,OAAO,EACvD+I,EAAgBC,GAAeT,EAAOzK,EAAS8K,EAAcX,EAAUjI,EAAM,WAAYA,EAAM,QAASsF,CAAG,EACjH,GAAI,CAACyD,EAAc,GACjB,OAAAV,EAAY,SAAA,EACLX,EAAIqB,EAAc,KAAK,EAEhC,MAAME,EAASF,EAAc,MAGvBG,EAAqBlJ,EAAM,WAAW,MAAM,IAAIwF,GACpCyD,EAAO,aAAa,QAAWE,EAAG,KAAO3D,EAAE,EAAE,GAC3CA,CACnB,EACK4D,EAAiBpJ,EAAM,QAAQ,IAAIwF,GACvByD,EAAO,aAAa,QAAWE,EAAG,KAAO3D,EAAE,EAAE,GAC3CA,CACnB,EAEK5F,EAAoB,CACxB,GAAGI,EAAM,WACT,MAAOkJ,CAAA,EAGHG,EAAetJ,EAAkBC,EAAO,CAC5C,WAAYJ,EACZ,QAASwJ,EACT,IAAK,CAAC,GAAGpJ,EAAM,IAAKiJ,EAAO,OAAO,CAAA,CACnC,EAGKR,EAAwB,CAAC,CAC7B,KAAM,UACN,SAAUN,EACV,UAAAvJ,EACA,QAASwJ,CAAA,CACV,EAGD,OAAIa,EAAO,SAAW,QACpBb,EAAU,QAAQkB,GAAY,CAE5B,GADe/B,EAAQ,KAAKP,GAAKA,EAAE,KAAOsC,CAAQ,EACtC,CACVb,EAAO,KAAK,CACV,KAAM,MACN,SAAAa,EACA,OAAQL,EAAO,QAAU,EACzB,QAASnL,EAAQ,OAAA,CAClB,EAGD,MAAMyL,EAAgBN,EAAO,aAAa,KAAKzD,GAAKA,EAAE,KAAO8D,CAAQ,EACjEC,GAAiBA,EAAc,WAAa,GAC9Cd,EAAO,KAAK,CAAE,KAAM,KAAM,OAAQa,EAAU,CAEhD,CACF,CAAC,EAGCL,EAAO,UAAY,QACrBb,EAAU,QAAQkB,GAAY,CAC5Bb,EAAO,KAAK,CACV,KAAM,OACN,SAAAa,EACA,OAAQL,EAAO,SAAW,CAAA,CAC3B,CACH,CAAC,EAICnL,EAAQ,cACVsK,EAAU,QAAQkB,GAAY,CAC5B,MAAME,EAAiBX,EAAoB,IAAIS,CAAQ,GAAK,CAAA,EACtDG,EAAYR,EAAO,aAAa,KAAKzD,GAAKA,EAAE,KAAO8D,CAAQ,EACjE,GAAIG,EAAW,CACb,MAAMC,EAAgBD,EAAU,cAG1BE,EAAc,IAAI,IAAIH,EAAe,IAAII,GAAKA,EAAE,IAAI,CAAC,EACvCF,EAAc,OAAOE,GAAK,CAACD,EAAY,IAAIC,EAAE,IAAI,CAAC,EAG1D,QAAQtI,GAAU,CAC5BmH,EAAO,KAAK,CACV,KAAM,iBACN,SAAAa,EACA,OAAAhI,CAAA,CACD,CACH,CAAC,CACH,CACF,CAAC,EAGH+G,EAAY,OAAA,EACLZ,EAAG,CAAE,MAAO4B,EAAc,OAAAJ,EAAQ,OAAAR,EAAQ,CACnD,CAMA,SAASoB,GACP/L,EACAyJ,EACQ,CACR,OAAOA,EAAQ,IAAIuB,GAAU,CAC3B,IAAIgB,EAAiBhB,EAGrB,GAAIhL,EAAQ,cAAe,CACzB,MAAMiM,EAAiF,CACrF,KAAM,SACN,iBAAkBjM,EAAQ,cAC1B,SAAUA,EAAQ,UAAY,CAAA,EAGhCgM,EAAiB,CACf,GAAGA,EACH,cAAe,CAAC,GAAGA,EAAe,cAAeC,CAAY,CAAA,CAEjE,CAGA,GAAIjM,EAAQ,yBAA2B,OAAW,CAChD,MAAMkM,EAAmG,CACvG,KAAM,kBACN,QAASlM,EAAQ,uBACjB,SAAUA,EAAQ,UAAY,CAAA,EAGhCgM,EAAiB,CACf,GAAGA,EACH,cAAe,CAAC,GAAGA,EAAe,cAAeE,CAAqB,CAAA,CAE1E,CAGA,GAAIlM,EAAQ,oBAAqB,CAC/B,MAAMmM,EAA2G,CAC/G,KAAM,sBACN,QAASnM,EAAQ,oBAAoB,QACrC,SAAUA,EAAQ,oBAAoB,SACtC,SAAUA,EAAQ,UAAY,CAAA,EAGhCgM,EAAiB,CACf,GAAGA,EACH,cAAe,CAAC,GAAGA,EAAe,cAAeG,CAAyB,CAAA,CAE9E,CAGA,GAAInM,EAAQ,cAAe,CACzB,MAAMoM,EAAqF,CACzF,KAAM,WACN,IAAKpM,EAAQ,cAAc,IAC3B,MAAOA,EAAQ,cAAc,MAC7B,SAAUA,EAAQ,cAAc,QAAA,EAGlCgM,EAAiB,CACf,GAAGA,EACH,cAAe,CAAC,GAAGA,EAAe,cAAeI,CAAc,CAAA,CAEnE,CAGA,GAAIpM,EAAQ,oBAAqB,CAC/B,MAAMqM,EAAarM,EAAQ,oBAC3B,IAAIsM,EAAmBN,EAAe,cAEtC,GAAIK,EAAW,OAAS,MAEtBC,EAAmB,CAAA,UACVD,EAAW,OAAS,WAE7BC,EAAmBA,EAAiB,OAAOR,GAAK,CAAC3C,GAAiB2C,CAAC,CAAC,UAC3DO,EAAW,OAAS,SAAU,CAEvC,MAAME,EAAgB,IAAI,IAAyBF,EAAW,QAAQ,EACtEC,EAAmBA,EAAiB,OAAO9I,GACpCwG,GAAsBxG,EAAO,IAAI,EAI/B,CAAC+I,EAAc,IAAI/I,EAAO,IAAI,EAH5B,EAIV,CACH,CAEAwI,EAAiB,CACf,GAAGA,EACH,cAAeM,CAAA,CAEnB,CAEA,OAAON,CACT,CAAC,CACH,CAMO,SAASd,GACdlF,EACAhG,EACAyJ,EACAU,EACA3M,EACAmE,EACA6F,EAC8B,CAC9B,MAAM8C,EAAYb,EAAQ,IAAIP,GAAKA,EAAE,EAAE,EACvC,IAAIsD,EAAU,GAAGxG,EAAO,IAAI,SAAShG,EAAQ,IAAI,IACjD,MAAMyM,EAAuB,CAAA,EAG7B,OAAQzM,EAAQ,KAAA,CACd,IAAK,WACL,IAAK,WAAY,CACf,IAAIwI,EAAc,EAClB,MAAMkE,EAAW1M,EAAQ,UAAY,EAErC,UAAWgL,KAAUvB,EAAS,CAE5B,IAAIkD,EAAgBF,EAAa,KAAK/E,GAAKA,EAAE,KAAOsD,EAAO,EAAE,GACxCb,EAAS,KAAKzC,GAAKA,EAAE,KAAOsD,EAAO,EAAE,EAC1D,GAAI,CAAC2B,GAAiBnK,EAASmK,CAAa,EAC1C,SAGF,IAAIC,EAAe,EAGnB,QAASC,EAAM,EAAGA,EAAMH,GAClB,CAAAlK,EAASmK,CAAa,EADME,IAAO,CAGvC,MAAMpG,EAASzG,EAAQ,OAAS,WAC5BiF,GAAwBe,EAAQ2G,EAAenP,EAAMwC,CAAO,EAC5DyF,GAAwBO,EAAQ2G,EAAenP,EAAMwC,CAAO,EAG1D,CAAE,YAAA4G,EAAa,aAAAkG,CAAA,EAAiBnG,GAAuBgG,EAAelG,CAAM,EAClFkG,EAAgB/F,EAChBgG,GAAgBE,EAGhB,MAAMC,EAAgBN,EAAa,aAAe/E,EAAE,KAAOiF,EAAe,EAAE,EACxEI,GAAiB,EACnBN,EAAaM,CAAa,EAAIJ,EAE9BF,EAAa,KAAKE,CAAa,CAEnC,CAKA,GAHAnE,GAAeoE,EAGX5M,EAAQ,aAAc,CACxB,MAAMgJ,EAAahJ,EAAQ,aAAa,KAClCgN,EAAiBhN,EAAQ,aAAa,SACtCiN,EAAejN,EAAQ,aAAa,QAAU,EAIpD,GADawH,EAAI,KAAA,EACNyF,EAAc,CAEvB,MAAMX,EAAmBK,EAAc,cAAc,OACnDb,GAAKA,EAAE,OAAS9C,CAAA,EAElB2D,EAAgB,CACd,GAAGA,EACH,cAAeL,CAAA,EAIjB,IAAIjD,EACAL,IAAe,SACjBK,EAAY,CACV,KAAM,SACN,cAAe,EACf,SAAU2D,CAAA,EAEHhE,IAAe,OACxBK,EAAY,CACV,KAAM,OACN,cAAe,GACf,SAAU2D,CAAA,EAEHhE,IAAe,SACxBK,EAAY,CACV,KAAM,SACN,SAAU2D,CAAA,EAEHhE,IAAe,OACxBK,EAAY,CACV,KAAM,OACN,SAAU2D,CAAA,EAGZ3D,EAAY,CACV,KAAM,WACN,SAAU2D,CAAA,EAKdL,EAAgBvD,GAAkBuD,EAAetD,CAAS,EAE1D,MAAM0D,EAAgBN,EAAa,aAAe/E,EAAE,KAAOiF,EAAe,EAAE,EACxEI,GAAiB,EACnBN,EAAaM,CAAa,EAAIJ,EAE9BF,EAAa,KAAKE,CAAa,CAEnC,CACF,CAGA,GAAI3M,EAAQ,aAAc,CACxB,MAAMkN,EAAgE,CAAA,EAChEC,EAAmD,CAAC,KAAM,KAAM,MAAO,MAAO,MAAO,KAAK,EAEhG,SAAW,CAAC/J,EAAMM,CAAQ,IAAK,OAAO,QAAQ1D,EAAQ,YAAY,EAC5D,OAAO0D,GAAa,UAAYyJ,EAAW,SAAS/J,CAAqC,GAC3F8J,EAAW,KAAK,CACd,KAAM,SACN,KAAA9J,EACA,SAAU,CAAC,KAAK,IAAIM,CAAQ,EAC5B,SAAU1D,EAAQ,UAAY,CAAA,CAC/B,EAKL,GAAIkN,EAAW,OAAS,EAAG,CACzB,UAAWE,KAAUF,EACnBP,EAAgBvD,GAAkBuD,EAAeS,CAAM,EAGzD,MAAML,EAAgBN,EAAa,aAAe/E,EAAE,KAAOiF,EAAe,EAAE,EACxEI,GAAiB,EACnBN,EAAaM,CAAa,EAAIJ,EAE9BF,EAAa,KAAKE,CAAa,CAEnC,CACF,CACF,CAGA,GAAI3M,EAAQ,qBAAuBA,EAAQ,UAAY,gBAAkByJ,EAAQ,SAAW,EAAG,CAC7F,MAAM4D,EAAkB5D,EAAQ,CAAC,GAAG,GAC9B6D,EAAgBtN,EAAQ,oBAGxBuN,EAAmB5L,EAAQ,UAC/B6L,EAAM,KAAOH,GAAmB,CAAC7K,EAASgL,CAAK,CAAA,EAGjD,UAAWC,KAAmBF,EAAkB,CAE9C,IAAIG,EAAmBjB,EAAa,KAAK/E,GAAKA,EAAE,KAAO+F,EAAgB,EAAE,GAChDtD,EAAS,KAAKzC,GAAKA,EAAE,KAAO+F,EAAgB,EAAE,EAEvE,GAAI,CAACC,GAAoBlL,EAASkL,CAAgB,EAChD,SAIF,MAAMpJ,EAAatE,EAAQ,OAAS,WAChCiF,GAAwBe,EAAQ0H,EAAkBlQ,EAAMwC,CAAO,EAC/DyF,GAAwBO,EAAQ0H,EAAkBlQ,EAAMwC,CAAO,EAE7D2N,EAAe,KAAK,MAAMrJ,EAAagJ,CAAa,EAGpD,CAAE,YAAA1G,EAAa,aAAAkG,CAAA,EAAiBnG,GAAuB+G,EAAkBC,CAAY,EAC3FD,EAAmB9G,EACnB4B,GAAesE,EAGf,MAAMC,EAAgBN,EAAa,aAAe/E,EAAE,KAAOgG,EAAiB,EAAE,EAC1EX,GAAiB,EACnBN,EAAaM,CAAa,EAAIW,EAE9BjB,EAAa,KAAKiB,CAAgB,CAEtC,CACF,CAGA,MAAME,EAAyB7B,GAAmB/L,EAASyM,CAAY,EACvEA,EAAa,OAAO,EAAGA,EAAa,OAAQ,GAAGmB,CAAsB,EAErEpB,GAAW,UAAUhE,CAAW,WAEhC,MAAMqF,EAAa1D,EAAS,IAAIzC,GACd+E,EAAa,QAAWpB,EAAG,KAAO3D,EAAE,EAAE,GACpCA,CACnB,EAED,OAAOiC,EAAG,CACR,OAAQnB,EACR,QAAAgE,EACA,UAAAlC,EACA,aAAcuD,EACd,IAAKrF,EAAc,CAAA,CACpB,CACH,CAEA,IAAK,UAAW,CACd,IAAIC,EAAe,EAEnB,UAAWuC,KAAUvB,EAAS,CAC5B,IAAIkD,EAAgB3B,EAGpB,IAAKhL,EAAQ,eAAiBA,EAAQ,SAAWwC,EAASwI,CAAM,EAAG,CACjE,MAAMnI,EAAQmI,EAAO,UAAU,IAAMA,EAAO,MAAQ,GAAKA,EAAO,YAAY,GACtE8C,EAAkB9N,EAAQ,iBAAmBnD,EAAiB,qBACpE8P,EAAgB,CACd,GAAG3B,EACH,UAAW,KAAK,MAAMnI,EAAQiL,CAAe,CAAA,EAE/CrF,GAAgBkE,EAAc,SAChC,SAAW,CAACnK,EAASwI,CAAM,EAAG,CAE5B,MAAM+C,EAAahI,GAAoBC,EAAQxI,EAAMwC,CAAO,EAC5D2M,EAAgBvF,GAAa4D,EAAQ+C,EAAY/N,EAAQ,eAAiBA,EAAQ,QAAU,EAAK,EACjGyI,GAAgBkE,EAAc,UAAY3B,EAAO,SACnD,CAGA,GAAIhL,EAAQ,cAAgB,CAACwC,EAASmK,CAAa,EAAG,CACpD,MAAMqB,EAA2F,CAC/F,KAAM,eACN,YAAahO,EAAQ,aAAa,OAClC,SAAUA,EAAQ,aAAa,QAAA,EAI3BsM,EAAmBK,EAAc,cAAc,OAAOb,GAAKA,EAAE,OAAS,cAAc,EAE1Fa,EAAgB,CACd,GAAGA,EACH,cAAe,CAAC,GAAGL,EAAkB0B,CAAS,CAAA,CAElD,CAEAvB,EAAa,KAAKE,CAAa,CACjC,CAGA,MAAMiB,EAAyB7B,GAAmB/L,EAASyM,CAAY,EACvEA,EAAa,OAAO,EAAGA,EAAa,OAAQ,GAAGmB,CAAsB,EAErEpB,GAAW,aAAa/D,CAAY,OAEpC,MAAMoF,EAAa1D,EAAS,IAAIzC,GACd+E,EAAa,QAAWpB,EAAG,KAAO3D,EAAE,EAAE,GACpCA,CACnB,EAED,OAAOiC,EAAG,CACR,QAASlB,EACT,QAAA+D,EACA,UAAAlC,EACA,aAAcuD,EACd,IAAK,EAAA,CACN,CACH,CAEA,IAAK,OACL,IAAK,SAAU,CACb,UAAW7C,KAAUvB,EACnB,GAAIzJ,EAAQ,WAAY,CACtB,IAAIgM,EAAiBhB,EAErB,MAAMmC,EAAmD,CAAC,KAAM,KAAM,MAAO,MAAO,MAAO,KAAK,EAChG,SAAW,CAAC/J,EAAMM,CAAQ,IAAK,OAAO,QAAQ1D,EAAQ,UAAU,EAC9D,GAAI,OAAO0D,GAAa,UAAYyJ,EAAW,SAAS/J,CAAqC,EAAG,CAC9F,MAAMiG,EAAiD,CACrD,KAAMrJ,EAAQ,OAAS,OAAS,OAAS,SACzC,KAAAoD,EACA,SAAAM,EACA,SAAU1D,EAAQ,UAAY,CAAA,EAIhCgM,EAAiB5C,GAAkB4C,EAAgB3C,CAAS,CAC9D,CAGFoD,EAAa,KAAKT,CAAc,CAClC,MACES,EAAa,KAAKzB,CAAM,EAK5B,MAAM4C,EAAyB7B,GAAmB/L,EAASyM,CAAY,EACvEA,EAAa,OAAO,EAAGA,EAAa,OAAQ,GAAGmB,CAAsB,EAErEpB,GAAW,YAAYxM,EAAQ,IAAI,IAEnC,MAAM6N,EAAa1D,EAAS,IAAIzC,GACd+E,EAAa,QAAWpB,EAAG,KAAO3D,EAAE,EAAE,GACpCA,CACnB,EAED,OAAOiC,EAAG,CACR,QAAA6C,EACA,UAAAlC,EACA,aAAcuD,EACd,IAAK,EAAA,CACN,CACH,CAEA,IAAK,SAGH,OAAOlE,EAAG,CACR,QAAS,GAAG3D,EAAO,IAAI,YAAYhG,EAAQ,IAAI,IAC/C,UAAAsK,EACA,aAAc,CAAC,GAAGH,CAAQ,EAC1B,IAAK,EAAA,CACN,EAGH,QAAS,CAEP,MAAM8D,EAAqBjO,EAAQ,KACnC,OAAO4J,EAAI,2BAA2B,OAAOqE,CAAW,CAAC,EAAE,CAC7D,CAAA,CAEJ,CAOO,SAASC,GACdhM,EACAsF,EAC6B,CAC7B,MAAM+C,EAAc,IAAIT,GACxBS,EAAY,MAAMrI,CAAK,EACvB,IAAIiM,EAAejM,EAEnB,MAAMkM,EAAiBD,EAAa,UAAUA,EAAa,iBAAiB,EAC5E,GAAI,CAACC,EAAgB,CAEnB,IAAIC,EAAYF,EAAa,kBAAoB,EAC7CE,GAAaF,EAAa,UAAU,SACtCE,EAAY,GAEd,MAAMC,EAAUrM,EAAkBkM,EAAc,CAAE,kBAAmBE,EAAW,EAChF,OAAA9D,EAAY,OAAA,EACLZ,EAAG2E,CAAO,CACnB,CAEA,MAAMC,EAAoBJ,EAAa,SAAS,IAAIC,CAAc,EAC5DI,EAAeD,GAAmB,KAExC,GAAIC,EAAc,CAChB,MAAMC,EAAelG,GAAwBiG,EAAchH,CAAG,EAK9D,GAFiB+G,EAAmB,SAEtB,CACZ,MAAMnD,EAAqB+C,EAAa,WAAW,MAAM,IAAIzG,GAC3DA,EAAE,KAAO0G,EAAiBK,EAAa,YAAc/G,CAAA,EAEvDyG,EAAelM,EAAkBkM,EAAc,CAC7C,WAAY,CAAE,GAAGA,EAAa,WAAY,MAAO/C,CAAA,EACjD,IAAKqD,EAAa,SAAS,OAAS,EAChC,CAAC,GAAGN,EAAa,IAAK,GAAGM,EAAa,QAAQ,EAC9CN,EAAa,GAAA,CAClB,CACH,KAAO,CACL,MAAM7C,EAAiB6C,EAAa,QAAQ,IAAIzG,GAC9CA,EAAE,KAAO0G,EAAiBK,EAAa,YAAc/G,CAAA,EAEvDyG,EAAelM,EAAkBkM,EAAc,CAC7C,QAAS7C,EACT,IAAKmD,EAAa,SAAS,OAAS,EAChC,CAAC,GAAGN,EAAa,IAAK,GAAGM,EAAa,QAAQ,EAC9CN,EAAa,GAAA,CAClB,CACH,CACF,CAGA,IAAIE,EAAYF,EAAa,kBAAoB,EAGjD,GAAIE,GAAaF,EAAa,UAAU,OAAQ,CAC9CE,EAAY,EACZ,MAAMK,EAAUP,EAAa,YAAc,EACrCQ,EAAepH,GACnB,CAAC,GAAG4G,EAAa,WAAW,MAAO,GAAGA,EAAa,OAAO,EAC1DA,EAAa,WACb3G,EACAkH,CAAA,EAGIJ,EAAUrM,EAAkBkM,EAAc,CAC9C,YAAaO,EACb,UAAWC,EACX,kBAAmB,CAAA,CACpB,EACD,OAAApE,EAAY,OAAA,EACLZ,EAAG2E,CAAO,CACnB,CAEA,MAAMA,EAAUrM,EAAkBkM,EAAc,CAC9C,kBAAmBE,CAAA,CACpB,EACD,OAAA9D,EAAY,OAAA,EACLZ,EAAG2E,CAAO,CACnB,CAKO,SAASM,GACd1M,EAC2C,CAC3C,MAAM2M,EAAc3M,EAAM,WAAW,MAAM,MAAMwF,GAAKlF,EAASkF,CAAC,CAAC,EAC3DoH,EAAe5M,EAAM,QAAQ,MAAMwF,GAAKlF,EAASkF,CAAC,CAAC,EAGzD,OAAIoH,GAAgBD,EACX,gBAGLC,EAAqB,iBACrBD,EAAoB,gBAEjB,IACT,CAMO,SAASE,GACd7M,EACAsF,EAC+D,CAC/D,MAAM4G,EAAiBlM,EAAM,UAAUA,EAAM,iBAAiB,EAC9D,GAAI,CAACkM,EACH,MAAO,CAAE,aAAclM,EAAO,OAAQ,CAAA,CAAC,EAGzC,MAAMiI,EAAW,CAAC,GAAGjI,EAAM,WAAW,MAAO,GAAGA,EAAM,OAAO,EACvDsM,EAAerE,EAAS,KAAKzC,GAAKA,EAAE,KAAO0G,CAAc,EAE/D,GAAI,CAACI,EACH,MAAO,CAAE,aAActM,EAAO,OAAQ,CAAA,CAAC,EAIzC,MAAMuM,EAAelG,GAAwBiG,EAAchH,CAAG,EAGxDwH,EAAkB7E,EAAS,IAAIzC,GACnCA,EAAE,KAAO0G,EAAiBK,EAAa,YAAc/G,CAAA,EAGjD0D,EAAqB4D,EAAgB,OAAOtH,GAChDxF,EAAM,WAAW,MAAM,KAAK+M,GAAMA,EAAG,KAAOvH,EAAE,EAAE,CAAA,EAE5C4D,EAAiB0D,EAAgB,OAAOtH,GAC5CxF,EAAM,QAAQ,QAAU2G,EAAE,KAAOnB,EAAE,EAAE,CAAA,EAGjCwH,EAA6B,CACjC,GAAGhN,EACH,WAAY,CACV,GAAGA,EAAM,WACT,MAAOkJ,CAAA,EAET,QAASE,CAAA,EAIL6D,EAA2B,CAAA,EAE7BV,EAAa,OAAS,GACxBU,EAAU,KAAK,CACb,KAAM,MACN,SAAUf,EACV,OAAQK,EAAa,MAAA,CACtB,EAIH,MAAMW,EAAiBtD,GACrB,GAAGA,EAAE,IAAI,IAAI,aAAcA,EAAIA,EAAE,SAAW,kBAAmBA,EAAIA,EAAE,cAAgB,WAAW,GAC5FuD,EAAe,IAAI,IAAIb,EAAa,cAAc,IAAIY,CAAa,CAAC,EACpEE,EAAe,IAAI,IAAIb,EAAa,YAAY,cAAc,IAAIW,CAAa,CAAC,EAEtF,OAAAZ,EAAa,cAAc,QAAQhL,GAAU,CAC3C,MAAM+L,EAAYH,EAAc5L,CAAM,EAClC6L,EAAa,IAAIE,CAAS,GAAK,CAACD,EAAa,IAAIC,CAAS,GAC5DJ,EAAU,KAAK,CACb,KAAM,iBACN,SAAUf,EACV,OAAA5K,CAAA,CACD,CAEL,CAAC,EAEM,CAAE,aAAc0L,EAAe,OAAQC,CAAA,CAChD,CC10BA,SAASK,GACPxP,EACAgG,EACA9D,EACQ,CACR,IAAIuN,EAAQzP,EAAQ,SAAS,UAAY,EAGzC,MAAM0B,EAAaQ,EAAM,WACnBwN,EAAkB,CACtB,cAAe,CAAA,EACf,cAAe,CAAA,EACf,MAAOxN,EAAM,QACb,eAAgB,CAAA,EAChB,YAAaA,EAAM,aAAe,EAClC,oBAAqB,CAAA,EACrB,YAAa,CAAA,CAAC,EAEVyN,EAAmB,CAAE,GAAGD,CAA2B,EACnDE,EAAchM,EAAwBoC,EAAQ2J,CAAU,EASxDE,EANmBvG,GACvBtJ,EACAgG,EACA9D,EAAM,WAAW,MACjBA,EAAM,OAAA,EAE8B,UAAY,CAACM,EAAS0G,CAAC,CAAC,EAE9D,GAAI2G,EAAa,SAAW,EAC1B,MAAO,KAIT,IAAIC,EAAiB,EAErB,GAAI9P,EAAQ,OAAS,YAAcA,EAAQ,OAAS,WAAY,CAE9D,MAAM0F,EAAY1F,EAAQ,WAAa,EACjC+P,EAAa/P,EAAQ,OAAS,WAAa4P,EAAY,IAAMA,EAAY,IACzEI,EAAeH,EAAa,OAAO,CAACjL,EAAKsE,IAAM,CACnD,MAAM+G,EAAavO,EAAW,MAAM,SAASwH,CAAC,EAAIxH,EAAagO,EACzDQ,EAAMtM,EAAwBsF,EAAG+G,CAAU,EAAE,IACnD,OAAOrL,EAAMsL,CACf,EAAG,CAAC,EAAIL,EAAa,OAIfrK,EAAYE,EAAYqK,EAAaC,EACrCG,EAAY,KAAK,IAAI,EAAG3K,CAAS,EAGvC,GAAIxF,EAAQ,QAAS,CACnB,MAAMoQ,EAAgBP,EAAa,OAAO,CAACjL,EAAKsE,IACvCtE,EAAMX,GAAmBjE,EAAQ,QAAUkJ,EAAE,OAAO,EAC1D,CAAC,EAAI2G,EAAa,OACrBC,EAAiBK,EAAYC,CAC/B,MACEN,EAAiBK,GAIfnQ,EAAQ,UAAY,eAAiBA,EAAQ,UAAY,gBAC3D8P,GAAkBD,EAAa,OAEnC,SAAW7P,EAAQ,OAAS,UAAW,CAErC,MAAMiG,EAAWjG,EAAQ,WAAa,EAChCqQ,EAAYT,EAAY,IACxB1J,EAAUD,EAAWoK,EAC3BP,EAAiB,KAAK,IAAI,EAAG5J,CAAO,EAGhClG,EAAQ,UAAY,eACtB8P,GAAkBD,EAAa,OAEnC,MAAW7P,EAAQ,OAAS,QAAUA,EAAQ,OAAS,WAEjDA,EAAQ,aAGV8P,EAFiB,OAAO,OAAO9P,EAAQ,UAAU,EAAE,OAAOsQ,GAAK,OAAOA,GAAM,QAAQ,EAC1D,OAAO,CAAC1L,EAAKC,IAAQD,EAAM,KAAK,IAAIC,CAAa,EAAG,CAAC,EACnD,GAKhC,OAAA4K,GAASK,EAAiB,GAKtB9P,EAAQ,SAAS,SACnByP,GAAS,GAGJA,CACT,CAMA,SAASc,GACPvQ,EACAgG,EACA9D,EACAsF,EACmB,CAOnB,MAAMqI,EANmBvG,GACvBtJ,EACAgG,EACA9D,EAAM,WAAW,MACjBA,EAAM,OAAA,EAE8B,UAAY,CAACM,EAAS0G,CAAC,CAAC,EAE9D,GAAI2G,EAAa,SAAW,EAC1B,MAAO,CAAA,EAKT,OAFmB7P,EAAQ,SAAS,QAAU,UAEtC,CACN,IAAK,UAAW,CAEd,MAAMwQ,EAASX,EAAa,IAAI7E,GAAU,CACxC,MAAMnI,EAAQP,GAAe0I,CAAM,EAC7ByF,EAAYzF,EAAO,UACnB0F,EAAUD,EAAY5N,EAG5B,IAAI8N,EAAcF,EAClB,GAAIzQ,EAAQ,QAAS,CACnB,MAAM4Q,EAAY3M,GAAmBjE,EAAQ,QAASgL,EAAO,OAAO,EACpE2F,EAAcF,EAAYG,CAC5B,CAEA,MAAO,CAAE,OAAA5F,EAAQ,YAAA2F,EAAa,QAAAD,CAAA,CAChC,CAAC,EAMD,GAHAF,EAAO,KAAK,CAACxI,EAAGC,IAAMD,EAAE,YAAcC,EAAE,WAAW,EAG/CjI,EAAQ,SAAS,cAAe,CAElC,MAAM6Q,GAAmB7Q,EAAQ,WAAa,IAC3CA,EAAQ,OAAS,WAAagG,EAAO,UAAU,IAAMA,EAAO,UAAU,KAGnE8K,EAAcN,EAAO,OAAO1E,GACf+E,EAAkB/E,EAAE,YACnBA,EAAE,YAAc,EACnC,EAED,GAAIgF,EAAY,OAAS,EAEvB,MAAO,CAACA,EAAY,CAAC,EAAG,OAAO,EAAE,CAErC,CAGA,OAAI9Q,EAAQ,UAAY,eAAiBA,EAAQ,UAAY,aACpDwQ,EAAO,IAAI1E,GAAKA,EAAE,OAAO,EAAE,EAEhC0E,EAAO,OAAS,EAEX,CAACA,EAAO,CAAC,EAAG,OAAO,EAAE,EAEvB,CAAA,CACT,CAEA,IAAK,YAAa,CAEhB,GAAI,CAACxQ,EAAQ,SAAW6P,EAAa,SAAW,EAC9C,OAAIA,EAAa,OAAS,EAEjB,CAACA,EAAa,CAAC,EAAG,EAAE,EAEtB,CAAA,EAIT,MAAMtL,EAAiBvE,EAAQ,QACzBwQ,EAASX,EAAa,IAAI7E,GAAU,CACxC,MAAM4F,EAAY3M,GAAmBM,EAAgByG,EAAO,OAAO,EACnE,MAAO,CAAE,OAAAA,EAAQ,UAAA4F,CAAA,CACnB,CAAC,EAGD,OADAJ,EAAO,KAAK,CAACxI,EAAGC,IAAMD,EAAE,UAAYC,EAAE,SAAS,EAC3CuI,EAAO,OAAS,EAEX,CAACA,EAAO,CAAC,EAAG,OAAO,EAAE,EAEvB,CAAA,CACT,CAEA,IAAK,cAAe,CAElB,MAAMO,EAAUlB,EAAa,UAC3B3G,EAAE,UAAU,KAAKlB,GAAKA,EAAE,OAAS,SAAS,CAAA,EAE5C,OAAI+I,EAAQ,OAAS,EAEZ,CAACA,EAAQ,CAAC,EAAG,EAAE,EAEpBlB,EAAa,OAAS,EAEjB,CAACA,EAAa,CAAC,EAAG,EAAE,EAEtB,CAAA,CACT,CAEA,IAAK,SAAU,CAEb,GAAIA,EAAa,SAAW,EAC1B,MAAO,CAAA,EAGT,GAAI7P,EAAQ,UAAY,eAAiBA,EAAQ,UAAY,aAC3D,OAAO6P,EAAa,IAAI3G,GAAKA,EAAE,EAAE,EAEnC,MAAM5H,EAAQ,KAAK,MAAMkG,EAAI,KAAA,EAASqI,EAAa,MAAM,EAEzD,MAAO,CAACA,EAAavO,CAAK,EAAG,EAAE,CACjC,CAEA,IAAK,aAAc,CAEjB,GAAIuO,EAAa,SAAW,EAC1B,MAAO,CAAA,EAGT,MAAMW,EAASX,EAAa,IAAI7E,GAAU,CAGxC,MAAMkF,EAAMlF,EAAO,UAAU,IAC7B,MAAO,CAAE,OAAAA,EAAQ,IAAAkF,CAAA,CACnB,CAAC,EAGD,OADAM,EAAO,KAAK,CAACxI,EAAGC,IAAMA,EAAE,IAAMD,EAAE,GAAG,EAC/BwI,EAAO,OAAS,EAEX,CAACA,EAAO,CAAC,EAAG,OAAO,EAAE,EAEvB,CAAA,CACT,CAEA,QACE,OAAIX,EAAa,OAAS,EAEjB,CAACA,EAAa,CAAC,EAAG,EAAE,EAEtB,CAAA,CAAC,CAEd,CAMO,SAASmB,GACd9O,EACAmI,EACA7C,EACY,CAGZ,MAAMiD,EADW,CAAC,GAAGvI,EAAM,WAAW,MAAO,GAAGA,EAAM,OAAO,EACtC,KAAKwF,GAAKA,EAAE,KAAO2C,CAAO,EACjD,GAAI,CAACI,GAASjI,EAASiI,CAAK,EAC1B,MAAM,IAAI,MAAM,kBAAkBJ,CAAO,EAAE,EAI7C,MAAM4G,EAAqBxG,EAAM,UAAU,OAAOzK,GAKvBsJ,GACvBtJ,EACAyK,EACAvI,EAAM,WAAW,MACjBA,EAAM,OAAA,EAE8B,UAAY,CAACM,EAAS0G,CAAC,CAAC,EAC1C,OAAS,CAC9B,EAED,GAAI+H,EAAmB,SAAW,EAEhC,MAAM,IAAI,MAAM,8BAA8B5G,CAAO,EAAE,EAIzD,MAAMmG,EAASS,EAAmB,IAAIjR,IAAY,CAChD,QAAAA,EACA,MAAOwP,GAAaxP,EAASyK,EAAOvI,CAAK,CAAA,EACzC,EAMF,GAHAsO,EAAO,KAAK,CAACxI,EAAGC,IAAMA,EAAE,MAAQD,EAAE,KAAK,EAGnCwI,EAAO,SAAW,EACpB,MAAM,IAAI,MAAM,2BAA2BnG,CAAO,EAAE,EAItD,IAAI6G,EAAgBV,EAAO,CAAC,EAAG,QAE/B,GAAIA,EAAO,OAAS,GAAKA,EAAO,CAAC,EAAG,MAAQA,EAAO,CAAC,EAAG,MAAQ,EAAK,CAElE,MAAMW,EAASX,EAAO,MAAM,EAAG,CAAC,EAC1BlP,EAAQ,KAAK,MAAMkG,EAAI,KAAA,EAAS2J,EAAO,MAAM,EACnDD,EAAgBC,EAAO7P,CAAK,EAAG,OACjC,CAGA,MAAMgJ,EAAYiG,GAAcW,EAAezG,EAAOvI,EAAOsF,CAAG,EAEhE,MAAO,CACL,UAAW0J,EAAc,GACzB,UAAA5G,CAAA,CAEJ,CC7UO,MAAM8G,EAA6B,CAChC,MACS,YACT,MAER,YAAYC,EAAc,CAExB,GAAIA,EAAO,EACT,MAAM,IAAI,MAAM,wCAAwCA,CAAI,EAAE,EAIhE,KAAK,YAAcA,GAAQ,EAC3B,KAAK,MAAQ,KAAK,YAClB,KAAK,MAAQ,EAGb,QAASvJ,EAAI,EAAGA,EAAI,GAAIA,IACtB,KAAK,aAAA,CAET,CAKQ,cAAuB,CAE7B,YAAK,OAAS,KAAK,OAAS,GAC5B,KAAK,OAAS,KAAK,QAAU,GAC7B,KAAK,OAAS,KAAK,OAAS,EACrB,KAAK,QAAU,CACxB,CAKA,MAAe,CACb,MAAM1I,EAAQ,KAAK,aAAA,EACnB,YAAK,OAAS,EAEPA,EAAQ,UACjB,CAMA,SAAkB,CAChB,MAAMA,EAAQ,KAAK,aAAA,EACnB,YAAK,OAAS,EACPA,CACT,CAEA,OAAc,CACZ,MAAMkS,EAAS,IAAIF,GAAa,KAAK,WAAW,EAChD,OAAAE,EAAO,MAAQ,KAAK,MACpBA,EAAO,MAAQ,KAAK,MACbA,CACT,CAEA,SAAkB,CAChB,OAAO,KAAK,WACd,CAEA,cAAuB,CACrB,OAAO,KAAK,KACd,CAEA,UAA2B,CACzB,MAAO,CACL,MAAO,KAAK,QAAU,EACtB,YAAa,KAAK,cAAgB,EAClC,MAAO,KAAK,QAAU,CAAA,CAE1B,CASA,OAAO,eAAeC,EAAwC,CAC5D,MAAMC,EAAO,IAAIJ,GAAaG,EAAS,WAAW,EAClD,OAAAC,EAAK,MAAQD,EAAS,QAAU,EAChCC,EAAK,MAAQD,EAAS,QAAU,EACzBC,CACT,CACF,CAOO,SAASC,GAASJ,EAAoB,CAC3C,GAAIA,EAAO,EACT,MAAM,IAAI,MAAM,wCAAwCA,CAAI,EAAE,EAEhE,OAAO,IAAID,GAAaC,CAAI,CAC9B,CCvIO,SAASK,GAAgBC,EAAuBC,EAA2B,CAChF,OAAOD,GAAiBC,CAC1B,CAUO,SAASC,GACd/Q,EACAd,EACQ,CACR,GAAIc,IAAc,KAEhB,MAAO,GAGT,GAAI,CAACd,EACH,MAAM,IAAI,MAAM,WAAWc,CAAS,YAAY,EAGlD,OAAOd,EAAQ,UAAY,CAC7B,CAQO,SAAS8R,GACdC,EACQ,CACR,OAAOA,EACJ,OAAQC,GAAmCA,IAAW,IAAI,EAC1D,OAAO,CAACxQ,EAAOwQ,IAAWxQ,EAAQwQ,EAAO,SAAU,CAAC,CACzD,CASO,SAASC,GACdN,EACAI,EACS,CAET,OADkBD,GAA6BC,CAAa,GACxCJ,CACtB,CCpCA,SAASO,GAAcF,EAA+B,CACpD,OAAOA,EAAO,YAAc,IAC9B,CAEA,SAASG,GACPH,EAEAI,EACS,CACT,OAAOF,GAAcF,CAAM,CAC7B,CAaO,SAASK,GACdnQ,EACAoQ,EACAxR,EACAwJ,EACAtK,EAC6B,CAC7B,GAAIkC,EAAM,QAAU,WAClB,OAAO0H,EAAI,8CAA8C,EAI3D,MAAM2I,EAAYrQ,EAAM,WAAW,MAAM,UAAUwF,GAAKA,EAAE,KAAO4K,CAAM,EACvE,GAAIC,IAAc,GAChB,OAAO3I,EAAI,QAAQ0I,CAAM,2BAA2B,EAItD,MAAME,EAAWtQ,EAAM,WAAW,MAAM,OACxC,GAAIqQ,EAAY,GAAKA,GAAaC,EAChC,OAAO5I,EAAI,cAAc2I,CAAS,gCAAgCC,CAAQ,EAAE,EAI9E,MAAMC,EAAiBvQ,EAAM,cAAcqQ,CAAS,EAGpD,GAAI,CACF,MAAMX,EAAWC,GAAmB/Q,EAAWd,CAAO,EAChD0S,EAAgBxQ,EAAM,eAAiBuQ,GAAgB,UAAY,GAGzE,GAAI,CAACf,GAAgBgB,EAAed,CAAQ,EAC1C,OAAOhI,EAAI,8BAA8BgI,CAAQ,eAAec,CAAa,EAAE,EAIjF,MAAMV,EAAuB,CAC3B,OAAAM,EACA,UAAAxR,EACA,UAAAwJ,EACA,SAAAsH,CAAA,EAIIe,EAAmB,CAAC,GAAGzQ,EAAM,aAAa,EAChD,OAAAyQ,EAAiBJ,CAAS,EAAIP,EAEvBrI,EAAG1H,EAAkBC,EAAO,CACjC,cAAeyQ,EACf,cAAeD,EAAgBd,CAAA,CAChC,CAAC,CACJ,OAAS/H,EAAO,CAEd,OAAOD,EAAIC,aAAiB,MAAQA,EAAM,QAAU,2BAA2B,OAAOA,CAAK,CAAC,EAAE,CAChG,CACF,CAUO,SAAS+I,GAAkB1Q,EAAoBqQ,EAAgD,CACpG,GAAIrQ,EAAM,QAAU,WAClB,OAAO0H,EAAI,8CAA8C,EAG3D,MAAMoI,EAAS9P,EAAM,cAAcqQ,CAAS,EAC5C,GAAI,CAACP,EACH,OAAOrI,EAAGzH,CAAK,EAIjB,MAAMyQ,EAAmB,CAAC,GAAGzQ,EAAM,aAAa,EAChD,OAAAyQ,EAAiBJ,CAAS,EAAI,KAEvB5I,EAAG1H,EAAkBC,EAAO,CACjC,cAAeyQ,EACf,cAAezQ,EAAM,cAAgB8P,EAAO,QAAA,CAC7C,CAAC,CACJ,CAUO,SAASa,GAAW3Q,EAAoB9D,EAA8C,CAC3F,OAAI8D,EAAM,QAAU,WACX0H,EAAI,4CAA4C,EAGpDrL,GAAiB2D,EAAM,WAAY9D,CAAO,EAI3C8D,EAAM,YAAY,SAAS9D,CAAO,EAC7BuL,EAAGzH,CAAK,EAGVyH,EAAG1H,EAAkBC,EAAO,CACjC,YAAa,CAAC,GAAGA,EAAM,YAAa9D,CAAO,CAAA,CAC5C,CAAC,EATOwL,EAAI,SAASxL,CAAO,gCAAgC,CAU/D,CAUO,SAAS0U,GAAa5Q,EAAoB9D,EAA8C,CAC7F,OAAI8D,EAAM,QAAU,WACX0H,EAAI,8CAA8C,EAGpDD,EAAG1H,EAAkBC,EAAO,CACjC,YAAaA,EAAM,YAAY,OAAO9B,GAAMA,IAAOhC,CAAO,CAAA,CAC3D,CAAC,CACJ,CASO,SAAS2U,GAAY7Q,EAAiC,CAC3D,OAAOD,EAAkBC,EAAO,CAC9B,cAAeA,EAAM,OAAA,CACtB,CACH,CAMA,SAAS8Q,GAA0B9Q,EAAiD,CAClF,GAAIA,EAAM,QAAU,WAClB,OAAO0H,EAAI,4CAA4C,EAMzD,MAAMqJ,EADa/Q,EAAM,WAAW,MAAM,OAAOwF,GAAK,CAAClF,EAASkF,CAAC,CAAC,EAChC,OAI5BwL,EAAmBhR,EAAM,cAAc,OAAO,CAAC8P,EAAQ1Q,IAAU,CACrE,MAAMzC,EAAOqD,EAAM,WAAW,MAAMZ,CAAK,EACzC,OAAOzC,GAAQ,CAAC2D,EAAS3D,CAAI,GAAKmT,IAAW,IAC/C,CAAC,EAED,OAAIkB,EAAiB,SAAWD,EACvBrJ,EAAI,8CAA8CqJ,CAAc,iCAAiCC,EAAiB,MAAM,EAAE,EAM9HjB,GAAsB/P,EAAM,QAASA,EAAM,aAAa,EAItDyH,EAAGzH,CAAK,EAHN0H,EAAI,4CAA4C,CAI3D,CAKA,SAASuJ,GAA2BjR,EAAiC,CACnE,OAAOD,EAAkBC,EAAO,CAC9B,MAAO,YACP,eAAgB,CAAA,CACjB,CACH,CAMA,SAASkR,GACPlR,EACAsF,EACwD,CAExD,MAAM6L,EAAgBnR,EAAM,cAAc,OAAQ8F,GAAyBA,IAAM,IAAI,EAG/EsL,EAAeC,GAAqBrR,EAAOsF,CAAG,EAG9CgM,EAAa,CAAC,GAAGH,EAAe,GAAGC,CAAY,EAC/CG,EAAgBC,GAAiBF,EAAYtR,EAAM,WAAYA,EAAM,OAAO,EAElF,IAAIyR,EAAezR,EACnB,MAAMyI,EAAwB,CAAA,EAE9B,UAAWqH,KAAUyB,EAAe,CAGlC,MAAMhJ,EADW,CAAC,GAAGkJ,EAAa,WAAW,MAAO,GAAGA,EAAa,OAAO,EACpD,QAAUjM,EAAE,KAAOsK,EAAO,MAAM,EAEvD,GAAI,CAACvH,GAASjI,EAASiI,CAAK,EAC1B,SAGF,MAAMoF,EAAe+D,GAAoB5B,EAAQ2B,CAAY,EAC7D,GAAI9D,EAAa,SAAW,EAC1B,SAGF,MAAMgE,EAAezJ,GACnBuJ,EACA3B,EAAO,OACPA,EAAO,WAAa,SACpBnC,EACArI,CAAA,EAGF,GAAI,CAACqM,EAAa,GAEhB,SAQF,GALAF,EAAeE,EAAa,MAAM,MAClClJ,EAAO,KAAK,GAAGkJ,EAAa,MAAM,MAAM,EAGjBF,EAAa,WAAW,MAAM,KAAKjM,GAAKA,EAAE,KAAOsK,EAAO,MAAM,GAC/DG,GAAmBH,EAAQ6B,EAAa,KAAK,EAAG,CAEpE,MAAMC,EAAU,KAAK,IAAIH,EAAa,cAAgB,EAAYA,EAAa,OAAO,EACtFA,EAAe1R,EAAkB0R,EAAc,CAC7C,cAAeG,CAAA,CAChB,EAEDnJ,EAAO,KAAK,CACV,KAAM,iBACN,OAAQ,EACR,OAAQqH,EAAO,OACf,SAAU8B,CAAA,CACX,CACH,CACF,CAEA,MAAO,CAAE,MAAOH,EAAc,OAAAhJ,CAAA,CAChC,CAMA,SAASoJ,GAAoB7R,EAA+D,CAC1F,OAAO0M,GAAe1M,CAAK,CAC7B,CAKA,SAAS8R,GACP9R,EACAiJ,EACa,CACb,OAAOlJ,EAAkBC,EAAO,CAC9B,MAAOiJ,IAAW,iBAAmB,UAAY,SACjD,OAAQA,CAAA,CACT,CACH,CAKA,SAAS8I,GAA0B/R,EAAiC,CAClE,MAAMgS,EAAgB,CAAE,GAAGhS,EAAM,mBAAA,EAC3BiS,EAAkB,CAAE,GAAGjS,EAAM,WAAW,aAAA,EAE9C,SAAW,CAAC9D,EAASgW,CAAK,IAAK,OAAO,QAAQF,CAAa,EACzD,GAAIE,EAAQ,GAEV,GADAF,EAAc9V,CAAO,EAAIgW,EAAQ,EAC7BF,EAAc9V,CAAO,IAAM,EAAG,CAChC,OAAO8V,EAAc9V,CAAO,EAC5B,MAAMiW,EAAUF,EAAgB/V,CAAO,EACnCiW,IACFF,EAAgB/V,CAAO,EAAI,CACzB,GAAGiW,EACH,MAAO,KAAA,EAGb,OAEA,OAAOH,EAAc9V,CAAO,EAIhC,IAAI0D,EAAcvE,EAAW2E,EAAM,WAAY,CAC7C,cAAeiS,CAAA,CAChB,EAOD,MAAMG,EAL4BxS,EAAY,MAAM,IAAIjD,GACtDgB,GAA4BhB,EAAMiD,CAAW,CAAA,EAIS,IAAIjD,GAAQ,CAElE,MAAM0V,EADiB3Q,EAAwB/E,EAAMiD,CAAW,EAChC,GAChC,IAAIwM,EAAUzP,EACd,OAAIA,EAAK,UAAY0V,IACnBjG,EAAU,CAAE,GAAGA,EAAS,UAAWiG,CAAA,GAG9BjG,CACT,CAAC,EAEDxM,EAAcvE,EAAWuE,EAAa,CACpC,MAAOwS,CAAA,CACR,EAED,MAAME,EAAYvS,EAAkBC,EAAO,CACzC,MAAO,WACP,YAAaA,EAAM,YAAc,EACjC,kBAAmB,EACnB,cAAepF,GAAiBgF,EAAY,MAAM,MAAM,EACxD,YAAa,CAAA,EACb,eAAgB,EAChB,WAAYA,EACZ,oBAAqBoS,CAAA,CACtB,EACD,OAAOnB,GAAYyB,CAAS,CAC9B,CAWO,SAASC,GACdvS,EACAsF,EACwD,CAExD,GAAI,CADewL,GAA0B9Q,CAAK,EAClC,GAMd,MAAO,CAAE,MAAAA,EAAO,OAAQ,EAAC,EAG3B,IAAIyR,EAAeR,GAA2BjR,CAAK,EACnD,MAAMwS,EAA2B,CAAA,EAEjC,GAAIf,EAAa,YAAY,OAAS,EAAG,CACvC,MAAMgB,EAAcC,GAAoBjB,EAAcnM,CAAG,EACzDmM,EAAegB,EAAY,MAC3BD,EAAU,KAAK,GAAGC,EAAY,MAAM,CACtC,CAGA,MAAME,EAAgBzB,GAAuBO,EAAcnM,CAAG,EAC9DmM,EAAekB,EAAc,MAC7BH,EAAU,KAAK,GAAGG,EAAc,MAAM,EAEtC,MAAMC,EAAYf,GAAoBJ,CAAY,EAClD,GAAImB,EACFnB,EAAeK,GAA4BL,EAAcmB,CAAS,EAClEJ,EAAU,KAAK,CACb,KAAM,aACN,OAAQI,CAAA,CACT,MACI,CACL,MAAMC,EAAmBpB,EACzBA,EAAeM,GAA0BN,CAAY,EACrD,MAAMqB,EAAoBC,GACxBF,EAAiB,WACjBpB,EAAa,UAAA,EAEf,GAAIqB,EAAkB,OAAS,EAAG,CAChC,MAAME,EAAaC,GAAqBJ,EAAiB,UAAU,EAC7DK,EAAcD,GAAqBxB,EAAa,UAAU,EAC1D0B,EAAiBC,GACrBJ,EACAE,EACAzB,EAAa,WAAW,MACxB,kBACAqB,CAAA,EAEFN,EAAU,KAAK,GAAGW,CAAc,CAClC,CACF,CAEA,MAAO,CACL,MAAO1B,EACP,OAAQe,CAAA,CAEZ,CAMA,SAASE,GACP1S,EACAsF,EACwD,CACxD,MAAMmD,EAAwB,CAAA,EAC9B,IAAIgJ,EAAezR,EACfJ,EAAcI,EAAM,WAExB,GAAIA,EAAM,YAAY,SAAW,EAC/B,MAAO,CAAE,MAAAA,EAAO,OAAAyI,CAAA,EAGlB,MAAMrM,EAAa4D,EAAM,YAAY,OAC/BgT,EAAaC,GAAqBjT,EAAM,UAAU,EAClDqT,EAAkBrT,EAAM,YAC3B,IAAK9B,GAAOf,EAAMe,CAAE,CAAC,EACrB,OAAQV,GAA8C,EAAQA,CAAM,EAGjE8V,EADkBtT,EAAM,YAAY,OACH,EAGjCiS,EAAkB,CAAE,GAAGrS,EAAY,aAAA,EACzC,UAAW1D,KAAW8D,EAAM,YAAa,CACvC,MAAMmS,EAAUF,EAAgB/V,CAAO,EACnCiW,IACFF,EAAgB/V,CAAO,EAAI,CACzB,GAAGiW,EACH,MAAO,UACP,kBAAmBnS,EAAM,WAAA,EAG/B,CAEAJ,EAAcvE,EAAWuE,EAAa,CACpC,cAAeqS,CAAA,CAChB,EAOD,MAAMsB,EAL4B3T,EAAY,MAAM,IAAIjD,GACtDgB,GAA4BhB,EAAMiD,CAAW,CAAA,EAIM,IAAIjD,GAAQ,CAE/D,MAAM0V,EADiB3Q,EAAwB/E,EAAMiD,CAAW,EAChC,GAChC,OAAIjD,EAAK,UAAY0V,EACZ,CAAE,GAAG1V,EAAM,UAAW0V,CAAA,EAExB1V,CACT,CAAC,EAEDiD,EAAcvE,EAAWuE,EAAa,CACpC,MAAO2T,CAAA,CACR,EAED,MAAML,EAAcD,GAAqBrT,CAAW,EAC9C4T,EAAgBJ,GACpBJ,EACAE,EACAtT,EAAY,MACZ,gBACAI,EAAM,WAAA,EAGRyI,EAAO,KAAK,GAAG+K,CAAa,EAE5B,MAAMC,EAAoB,CAAE,GAAGzT,EAAM,mBAAA,EACrC,UAAW9D,KAAW8D,EAAM,YAC1ByT,EAAkBvX,CAAO,EAAIoX,EAG/B7B,EAAe1R,EAAkB0R,EAAc,CAC7C,WAAY7R,EACZ,oBAAqB6T,CAAA,CACtB,EAED,UAAWjW,KAAS6V,EAAiB,CACnC,MAAMK,EAAelW,EAAM,aACrBmW,EAAuB,CAAA,EACvBC,EAA0B,CAAA,EAEhC,GAAIF,EAAa,OAAS,SAAU,CAClC,MAAMG,EAAeH,EAAa,QAAUvX,GAAsBC,CAAU,EAC5E,GAAIA,IAAe,EAAG,CACpB,MAAMgN,EAAiBqI,EAAa,QAAQ,IAAInG,GAAS,CACvD,GAAIhL,EAASgL,CAAK,EAAG,OAAOA,EAC5B,MAAM9G,EAAQ,KAAK,IAAI,EAAG8G,EAAM,UAAYuI,CAAY,EACxD,OAAApL,EAAO,KAAK,CACV,KAAM,MACN,SAAU6C,EAAM,GAChB,OAAQuI,CAAA,CACT,EACDF,EAAW,KAAKrI,EAAM,EAAE,EACjB,CAAE,GAAGA,EAAO,UAAW9G,CAAA,CAChC,CAAC,EACDiN,EAAe1R,EAAkB0R,EAAc,CAC7C,QAASrI,CAAA,CACV,CACH,KAAO,CACL,MAAM0K,EAAerC,EAAa,QAAQ,UAAY,CAACnR,EAASqG,CAAC,CAAC,EAClE,GAAImN,EAAa,OAAS,EAAG,CAC3B,MAAMC,EAAc,KAAK,MAAMzO,EAAI,KAAA,EAASwO,EAAa,MAAM,EACzDhL,EAASgL,EAAaC,CAAW,EACjCvP,EAAQ,KAAK,IAAI,EAAGsE,EAAO,UAAY+K,CAAY,EACzDpL,EAAO,KAAK,CACV,KAAM,MACN,SAAUK,EAAO,GACjB,OAAQ+K,CAAA,CACT,EACDF,EAAW,KAAK7K,EAAO,EAAE,EACzB,MAAMM,EAAiBqI,EAAa,QAAQ,IAAI9K,GAC9CA,EAAE,KAAOmC,EAAO,GAAK,CAAE,GAAGnC,EAAG,UAAWnC,GAAUmC,CAAA,EAEpD8K,EAAe1R,EAAkB0R,EAAc,CAC7C,QAASrI,CAAA,CACV,CACH,CACF,CACF,SAAWsK,EAAa,OAAS,OAAQ,CACvC,MAAM7H,EAAa6H,EAAa,WAC1BM,EAAcvC,EAAa,WAAW,MAAM,IAAK9U,GAAS,CAC9D,MAAMgE,EAAQe,EAAwB/E,EAAM8U,EAAa,UAAU,EAAE,GAC/DjN,EAAQ,KAAK,IAAI7H,EAAK,UAAYkP,EAAYlL,CAAK,EACzD,OAAI6D,IAAU7H,EAAK,WACjBiX,EAAc,KAAKjX,EAAK,EAAE,EAErB,CAAE,GAAGA,EAAM,UAAW6H,CAAA,CAC/B,CAAC,EACKyP,EAAuB5Y,EAAWoW,EAAa,WAAY,CAAE,MAAOuC,EAAa,EACvFvC,EAAe1R,EAAkB0R,EAAc,CAAE,WAAYwC,EAAsB,CACrF,SAAWP,EAAa,OAAS,OAAQ,CACvC,MAAMQ,EAAYR,EAAa,UACzBS,EAAc1C,EAAa,WAAW,MAAM,IAAK9U,GAAS,CAC9D,IAAIyP,EAAUzP,EACb,cAAO,QAAQuX,CAAS,EAA0D,QAAQ,CAAC,CAAChT,EAAMhE,CAAK,IAAM,CACxGA,IAAU,SAOZkP,EAAUlF,GAAkBkF,EANsB,CAChD,KAAM,OACN,KAAAlL,EACA,SAAUhE,EACV,SAAU,CAAA,CAE+B,EAE/C,CAAC,EACMkP,CACT,CAAC,EACKgI,EAAuB/Y,EAAWoW,EAAa,WAAY,CAAE,MAAO0C,EAAa,EACvF1C,EAAe1R,EAAkB0R,EAAc,CAAE,WAAY2C,EAAsB,CACrF,SAAWV,EAAa,OAAS,UAAW,CAE1C,MAAMtK,EAAiBqI,EAAa,QAAQ,IAAKnG,GAC3ChL,EAASgL,CAAK,EAAUA,EAKrBpE,GAAkBoE,EAJ0B,CACjD,KAAM,WACN,SAAU,CAAA,CAE0B,CACvC,EACDmG,EAAe1R,EAAkB0R,EAAc,CAAE,QAASrI,EAAgB,CAC5E,CAEA,MAAMiL,EACJX,EAAa,OAAS,OAClBE,EACAF,EAAa,OAAS,SACpBC,EACAD,EAAa,OAAS,OACpBjC,EAAa,WAAW,MAAM,IAAKjM,GAAMA,EAAE,EAAE,EAC7CiM,EAAa,QAAQ,OAAQ9K,GAAM,CAACrG,EAASqG,CAAC,CAAC,EAAE,IAAKA,GAAMA,EAAE,EAAE,EAW1E,GATI0N,EAAe,OAAS,GAC1B5L,EAAO,KAAK,CACV,KAAM,UACN,SAAU,eACV,UAAW,UAAUjL,EAAM,EAAE,GAC7B,QAAS6W,CAAA,CACV,EAGCX,EAAa,OAAS,OACxB,UAAWxV,KAAM0V,EACfnL,EAAO,KAAK,CAAE,KAAM,OAAQ,SAAUvK,EAAI,OAAQwV,EAAa,WAAY,CAGjF,CAEA,MAAO,CAAE,MAAOjC,EAAc,OAAAhJ,CAAA,CAChC,CAOA,SAAS+I,GACP8C,EACA9U,EACAC,EACgB,CAChB,MAAMwI,EAAW,CAAC,GAAGzI,EAAW,MAAO,GAAGC,CAAO,EAG3C8U,EAAkB,CACtB,cAAe,CAAA,EACf,cAAe,CAAA,CAMjB,EAEA,MAAO,CAAC,GAAGD,CAAO,EAAE,KAAK,CAACxO,EAAGC,IAAM,CACjC,MAAMyO,EAAQvM,EAAS,QAAUzC,EAAE,KAAOM,EAAE,MAAM,EAC5C2O,EAAQxM,EAAS,QAAUzC,EAAE,KAAOO,EAAE,MAAM,EAElD,GAAI,CAACyO,GAAS,CAACC,EAAO,MAAO,GAG7B,MAAMC,EAAYlV,EAAW,MAAM,QAAUgG,EAAE,KAAOM,EAAE,MAAM,EACxD6O,EAAYnV,EAAW,MAAM,QAAUgG,EAAE,KAAOO,EAAE,MAAM,EAKxD6O,EAAOF,EACT7S,EAAgB2S,EAAOhV,CAAU,EACjCqC,EAAgB2S,EAAOD,CAAS,EAC9BM,EAAOF,EACT9S,EAAgB4S,EAAOjV,CAAU,EACjCqC,EAAgB4S,EAAOF,CAAS,EAEpC,OAAIM,IAASD,EACJC,EAAOD,EAIZF,IAAcC,EACTD,EAAY,GAAK,EAGnB5O,EAAE,OAAO,cAAcC,EAAE,MAAM,CACxC,CAAC,CACH,CAMA,SAAS2L,GACP5B,EACA9P,EACmB,CACnB,MAAMiI,EAAW,CAAC,GAAGjI,EAAM,WAAW,MAAO,GAAGA,EAAM,OAAO,EACvDuI,EAAQN,EAAS,QAAUzC,EAAE,KAAOsK,EAAO,MAAM,EAGjDnC,EAAemC,EAAO,UAAU,OAAO5R,GAAM,CACjD,MAAMvB,EAAOsL,EAAS,KAAKzC,GAAKA,EAAE,KAAOtH,CAAE,EAC3C,OAAOvB,GAAQ,CAAC2D,EAAS3D,CAAI,CAC/B,CAAC,EAGD,GAAIgR,EAAa,OAAS,EACxB,OAAOA,EAQT,IAAImH,EAAyB,QACzBC,EAAyB,SAE7B,GAAIxM,GAASuH,EAAO,UAAW,CAE7B,IAAIhS,EAAUyK,EAAM,UAAU,QAAUzC,EAAE,KAAOgK,EAAO,SAAS,EAQjE,GAJKhS,IACHA,EAAUkX,GAAUlF,EAAO,SAAS,GAGlChS,EAAS,CAEX,MAAMyJ,EAAUzJ,EAAQ,QAEpByJ,IAAY,eAAiBA,IAAY,cAAgBA,IAAY,OACvEuN,EAAa,OAEbA,EAAa,QAGXvN,IAAY,eAAiBA,IAAY,aAC3CwN,EAAa,MAEbA,EAAa,QAEjB,MAGE,QAAQ,KAAK,yBAAyBjF,EAAO,SAAS,wBAAwBvH,EAAM,EAAE,EAAE,CAE5F,MAAWuH,EAAO,YAAc,OAE9BgF,EAAa,QACbC,EAAa,UAIf,MAAME,EAAiBjV,EAAM,WAAW,MAAM,KAAKwF,GAAKA,EAAE,KAAOsK,EAAO,MAAM,EAE9E,GAAIgF,IAAe,OAAQ,CAEzB,MAAMI,EAASD,EACXjV,EAAM,WAAW,MAAM,UAAY,CAACM,EAASkF,CAAC,CAAC,EAC/CxF,EAAM,QAAQ,UAAY,CAACM,EAASqG,CAAC,CAAC,EAE1C,OAAIuO,EAAO,SAAW,EACb,CAAA,EAGLH,IAAe,MAEVG,EAAO,IAAI1P,GAAKA,EAAE,EAAE,EAGpB,CAAC0P,EAAO,CAAC,EAAG,EAAE,CAEzB,KAAO,CAEL,MAAMzV,EAAUwV,EACZjV,EAAM,QAAQ,OAAO2G,GAAK,CAACrG,EAASqG,CAAC,CAAC,EACtC3G,EAAM,WAAW,MAAM,UAAY,CAACM,EAASkF,CAAC,CAAC,EAEnD,OAAI/F,EAAQ,SAAW,EACd,CAAA,EAGLsV,IAAe,MAEVtV,EAAQ,IAAI+F,GAAKA,EAAE,EAAE,EAGrB,CAAC/F,EAAQ,CAAC,EAAG,EAAE,CAE1B,CACF,CAMA,SAAS4R,GACPrR,EACAsF,EACyB,CACzB,MAAMgP,EAA0B,CAAA,EAEhC,UAAWhJ,KAAStL,EAAM,QACxB,GAAI,CAAAM,EAASgL,CAAK,EAElB,GAAI,CACF,MAAM6J,EAAWrG,GAAe9O,EAAOsL,EAAM,GAAIhG,CAAG,EAChD6P,GACFb,EAAQ,KAAK,CACX,OAAQhJ,EAAM,GACd,UAAW6J,EAAS,UACpB,UAAWA,EAAS,UACpB,SAAU,CAAA,CACX,CAEL,OAASxN,EAAO,CAEd,QAAQ,KAAK,gCAAgC2D,EAAM,EAAE,wBAAyB3D,CAAK,EACnF,MAAMyN,EAAepV,EAAM,WAAW,MAAM,OAAO,GAAK,CAACM,EAAS,CAAC,CAAC,EAChE8U,EAAa,OAAS,GACxBd,EAAQ,KAAK,CACX,OAAQhJ,EAAM,GACd,UAAW,KACX,UAAW,CAAC8J,EAAa,CAAC,EAAG,EAAE,EAC/B,SAAU,CAAA,CACX,CAEL,CAGF,OAAOd,CACT,CAMA,SAAS5H,GAAe1M,EAA+D,CACrF,MAAM4M,EAAe5M,EAAM,QAAQ,MAAM2G,GAAKrG,EAASqG,CAAC,CAAC,EACnD0O,EAAerV,EAAM,WAAW,MAAM,MAAMwF,GAAKlF,EAASkF,CAAC,CAAC,EAK5DD,EAAavF,EAAM,WAAW,MAAM,OAAOwF,GAAK,CAAClF,EAASkF,CAAC,CAAC,EAClE,OAAI6P,GAAgB9P,EAAW,OAAS,GACtC,QAAQ,KAAK,sFAAuF,CAClG,MAAOvF,EAAM,WAAW,MAAM,QAAU,CAAE,GAAIwF,EAAE,GAAI,UAAWA,EAAE,UAAW,KAAMlF,EAASkF,CAAC,GAAI,EAChG,WAAYD,EAAW,IAAIC,IAAM,CAAE,GAAIA,EAAE,GAAI,UAAWA,EAAE,SAAA,EAAY,EACtE,aAAA6P,CAAA,CACD,EACM,MAILzI,GAAgByI,EACX,gBAGLzI,EACK,iBAELyI,EACK,gBAEF,IACT,CAIA,SAASpC,GAAqB3X,EAA4C,CACxE,MAAM+T,EAA2C,CAAA,EACjD,UAAW1S,KAAQrB,EAAK,MACtB+T,EAAS1S,EAAK,EAAE,EAAID,GAA6BC,EAAMrB,CAAI,EAE7D,OAAO+T,CACT,CAEA,SAAS+D,GACPkC,EACAC,EACAna,EACA2M,EACAxJ,EACe,CACf,GAAIA,EAAS,SAAW,EACtB,MAAO,CAAA,EAGT,MAAMkK,EAAwB,CAAA,EAC9B,UAAW9L,KAAQvB,EAAO,CACxB,MAAMoa,EAAOF,EAAO3Y,EAAK,EAAE,EACrB8Y,EAAOF,EAAM5Y,EAAK,EAAE,EACpB+Y,GAAYD,GAAM,KAAO,IAAMD,GAAM,KAAO,GAC5CG,GAAYF,GAAM,KAAO,IAAMD,GAAM,KAAO,GAC9CE,IAAa,GAAKC,IAAa,GAInClN,EAAO,KAAK,CACV,KAAAV,EACA,OAAQpL,EAAK,GACb,SAAA4B,EACA,SAAAmX,EACA,SAAAC,CAAA,CACD,CACH,CAEA,OAAOlN,CACT,CAEA,SAASsK,GAAqBuC,EAAcC,EAAuB,CACjE,MAAMK,EAAsB,CAAA,EAC5B,SAAW,CAAC1Z,EAASiW,CAAO,IAAK,OAAO,QAAQoD,EAAM,aAAa,EAAG,CACpE,MAAMM,EAAgBP,EAAO,cAAcpZ,CAAO,GAAG,MACjD2Z,GAAiBA,IAAkB,OAAS1D,EAAQ,QAAU,OAChEyD,EAAU,KAAK1Z,CAAO,CAE1B,CACA,OAAO0Z,CACT,CAMO,SAASE,GAAqB9V,EAA8B,CAEjE,MAAM+V,EAAa/V,EAAM,WAAW,MAAM,IAAI,CAACrD,EAAMyC,KAAW,CAC9D,MAAAA,EACA,IAAKkB,EAAS3D,CAAI,EAAI,GAAKkF,EAAgBlF,EAAMqD,EAAM,UAAU,EACjE,KAAMM,EAAS3D,CAAI,CAAA,EACnB,EAGF,OAAAoZ,EAAW,KAAK,CAACjQ,EAAGC,IAEdD,EAAE,MAAQ,CAACC,EAAE,KAAa,EAC1B,CAACD,EAAE,MAAQC,EAAE,KAAa,GAE1BA,EAAE,MAAQD,EAAE,IACPC,EAAE,IAAMD,EAAE,IAGZA,EAAE,MAAQC,EAAE,KACpB,EAEMgQ,EAAW,IAAIvQ,GAAKA,EAAE,KAAK,CACpC,CC58BO,SAASwQ,GAAc5a,EAAyC,CACrE,OAAOA,EAAM,IAAIuB,GAAQ,CACvB,MAAMgE,EAAQP,GAAezD,CAAI,EACjC,MAAO,CACL,GAAGA,EACH,UAAWgE,EACX,cAAe,CAAA,CAAC,CAEpB,CAAC,CACH,CChBO,MAAMsV,GAAcC,EAAS,CAClC,GAAIC,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAC1B,GAAIA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAC1B,IAAKA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAC3B,IAAKA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAC3B,IAAKA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAC3B,IAAKA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,CAC7B,CAAC,ECVYC,GAA4BC,EAAQC,EAAO,CAAC,WAAY,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,ECK/EC,GAAgBD,EAAO,CAAC,QAAS,OAAQ,UAAW,UAAW,SAAS,CAAC,EAMlEE,GAA2BN,EAAS,CAC/C,GAAIC,EAAE,EAAS,IAAA,EACf,GAAIA,EAAE,EAAS,IAAA,EACf,IAAKA,EAAE,EAAS,IAAA,EAChB,IAAKA,EAAE,EAAS,IAAA,EAChB,IAAKA,EAAE,EAAS,IAAA,EAChB,IAAKA,EAAE,EAAS,IAAA,CAClB,CAAC,EAAE,QAAA,EAKUM,GAAsBH,EAAO,CAAC,SAAU,QAAS,OAAQ,QAAS,WAAW,CAAC,EAK9EI,GAAsBJ,EAAO,CACxC,QACA,SACA,OACA,QACA,SACA,UACA,YACA,UACF,CAAC,EAMYK,EAAkBT,EAAS,CACtC,GAAIU,EAAE,EAAS,IAAI,CAAC,EACpB,KAAMA,EAAE,EAAS,IAAI,CAAC,EACtB,KAAMH,GACN,KAAMC,GACN,KAAMP,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAC5B,UAAWK,GAAyB,QAAQ,EAAE,EAC9C,gBAAiBH,EAAQE,EAAa,EAAE,IAAI,CAAC,EAAE,SAAA,EAC/C,eAAgBK,EAAE,EAAS,SAAA,EAC3B,0BAA2BC,EAAE,EAAU,SAAA,EACvC,gBAAiBV,EAAE,EAAS,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,SAAA,EAC1C,gBAAiBU,EAAE,EAAU,SAAA,EAC7B,YAAaT,GAA0B,SAAA,EAAW,SAAA,CACpD,CAAC,EAOYU,GAAyBZ,EAAS,CAC7C,OAAQS,EAAgB,SAAA,EACxB,MAAOA,EAAgB,SAAA,EACvB,KAAMA,EAAgB,SAAA,EACtB,MAAOA,EAAgB,SAAA,EACvB,UAAWA,EAAgB,SAAA,CAC7B,CAAC,EC5DYI,GAAiB,6BAEjBC,GAAgBd,EAAS,CACpC,GAAIU,EAAE,EAAS,MAAMG,GAAgB,CACnC,QAAS,0EAAA,CACV,EACD,KAAMH,EAAE,EAAS,IAAI,CAAC,EACtB,KAAMN,EAAO,CAAC,WAAY,WAAY,UAAW,OAAQ,SAAU,QAAQ,CAAC,EAC5E,QAASA,EAAO,CAAC,QAAS,OAAQ,UAAW,UAAW,SAAS,CAAC,EAAE,SAAA,EACpE,SAAUH,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAAE,IAAI,CAAC,EACvC,UAAWA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACjC,QAASG,EAAO,CAAC,eAAgB,cAAe,cAAe,aAAc,MAAM,CAAC,EACpF,YAAaH,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAAE,IAAI,EAAE,EAC3C,KAAMG,EAAO,CAAC,SAAU,UAAU,CAAC,EAAE,SAAA,EACrC,YAAaM,EAAE,EAGf,YAAaC,EAAE,EAAU,SAAA,EACzB,cAAeA,EAAE,EAAU,SAAA,EAC3B,WAAYX,EAAS,CACnB,IAAKC,EAAE,EAAS,SAAA,EAChB,IAAKA,EAAE,EAAS,SAAA,EAChB,IAAKA,EAAE,EAAS,SAAA,EAChB,IAAKA,EAAE,EAAS,SAAA,CAAS,CAC1B,EAAE,SAAA,EACH,SAAUA,EAAE,EAAS,MAAM,IAAI,CAAC,EAAE,SAAA,EAGlC,aAAcD,EAAS,CACrB,KAAMI,EAAO,CAAC,SAAU,OAAQ,SAAU,WAAY,MAAM,CAAC,EAC7D,SAAUH,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAChC,OAAQA,EAAE,EAAS,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,SAAA,CAAS,CAC3C,EAAE,SAAA,EAGH,aAAcD,EAAS,CACrB,IAAKC,EAAE,EAAS,SAAA,EAChB,IAAKA,EAAE,EAAS,SAAA,EAChB,IAAKA,EAAE,EAAS,SAAA,EAChB,IAAKA,EAAE,EAAS,SAAA,EAChB,GAAIA,EAAE,EAAS,SAAA,CAAS,CACzB,EAAE,SAAA,EAGH,aAAcD,EAAS,CACrB,OAAQC,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAC9B,SAAUA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,CAAA,CACjC,EAAE,SAAA,EAGH,SAAUA,IAAW,MAAM,IAAI,CAAC,EAAE,IAAI,EAAE,EAAE,SAAA,EAG1C,OAAQU,EAAE,EAAU,SAAA,EACpB,gBAAiBV,EAAE,EAAS,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,SAAA,EAG1C,qBAAsBA,EAAE,EAAS,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,SAAA,EAC/C,oBAAqBA,EAAE,EAAS,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,SAAA,EAG9C,cAAeA,IAAW,MAAM,IAAI,CAAC,EAAE,IAAI,EAAE,EAAE,SAAA,EAG/C,oBAAqBc,GAAQ,CAC3Bf,EAAS,CAAE,KAAMgB,EAAU,KAAK,EAAG,EACnChB,EAAS,CAAE,KAAMgB,EAAU,UAAU,EAAG,EACxChB,EAAS,CACP,KAAMgB,EAAU,QAAQ,EACxB,SAAUb,EAAQC,EAAO,CAAC,SAAU,OAAQ,SAAU,WAAY,OAAQ,QAAQ,CAAC,CAAC,CAAA,CACrF,CAAA,CACF,EAAE,SAAA,EAGH,uBAAwBH,EAAE,EAAS,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,SAAA,EAGjD,oBAAqBD,EAAS,CAC5B,QAASI,EAAO,CAAC,QAAS,OAAQ,UAAW,SAAS,CAAC,EACvD,SAAUH,EAAE,CAAO,CACpB,EAAE,SAAA,EAGH,cAAeD,EAAS,CACtB,IAAKW,EAAE,EACP,MAAOR,EAAQC,EAAO,CAAC,SAAU,OAAQ,SAAU,WAAY,OAAQ,QAAQ,CAAC,CAAC,EAAE,SAAA,EACnF,SAAUH,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,CAAA,CACjC,EAAE,SAAA,EAGH,QAASD,EAAS,CAChB,SAAUC,EAAE,EAAS,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,SAAA,EACnC,OAAQG,EAAO,CAAC,UAAW,SAAU,YAAa,cAAe,YAAY,CAAC,EAAE,SAAA,EAChF,cAAeO,EAAE,EAAU,SAAA,EAC3B,OAAQA,EAAE,EAAU,SAAA,CAAS,CAC9B,EAAE,SAAA,CACL,CAAC,EClGYN,GAAgBD,EAAO,CAAC,QAAS,OAAQ,UAAW,UAAW,SAAS,CAAC,EAOzEa,GAAiBb,EAAO,CACnC,mBACA,WACA,iBACA,SACA,iBACA,gBACA,iBACA,iBACA,oBACA,gBACF,CAAC,EAOYc,GAAmBd,EAAO,CAAC,MAAO,UAAW,UAAU,CAAC,EAO/De,GAAgBf,EAAO,CAAC,KAAM,KAAM,MAAO,MAAO,MAAO,KAAK,CAAC,EAKxDgB,GAAqBC,GAAqB,OAAQ,CAC7DrB,EAAS,CACP,KAAMgB,EAAU,MAAM,EACtB,KAAMG,GACN,SAAUlB,EAAE,EAAS,SAAA,EACrB,SAAUA,EAAE,EAAS,IAAA,EAAM,SAAA,CAAS,CACrC,EACDD,EAAS,CACP,KAAMgB,EAAU,QAAQ,EACxB,KAAMG,GACN,SAAUlB,EAAE,EAAS,SAAA,EACrB,SAAUA,EAAE,EAAS,IAAA,EAAM,SAAA,CAAS,CACrC,EACDD,EAAS,CACP,KAAMI,EAAO,CAAC,SAAU,MAAM,CAAC,EAC/B,cAAeH,EAAE,EAAS,IAAA,EAAM,SAAA,EAChC,SAAUA,EAAE,EAAS,IAAA,EAAM,SAAA,CAAS,CACrC,EACDD,EAAS,CACP,KAAMI,EAAO,CAAC,SAAU,WAAY,MAAM,CAAC,EAC3C,SAAUH,EAAE,EAAS,IAAA,EAAM,SAAA,CAAS,CACrC,EACDD,EAAS,CACP,KAAMgB,EAAU,cAAc,EAC9B,YAAaf,EAAE,EAAS,IAAA,EAAM,SAAA,EAC9B,SAAUA,EAAE,EAAS,IAAA,EAAM,SAAA,CAAS,CACrC,EAIDD,EAAS,CACP,KAAMgB,EAAU,qBAAqB,EACrC,QAASX,GACT,SAAUJ,EAAE,EACZ,SAAUA,EAAE,EAAS,IAAA,EAAM,SAAA,CAAS,CACrC,EAEDD,EAAS,CACP,KAAMgB,EAAU,iBAAiB,EACjC,QAASf,EAAE,EAAS,IAAI,CAAC,EAAE,IAAI,CAAC,EAChC,SAAUA,EAAE,EAAS,IAAA,EAAM,SAAA,CAAS,CACrC,EAEDD,EAAS,CACP,KAAMgB,EAAU,QAAQ,EACxB,iBAAkBf,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACxC,SAAUA,EAAE,EAAS,IAAA,EAAM,SAAA,CAAS,CACrC,EAEDD,EAAS,CACP,KAAMgB,EAAU,cAAc,EAC9B,SAAUf,EAAE,EAAS,IAAA,EAAM,SAAA,CAAS,CACrC,EAEDD,EAAS,CACP,KAAMgB,EAAU,UAAU,EAC1B,IAAKL,EAAE,EACP,MAAOR,EAAQC,EAAO,CAAC,SAAU,OAAQ,SAAU,WAAY,OAAQ,QAAQ,CAAC,CAAC,EAAE,SAAA,EACnF,SAAUH,EAAE,EAAS,IAAA,EAAM,SAAA,CAAS,CACrC,EAEDD,EAAS,CACP,KAAMgB,EAAU,YAAY,EAC5B,UAAWf,EAAE,EAAS,IAAI,CAAC,EAAE,IAAI,CAAC,EAClC,cAAeA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,CAAA,CACtC,CACH,CAAC,EAKYqB,GAAuBtB,EAAS,CAC3C,GAAIU,EAAE,EAAS,IAAI,CAAC,EACpB,KAAMA,EAAE,EAAS,IAAI,CAAC,EACtB,QAASL,GACT,KAAMY,GACN,UAAWlB,GACX,YAAaA,GACb,UAAWI,EAAQW,EAAa,EAChC,iBAAkBb,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACxC,YAAaS,EAAE,EACf,iBAAkBN,EAAO,CAAC,YAAa,WAAW,CAAC,EAAE,SAAA,EACrD,YAAaF,GAA0B,SAAA,EAAW,SAAA,CACpD,CAAC,EAKYqB,GAAavB,EAAS,CACjC,GAAIU,EAAE,EAAS,IAAI,CAAC,EACpB,KAAMA,EAAE,EAAS,IAAI,CAAC,EACtB,QAASL,GACT,KAAMY,GACN,UAAWlB,GACX,YAAaA,GACb,YAAaW,EAAE,EACf,iBAAkBT,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACxC,MAAOA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAAE,IAAI,EAAE,EACrC,GAAIA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAC1B,UAAWA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACjC,iBAAkBG,EAAO,CAAC,YAAa,WAAW,CAAC,EAAE,SAAA,EACrD,UAAWQ,GACX,cAAeD,EAAE,EACjB,MAAOR,EAAQO,IAAW,IAAI,CAAC,CAAC,EAChC,YAAac,EAASd,EAAE,EAAUQ,EAAgB,EAClD,UAAWf,EAAQW,EAAa,EAChC,mBAAoBX,EAAQO,IAAW,IAAI,CAAC,CAAC,EAC7C,cAAeP,EAAQiB,EAAkB,EACzC,aAAcnB,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACpC,YAAaD,EAAS,CACpB,YAAaC,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACnC,YAAaA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,CAAA,CACpC,CACH,CAAC,EAAE,YAAY,CAAC3Q,EAAGmS,IAAQ,CAEzB,MAAMhX,EAAQ6E,EAAE,UAAU,IAAMA,EAAE,MAAQ,GAAKA,EAAE,YAAY,GACzDA,EAAE,UAAY7E,GAChBgX,EAAI,SAAS,CACX,KAAMC,EAAe,OACrB,QAAS,cAAcpS,EAAE,SAAS,oBAAoB7E,CAAK,IAC3D,KAAM,CAAC,WAAW,CAAA,CACnB,CAEL,CAAC,ECjKKkX,GAAqB3B,EAAS,CAClC,QAASU,EAAE,EAAS,IAAI,CAAC,EACzB,MAAOQ,GACP,kBAAmBjB,EAAE,EAAS,IAAA,CAChC,CAAC,EAMK2B,GAAiB5B,EAAS,CAC9B,SAAUW,EAAE,EAAU,SAAA,EACtB,aAAcA,EAAE,EAAU,SAAA,EAC1B,cAAeV,EAAE,EAAS,MAAM,IAAI,CAAC,EAAE,SAAA,EACvC,gBAAiBA,EAAE,EAAS,IAAA,EAAM,SAAA,EAClC,WAAYuB,EAASd,IAAYK,GAAQ,CAACL,IAAYT,IAAYU,GAAW,CAAC,CAAC,EAAE,SAAA,CACnF,CAAC,EAEKkB,GAAoB7B,EAAS,CACjC,iBAAkBC,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAAE,QAAQ,CAAC,EACnD,UAAWA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAAE,QAAQ,CAAC,EAC5C,aAAcA,IAAW,MAAM,IAAI,CAAC,EAAE,SAAA,EAAW,QAAQ,IAAI,EAC7D,mBAAoBA,IAAW,MAAM,IAAI,CAAC,EAAE,WAAW,QAAQ,IAAI,CACrE,CAAC,EAMY6B,EAAe9B,EAAS,CACnC,QAASgB,EAAU,OAAO,EAC1B,UAAWf,EAAE,EAAS,IAAA,EAAM,SAAA,EAC5B,QAASA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAAE,QAAQ,CAAC,EAG1C,WAAYD,EAAS,CACnB,eAAgBG,EAAQoB,EAAU,EAAE,IAAI,EAAE,EAC1C,YAAapB,EAAQO,IAAW,IAAI,CAAC,CAAC,EAAE,IAAIrc,CAAc,EAAE,IAAIC,CAAc,EAC9E,UAAW6b,EAAQM,CAAe,EAClC,KAAMR,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAC5B,eAAgBE,EAAQO,IAAW,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,EACjD,cAAeP,EAAQO,EAAE,EAAS,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,SAAA,EACjD,cAAec,EAASd,IAAYiB,EAAkB,EAAE,SAAA,EACxD,iBAAkBH,EAASd,IAAYC,GAAW,EAClD,WAAYa,EAASd,IAAYC,GAAW,CAAA,CAC7C,EAGD,eAAgBX,EAAS,CACvB,eAAgBA,EAAS,CACvB,EAAGC,EAAE,EACL,EAAGA,EAAE,CAAO,CACb,EACD,aAAcS,EAAE,EAAS,IAAI,CAAC,EAC9B,UAAWc,EAASd,EAAE,EAAUkB,EAAc,CAAA,CAC/C,EAGD,MAAO5B,EAAS,CACd,WAAYC,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAClC,YAAaA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACnC,iBAAkBA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACxC,iBAAkBA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACxC,SAAUA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,CAAA,CACjC,EACD,WAAY4B,GAAkB,SAAA,CAChC,CAAC,ECnEYF,GAAqB3B,EAAS,CACzC,QAASU,EAAE,EAAS,IAAI,CAAC,EACzB,MAAOQ,GACP,kBAAmBjB,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,CAC3C,CAAC,EAKY8B,GAAa/B,EAAS,CACjC,cAAeG,EAAQO,IAAW,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,EAC/C,cAAec,EAASd,EAAE,EAAUiB,EAAkB,EACtD,MAAOxB,EAAQoB,EAAU,EAAE,IAAIld,CAAc,EAAE,IAAIC,CAAc,EACjE,eAAgB6b,EAAQO,IAAW,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,EACjD,YAAaT,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACnC,oBAAqBuB,EAASd,IAAYT,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,CAAC,EACjE,YAAauB,EAASd,EAAE,EAAUQ,EAAgB,CACpD,CAAC,EAAE,YAAY,CAACpQ,EAAG2Q,IAAQ,CAErB3Q,EAAE,cAAc,OAAS,GAC3B2Q,EAAI,SAAS,CACX,KAAMC,EAAe,QACrB,QAAS,EACT,KAAM,QACN,UAAW,GACX,KAAM,CAAC,eAAe,CAAA,CACvB,CAEL,CAAC,EC3BYM,GAAqB5B,EAAO,CAAC,iBAAkB,eAAe,CAAC,EAK/D6B,GAAqBlB,GAAQ,CACxCC,EAAU,SAAS,EACnBgB,EACF,CAAC,EAKYE,GAAqBlC,EAAS,CACzC,OAAQU,EAAE,EAAS,IAAI,CAAC,EACxB,UAAWA,EAAE,EAAS,SAAA,EACtB,UAAWP,EAAQO,IAAW,IAAI,CAAC,CAAC,EACpC,SAAUT,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAAE,IAAI,EAAE,CAC1C,CAAC,EAKYkC,GAAoB/B,EAAO,CAAC,WAAY,YAAa,UAAW,QAAQ,CAAC,EAMrDJ,EAAS,CACxC,WAAY+B,GACZ,QAAS5B,EAAQoB,EAAU,EAAE,IAAI,CAAC,EAClC,YAAatB,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACnC,YAAaA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACnC,MAAOkC,GACP,UAAWhC,EAAQO,IAAW,IAAI,CAAC,CAAC,EACpC,kBAAmBT,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACzC,OAAQgC,GACR,IAAK9B,EAAQO,GAAU,EAGvB,kBAAmBT,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACzC,cAAeE,EAAQ+B,GAAmB,SAAA,CAAU,EAAE,IAAI7d,CAAc,EAAE,IAAIC,CAAc,EAC5F,YAAa6b,EAAQO,IAAW,IAAI,CAAC,CAAC,EACtC,cAAeT,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACrC,QAASA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EAC/B,eAAgBA,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,EACtC,oBAAqBuB,EAASd,IAAYT,EAAE,EAAS,IAAA,EAAM,IAAI,CAAC,CAAC,EACjE,YAAaD,EAAS,CACpB,MAAOC,EAAE,EAAS,IAAA,EAClB,YAAaA,EAAE,EAAS,IAAA,EACxB,MAAOA,EAAE,EAAS,IAAA,CAAI,CACvB,EAAE,SAAA,EAGH,aAAcU,EAAE,EAAU,SAAA,EAC1B,MAAOD,EAAE,EAAS,SAAA,EAClB,YAAaA,EAAE,EAAS,SAAA,EACxB,KAAMV,EAAS,CACb,YAAaU,EAAE,EACf,WAAYN,EAAO,CAAC,SAAU,QAAS,MAAM,CAAC,EAAE,SAAA,CAAS,CAC1D,EAAE,SAAA,CACL,CAAC,EAAE,YAAY,CAACvQ,EAAG4R,IAAQ,CAEzB,MAAMW,EAAUvS,EAAE,WAAW,MAAM,IAAI,GAAK,EAAE,EAAE,EAC1CwS,EAAWxS,EAAE,QAAQ,IAAI,GAAK,EAAE,EAAE,EAClCyS,MAAY,IAAI,CAAC,GAAGF,EAAS,GAAGC,CAAQ,CAAC,EAE/C,SAAW,CAAC3S,EAAG1H,CAAE,IAAK6H,EAAE,UAAU,UAC3ByS,EAAM,IAAIta,CAAE,GACfyZ,EAAI,SAAS,CACX,KAAMC,EAAe,OACrB,KAAM,CAAC,YAAahS,CAAC,EACrB,QAAS,qBAAqB1H,CAAE,EAAA,CACjC,EAIL,MAAMoS,EAAWvK,EAAE,WAAW,MAAM,OAGhCA,EAAE,mBAAqBuK,GACzBqH,EAAI,SAAS,CACX,KAAMC,EAAe,QACrB,QAAStH,EAAW,EACpB,KAAM,SACN,UAAW,GACX,KAAM,CAAC,mBAAmB,EAC1B,QAAS,sBAAsBvK,EAAE,iBAAiB,wBAAwBuK,CAAQ,GAAA,CACnF,EAICvK,EAAE,cAAc,SAAWuK,GAC7BqH,EAAI,SAAS,CACX,KAAMC,EAAe,OACrB,KAAM,CAAC,eAAe,EACtB,QAAS,yBAAyB7R,EAAE,cAAc,MAAM,2BAA2BuK,CAAQ,GAAA,CAC5F,EAIH,SAAW,CAAC1K,EAAGkK,CAAM,IAAK/J,EAAE,cAAc,UACpC+J,GAAU,CAACwI,EAAQ,SAASxI,EAAO,MAAM,GAC3C6H,EAAI,SAAS,CACX,KAAMC,EAAe,OACrB,KAAM,CAAC,gBAAiBhS,EAAG,QAAQ,EACnC,QAAS,0CAA0CkK,EAAO,MAAM,EAAA,CACjE,EAICA,GAAUlK,GAAK0K,GACjBqH,EAAI,SAAS,CACX,KAAMC,EAAe,OACrB,KAAM,CAAC,gBAAiBhS,CAAC,EACzB,QAAS,0BAA0BA,CAAC,uBAAuB0K,CAAQ,GAAA,CACpE,EAKDvK,EAAE,cAAgBA,EAAE,SACtB4R,EAAI,SAAS,CACX,KAAMC,EAAe,OACrB,KAAM,CAAC,eAAe,EACtB,QAAS,kBAAkB7R,EAAE,aAAa,sBAAsBA,EAAE,OAAO,GAAA,CAC1E,CAEL,CAAC,EC5HM,MAAM0S,GAAuB,QA4B7B,SAASC,GAAgBC,EAAwC,CAGtE,MAAM1P,EAAS+O,EAAa,UAAUW,CAAI,EAE1C,OAAK1P,EAAO,QAILxB,EAAGwB,EAAO,IAAI,EAHZvB,EAAI,sBAAsBuB,EAAO,MAAM,OAAO,EAAE,CAI3D,CCGO,SAAS2P,GACdC,EACAC,EACAC,EAAyBN,GACzBO,EACoC,CACpC,GAAI,CAACH,GAAW,OAAOA,GAAY,SACjC,OAAOnR,EAAI,CACT,KAAM,iBACN,QAAS,4BAAA,CACV,EAGH,MAAMuR,EAAOJ,EAOPK,EAAgB,CACnBD,EAAK,QAAsB,KAAZ,UACfA,EAAK,UAA0B,KAAd,YACjBA,EAAK,SAAwB,KAAb,WACjB,OAAOA,EAAK,KAAS,IAAc,OAAS,IAAA,EAC5C,OAAQE,GAAmBA,IAAM,IAAI,EAEvC,GAAID,EAAc,OAAS,EACzB,OAAOxR,EAAI,CACT,KAAM,eACN,cAAAwR,CAAA,CACD,EAGH,IAAIP,EAAOM,EAAK,KAChB,MAAMG,EAAcH,EAAK,QAEzB,GAAIG,IAAgBL,EAClB,GAAIC,EAAS,CACX,MAAMK,EAAWL,EAAQL,CAAI,EAC7B,GAAI,CAACU,EAAS,GACZ,OAAO3R,EAAI,CACT,KAAM,mBACN,YAAA0R,EACA,eAAAL,EACA,WAAY,EAAA,CACb,EAEHJ,EAAOU,EAAS,KAClB,KACE,QAAO3R,EAAI,CACT,KAAM,mBACN,YAAA0R,EACA,eAAAL,EACA,WAAY,EAAA,CACb,EAIL,GAAI,CAACO,GAAeX,EAAMM,EAAK,QAAS,EACtC,OAAOvR,EAAI,CACT,KAAM,kBACN,SAAUuR,EAAK,SACf,OAAQM,GAAkBZ,CAAI,CAAA,CAC/B,EAGH,MAAM1P,EAAS6P,EAAO,UAAUH,CAAI,EACpC,OAAK1P,EAAO,QAOLxB,EAAGwB,EAAO,IAAS,EANjBvB,EAAI,CACT,KAAM,iBACN,QAASuB,EAAO,MAAM,OAAA,CACvB,CAIL,CAWO,SAASsQ,GAAkBZ,EAAuB,CAEvD,MAAMa,EAAa,KAAK,UAAUb,EAAM,CAACc,EAAMvc,IAEzCA,GAAS,OAAOA,GAAU,UAAY,CAAC,MAAM,QAAQA,CAAK,EACrD,OAAO,KAAKA,CAAK,EACrB,OACA,OAAO,CAACwc,EAAiCC,KACxCD,EAAOC,CAAC,EAAIzc,EAAMyc,CAAC,EACZD,GACN,CAAA,CAAE,EAEFxc,CACR,EAGD,IAAI0c,EAAO,WACX,QAAShU,EAAI,EAAGA,EAAI4T,EAAW,OAAQ5T,IACrCgU,GAAQJ,EAAW,WAAW5T,CAAC,EAC/BgU,EAAO,KAAK,KAAKA,EAAM,QAAQ,EAIjC,OAAQA,IAAS,GAAG,SAAS,EAAE,EAAE,SAAS,EAAG,GAAG,CAClD,CASO,SAASN,GAAeX,EAAekB,EAAmC,CAE/E,OADuBN,GAAkBZ,CAAI,IACnBkB,CAC5B,CCvJA,MAAMC,GAAmB,gCACnBC,GAAgB,UAuBtB,SAASC,GAAeC,EAAsB,CAC5C,GAAIA,EAAO,GAAKA,GAAQ,EACtB,MAAM,IAAI,MAAM,sBAAsBA,CAAI,gBAAgB,EAE5D,MAAO,GAAGH,EAAgB,GAAGG,CAAI,EACnC,CAKA,SAASC,GAAajd,EAAqB,CACzC,MAAO,GAAGA,CAAG,GAAG8c,EAAa,EAC/B,CAQA,SAASI,GAAald,EAAmC,CACvD,GAAI,CACF,MAAMmd,EAAW,aAAa,QAAQnd,CAAG,EACzC,OAAImd,GACF,aAAa,QAAQF,GAAajd,CAAG,EAAGmd,CAAQ,EAE3C3S,EAAG,MAAS,CACrB,OAASE,EAAO,CACd,MAAM2C,EAAU3C,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EACrE,OAAOD,EAAI,4BAA4B4C,CAAO,EAAE,CAClD,CACF,CAKA,SAAS+P,GAAiB1B,EAAwC2B,EAAkC,CAClG,MAAMC,EAAWhB,GAAkBZ,CAAI,EACvC,MAAO,CACL,QAAA2B,EACA,UAAW,KAAK,IAAA,EAChB,SAAAC,EACA,KAAA5B,CAAA,CAEJ,CAKA,SAAS6B,GACP3B,EACA4B,EACA3B,EACAE,EACoC,CACpC,OAAOJ,GAAoBC,EAASC,EAAQ2B,EAAiBzB,CAAO,CACtE,CASO,SAAS0B,GAAaT,EAActB,EAAoC,CAC7E,GAAI,CACF,GAAIsB,EAAO,GAAKA,GAAQ,EACtB,OAAOvS,EAAI,sBAAsBuS,CAAI,gBAAgB,EAIvD,MAAMU,EAAmB3C,EAAa,UAAUW,CAAI,EACpD,GAAI,CAACgC,EAAiB,QACpB,OAAOjT,EAAI,sBAAsBiT,EAAiB,MAAM,OAAO,EAAE,EAGnE,MAAM1d,EAAM+c,GAAeC,CAAI,EAGzBW,EAAeT,GAAald,CAAG,EACrC,GAAI,CAAC2d,EAAa,GAChB,OAAOA,EAIT,MAAMC,EAAUR,GAAiBM,EAAiB,KAAM,OAAO,EACzDnB,EAAa,KAAK,UAAUqB,CAAO,EAGzC,oBAAa,QAAQ5d,EAAKuc,CAAU,EAE7B/R,EAAG,MAAS,CACrB,OAASE,EAAO,CACd,OAAOD,EAAI,4BAA4BC,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAAC,EAAE,CACjG,CACF,CAKO,SAASmT,GAAab,EAAsC,CACjE,GAAI,CACF,GAAIA,EAAO,GAAKA,GAAQ,EACtB,OAAOvS,EAAI,sBAAsBuS,CAAI,gBAAgB,EAGvD,MAAMhd,EAAM+c,GAAeC,CAAI,EACzBT,EAAa,aAAa,QAAQvc,CAAG,EAE3C,GAAI,CAACuc,EACH,OAAO9R,EAAI,iCAAiC,EAI9C,IAAImR,EACJ,GAAI,CACFA,EAAU,KAAK,MAAMW,CAAU,CACjC,OAASuB,EAAY,CAEnB,MAAMC,EAAWD,aAAsB,MAAQA,EAAW,QAAU,eACpE,OAAOE,GAAuBhB,EAAM,sBAAsBe,CAAQ,EAAE,CACtE,CAGA,MAAME,EAAeV,GAA0B3B,EAAS,QAASb,EAAcU,EAAe,EAC9F,GAAI,CAACwC,EAAa,GAAI,CAEpB,MAAMF,EAAWE,EAAa,MAAM,KACpC,OAAOD,GAAuBhB,EAAM,sBAAsBe,CAAQ,EAAE,CACtE,CAGA,MAAMG,EAAenD,EAAa,UAAUkD,EAAa,KAAK,EAC9D,OAAKC,EAAa,QAIX1T,EAAG0T,EAAa,IAAI,EAHlBzT,EAAI,gCAAgCyT,EAAa,MAAM,OAAO,EAAE,CAI3E,OAASxT,EAAO,CACd,OAAOD,EAAI,4BAA4BC,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAAC,EAAE,CACjG,CACF,CAQA,SAASsT,GAAuBhB,EAAcmB,EAA4C,CACxF,GAAI,CACF,MAAMne,EAAM+c,GAAeC,CAAI,EACzBoB,EAAYnB,GAAajd,CAAG,EAC5Buc,EAAa,aAAa,QAAQ6B,CAAS,EAEjD,GAAI,CAAC7B,EAAY,CACf,MAAM8B,EAAUF,EAAY,qBAAqBA,CAAS,GAAK,GAC/D,OAAO1T,EAAI,2CAA2C4T,CAAO,EAAE,CACjE,CAEA,MAAMzC,EAAU,KAAK,MAAMW,CAAU,EAC/B0B,EAAeV,GAA0B3B,EAAS,QAASb,EAAcU,EAAe,EAE9F,GAAI,CAACwC,EAAa,GAAI,CACpB,MAAMI,EAAUF,EAAY,qBAAqBA,CAAS,GAAK,GAC/D,OAAO1T,EAAI,2CAA2C4T,CAAO,EAAE,CACjE,CAEA,MAAMH,EAAenD,EAAa,UAAUkD,EAAa,KAAK,EAC9D,GAAI,CAACC,EAAa,QAAS,CACzB,MAAMG,EAAUF,EAAY,qBAAqBA,CAAS,GAAK,GAC/D,OAAO1T,EAAI,4BAA4B4T,CAAO,EAAE,CAClD,CAGA,oBAAa,QAAQre,EAAKuc,CAAU,EAE7B/R,EAAG0T,EAAa,IAAI,CAC7B,OAASxT,EAAO,CACd,MAAM2T,EAAUF,EAAY,qBAAqBA,CAAS,GAAK,GAC/D,OAAO1T,EAAI,0BAA0BC,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAAC,IAAI2T,CAAO,EAAE,CAC1G,CACF,CAmIO,SAASC,GAAYtB,EAAuB,CACjD,OAAIA,EAAO,GAAKA,GAAQ,EACf,GAEF,aAAa,QAAQD,GAAeC,CAAI,CAAC,IAAM,IACxD,CAKO,SAASuB,GAAevB,EAAoC,CACjE,GAAI,CACF,GAAIA,EAAO,GAAKA,GAAQ,EACtB,OAAOvS,EAAI,sBAAsBuS,CAAI,gBAAgB,EAGvD,MAAMhd,EAAM+c,GAAeC,CAAI,EAC/B,oBAAa,WAAWhd,CAAG,EAC3B,aAAa,WAAWid,GAAajd,CAAG,CAAC,EAElCwK,EAAG,MAAS,CACrB,OAASE,EAAO,CACd,OAAOD,EAAI,0BAA0BC,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAAC,EAAE,CAC/F,CACF,CAmBO,SAAS8T,GAAoBxB,EAAgC,CAClE,GAAIA,EAAO,GAAKA,GAAQ,EACtB,MAAO,CAAE,OAAQ,EAAA,EAGnB,MAAMT,EAAa,aAAa,QAAQQ,GAAeC,CAAI,CAAC,EAC5D,GAAI,CAACT,EACH,MAAO,CAAE,OAAQ,EAAA,EAGnB,GAAI,CACF,MAAMX,EAAU,KAAK,MAAMW,CAAU,EAGrC,GAAI,CAACX,EAAQ,MAAQ,CAACA,EAAQ,SAC5B,MAAO,CAAE,OAAQ,GAAM,UAAW,EAAA,EAGpC,MAAMF,EAAOE,EAAQ,KAGrB,GAAI,CAACF,EAAK,YAAc,CAACA,EAAK,OAAS,CAAC,MAAM,QAAQA,EAAK,WAAW,cAAc,EAClF,MAAO,CAAE,OAAQ,GAAM,UAAW,EAAA,EAIpC,MAAM+C,EAAW/C,EAAK,WAAW,eAAe,OAAS,EACrD,KAAK,MACHA,EAAK,WAAW,eAAe,OAAO,CAACjW,EAAK,IAAM,CAChD,MAAMjC,EAAQ,OAAO,GAAG,OAAU,SAAW,EAAE,MAAQ,EACvD,OAAOiC,EAAMjC,CACf,EAAG,CAAC,EAAIkY,EAAK,WAAW,eAAe,MAAA,EAEzC,EAEJ,MAAO,CACL,OAAQ,GACR,UAAW,OAAOE,EAAQ,WAAc,SAAWA,EAAQ,UAAY,KAAK,IAAA,EAC5E,SAAU,OAAOF,EAAK,MAAM,UAAa,SAAWA,EAAK,MAAM,SAAW,EAC1E,UAAW+C,EACX,KAAM,OAAO/C,EAAK,WAAW,MAAS,SAAWA,EAAK,WAAW,KAAO,EACxE,QAAS,EACT,UAAW,EAAA,CAEf,MAAQ,CACN,MAAO,CAAE,OAAQ,GAAM,UAAW,EAAA,CACpC,CACF,CAgBO,SAASgD,GAAShD,EAAoC,CAC3D,OAAO+B,GAAa,EAAG/B,CAAI,CAC7B,CAKO,SAASiD,IAAmC,CACjD,OAAOd,GAAa,CAAC,CACvB,CAKO,SAASe,IAAmB,CACjC,OAAON,GAAY,CAAC,CACtB,CAKO,SAASO,IAAmC,CACjD,OAAON,GAAe,CAAC,CACzB,CAKO,SAASO,GAAa9B,EAActB,EAAoC,CAC7E,OAAO+B,GAAaT,EAAMtB,CAAI,CAChC,CAKO,SAASqD,GAAa/B,EAAsC,CACjE,OAAOa,GAAab,CAAI,CAC1B,CC9eO,MAAMgC,EAAoC,CAC/C,kBAAmB,EACnB,eAAgB,IAChB,mBAAoB,GACpB,qBAAsB,IACtB,kBAAmB,EACnB,YAAa,CACf,EAEyCA,EAAqB,kBACxBA,EAAqB,eACVA,EAAqB,mBACzBA,EAAqB,qBACzBA,EAAqB,kBAC3BA,EAAqB,YCgDjD,SAASC,GACd/M,EACAgN,EACAC,EACAC,EAAiC,CAAA,EAClB,CACf,GAAI,CAACD,EAAO,OACV,MAAM,IAAI,MAAM,8CAA8C,EAGhE,MAAME,EAAe,CAAC,GAAGF,CAAM,EAAE,KAAK,CAACtW,EAAGC,IAAMD,EAAE,YAAcC,EAAE,WAAW,EACvEwW,EAAWD,EAAa,IAAIE,GAASA,EAAM,EAAE,EAEnD,MAAO,CACL,KAAArN,EACA,WAAAgN,EACA,WAAY,EACZ,SAAAI,EACA,YAAa,GACb,SAAU,GACV,MAAO,CACL,aAAc,EACd,aAAc,EACd,UAAW,EACX,QAAS,EACT,SAAU,EACV,WAAY,EACZ,iBAAkB,EAClB,iBAAkB,CAAA,EAEpB,QAASD,EAAa,IAAIE,IAAU,CAClC,QAASA,EAAM,GACf,YAAaA,EAAM,YACnB,KAAMA,EAAM,KACZ,QAAS,UACT,eAAgB,CAAA,CAAC,EACjB,EACF,eAAgB,CAAA,EAChB,OAAQH,EAAQ,QAAUJ,EAC1B,aAAcI,EAAQ,YAAA,CAE1B,CAEO,SAASI,GAAgBC,EAAoBN,EAAkD,CACpG,GAAIM,EAAI,YAAcA,EAAI,SAAS,OACjC,OAAO,KAET,MAAMC,EAAYD,EAAI,SAASA,EAAI,UAAU,EAC7C,OAAOE,GAAaR,EAAQO,CAAS,CACvC,CA4BO,SAASE,GAAmB,CACjC,IAAAH,EACA,OAAAN,EACA,QAAAU,EACA,QAAAC,EACA,QAAAC,EAAU,CAAA,CACZ,EAA4C,CAC1C,MAAMC,EAAeR,GAAgBC,EAAKN,CAAM,EAChD,GAAI,CAACa,EACH,OAAOP,EAET,GAAIO,EAAa,OAAS,OACxB,MAAM,IAAI,MAAM,8CAA8CA,EAAa,EAAE,EAAE,EAGjF,MAAMC,EAAYC,GAAqBT,EAAI,MAAOO,EAAa,YAAaH,EAASC,CAAO,EACtFK,EAAwCV,EAAI,QAAQ,IAAIW,GACxDA,EAAM,UAAYJ,EAAa,GAC1BI,EAEF,CACL,GAAGA,EACH,QAAAP,EACA,eAAgBE,CAAA,CAEnB,EAEKM,EAASR,IAAY,UACrBS,EAAaT,IAAY,UACzBU,EAAiBF,EAAS,KAAK,IAAIZ,EAAI,WAAa,EAAGA,EAAI,SAAS,MAAM,EAAIA,EAAI,WAClFe,EAAsBD,GAAkBd,EAAI,SAAS,OACrDgB,EAAWZ,IAAY,SAG7B,MAAO,CACL,GAAGJ,EACH,MAAOQ,EACP,QAASE,EACT,WAAYI,EACZ,YAPkBC,GAAuBF,GAAcG,EAQvD,SAAAA,EACA,eAAgBV,EAAQ,OAAS,CAAC,GAAGN,EAAI,eAAgB,GAAGM,CAAO,EAAIN,EAAI,cAAA,CAG/E,CAEO,SAASiB,GACdjB,EACAN,EACAW,EACe,CACf,MAAME,EAAeR,GAAgBC,EAAKN,CAAM,EAChD,GAAI,CAACa,EACH,OAAOP,EAET,GAAIO,EAAa,OAAS,OACxB,MAAM,IAAI,MAAM,+CAA+CA,EAAa,EAAE,EAAE,EAGlF,MAAMG,EAAcV,EAAI,QAAQ,IAAIW,GAC9BA,EAAM,UAAYJ,EAAa,GAC1BI,EAE+B,CACtC,GAAGA,EACH,QAAS,SACT,eAAgB,CAAA,EAChB,YAAaN,CAAA,CAGhB,EAED,MAAO,CACL,GAAGL,EACH,QAASU,EACT,WAAY,KAAK,IAAIV,EAAI,WAAa,EAAGA,EAAI,SAAS,MAAM,EAC5D,MAAO,CACL,GAAGA,EAAI,MACP,aAAc,KAAK,IAAIA,EAAI,MAAM,aAAcO,EAAa,WAAW,CAAA,CACzE,CAEJ,CAEO,SAASW,GAAoBlB,EAAmC,CACrE,OAAKA,EAAI,eAAe,OAGjB,CACL,GAAGA,EACH,eAAgB,CAAA,CAAC,EAJVA,CAMX,CAkBA,SAASE,GAAaR,EAA+Ble,EAAwB,CAC3E,MAAMse,EAAQJ,EAAO,KAAKiB,GAASA,EAAM,KAAOnf,CAAE,EAClD,GAAI,CAACse,EACH,MAAM,IAAI,MAAM,eAAete,CAAE,YAAY,EAE/C,OAAOse,CACT,CAEA,SAASW,GACPU,EACAC,EACAhB,EACAC,EACe,CACf,MAAO,CACL,aAAcD,IAAY,UAAY,KAAK,IAAIe,EAAM,aAAcC,CAAW,EAAID,EAAM,aACxF,aAAcA,EAAM,aAAe,EACnC,UAAWA,EAAM,WAAaf,IAAY,UAAY,EAAI,GAC1D,QAASe,EAAM,SAAWf,IAAY,SAAW,EAAI,GACrD,SAAUe,EAAM,UAAYf,IAAY,UAAY,EAAI,GACxD,WAAYe,EAAM,WAAad,EAAQ,WACvC,iBAAkBc,EAAM,iBAAmBd,EAAQ,YACnD,iBAAkBc,EAAM,iBAAmBd,EAAQ,WAAA,CAEvD,CC9QO,SAASgB,GAAaziB,EAAYY,EAAuC,CAE9E,GAAI,CAACiB,EAAMjB,CAAO,EAChB,OAAOwL,EAAI,SAASxL,CAAO,iBAAiB,EAI9C,GAAIZ,EAAK,eAAe,SAASY,CAAO,EACtC,OAAOwL,EAAI,SAASxL,CAAO,oBAAoB,EAIjD,GAAIZ,EAAK,eAAe,QAAU,GAChC,OAAOoM,EAAI,mCAAmC,EAIhD,MAAMsW,EAAoB,CAAC,GAAG1iB,EAAK,eAAgBY,CAAO,EAE1D,OAAOuL,EAAGpM,EAAWC,EAAM,CACzB,eAAgB0iB,CAAA,CACjB,CAAC,CACJ,CAMO,SAASC,GAAW3iB,EAAYY,EAAiBgiB,EAAoB,GAA0B,CAEpG,GAAI,CAAC5iB,EAAK,eAAe,SAASY,CAAO,EACvC,OAAOwL,EAAI,SAASxL,CAAO,gBAAgB,EAI7C,GAAIZ,EAAK,cAAc,SAASY,CAAO,EACrC,OAAOwL,EAAI,SAASxL,CAAO,mBAAmB,EAIhD,GAAIZ,EAAK,cAAc,QAAU,EAAG,CAClC,GAAI4iB,EAAY,GAAKA,GAAa,EAChC,OAAOxW,EAAI,gDAAgD,EAI7D,MAAMyW,EAAmB,CAAC,GAAG7iB,EAAK,aAAa,EACzC8iB,EAAaD,EAAiBD,CAAS,EAC7CC,EAAiBD,CAAS,EAAIhiB,EAG9B,MAAMmiB,EAAc,CAAE,GAAG/iB,EAAK,aAAA,EAC9B,OAAI8iB,GACF,OAAOC,EAAYD,CAAU,EAE1BC,EAAYniB,CAAO,IACtBmiB,EAAYniB,CAAO,EAAI,CACrB,QAAAA,EACA,MAAO,MACP,kBAAmB,EAAA,GAIhBuL,EAAGpM,EAAWC,EAAM,CACzB,cAAe6iB,EACf,cAAeE,CAAA,CAChB,CAAC,CACJ,CAGA,MAAMF,EAAmB,CAAC,GAAG7iB,EAAK,cAAeY,CAAO,EAClDmiB,EAAc,CAAE,GAAG/iB,EAAK,aAAA,EAC9B,OAAK+iB,EAAYniB,CAAO,IACtBmiB,EAAYniB,CAAO,EAAI,CACrB,QAAAA,EACA,MAAO,MACP,kBAAmB,EAAA,GAIhBuL,EAAGpM,EAAWC,EAAM,CACzB,cAAe6iB,EACf,cAAeE,CAAA,CAChB,CAAC,CACJ,CC1EO,SAASC,GAAiBC,EAAkB,EAAe,CAChE,MAAO,CACL,QAAAA,EACA,MAAO,CAAA,CAAC,CAEZ,CAKO,SAASC,EAAQxe,EAAmBye,EAAcvhB,EAA0B,GAAkB,CACnG,MAAO,CACL,GAAG8C,EACH,MAAO,CACL,GAAGA,EAAM,MACT,CAACye,CAAI,EAAGvhB,CAAA,CACV,CAEJ,CCbO,SAASwhB,GACd1e,EACA2e,EAC4B,CAE5B,MAAMC,EAAUC,GAAqBF,CAAY,EAGjD,OAAIC,IAAY,YAAc5e,EAAM,UAAY,EAEvC,CACL,GAAI,GACJ,MAAO,CACL,GAJawe,EAAQxe,EAAO,WAAY,EAAI,EAK5C,QAAS,CAAA,CACX,EAKA4e,IAAY,YAAc5e,EAAM,UAAY,EAEvC,CACL,GAAI,GACJ,MAAO,CACL,GAJawe,EAAQxe,EAAO,WAAY,EAAI,EAK5C,QAAS,CAAA,CACX,EAKA4e,IAAY,YAAc5e,EAAM,UAAY,EAEvC,CACL,GAAI,GACJ,MAAO,CACL,GAJawe,EAAQxe,EAAO,WAAY,EAAI,EAK5C,QAAS,CAAA,CACX,EAIG,CACL,GAAI,GACJ,MAAO,uCAAuC2e,CAAY,KAAKC,CAAO,gBAAgB5e,EAAM,OAAO,EAAA,CAEvG,CAMO,SAAS6e,GAAqBC,EAA6B,CAEhE,GAAIA,IAAgB,WAAY,MAAO,WACvC,GAAIA,EAAY,WAAW,QAAQ,EAAG,CACpC,MAAMC,EAAQD,EAAY,MAAM,eAAe,EAC/C,GAAIC,EAEF,MAAO,iBADU,SAASA,EAAM,CAAC,EAAI,EAAE,CACP,EAEpC,CAGA,OAAID,IAAgB,UAAkB,WAClCA,IAAgB,UAAkB,WAClCA,IAAgB,UAAkB,WAGlCA,IAAgB,gBAAkBA,IAAgB,cAAsB,eACxEA,IAAgB,gBAAkBA,IAAgB,cAAsB,eACxEA,IAAgB,gBAAkBA,IAAgB,cAAsB,eAGxEA,EAAY,WAAW,YAAY,EAE9B,iBADcA,EAAY,QAAQ,aAAc,EAAE,CACrB,GAElCA,EAAY,WAAW,YAAY,EAE9B,iBADcA,EAAY,QAAQ,aAAc,EAAE,CACrB,GAElCA,EAAY,WAAW,YAAY,EAE9B,iBADcA,EAAY,QAAQ,aAAc,EAAE,CACrB,IAIlCA,EAAY,WAAW,OAAO,GAAKA,EAAY,WAAW,WAAW,GAAKA,EAAY,WAAW,YAAY,EACxGA,EAKX,CAOO,SAASE,GACdhf,EACA8e,EACY,CACZ,MAAMF,EAAUC,GAAqBC,CAAW,EAChD,IAAIzV,EAAemV,EAAQxe,EAAO4e,EAAS,EAAI,EAM/C,OAAIE,EAAY,WAAW,QAAQ,IACjCzV,EAAemV,EAAQnV,EAAcyV,EAAa,EAAI,GAGjDzV,CACT,CAWO,SAAS4V,GAAgBC,EAAmBC,EAA0B,CAE3E,GAAIA,IAAY,WAAY,MAAO,GAGnC,MAAMJ,EAAQI,EAAQ,MAAM,eAAe,EAC3C,GAAI,CAACJ,EAAO,MAAO,GAEnB,KAAM,CAAA,CAAGK,CAAW,EAAIL,EACxB,GAAI,CAACK,EAAa,MAAO,GACzB,MAAMC,EAAW,SAASD,EAAa,EAAE,EAGnCE,EAAc,SAAS,OAAOD,EAAW,CAAC,EAAE,SAAS,EAAG,GAAG,CAAC,GAClE,OAAOH,EAAM,MAAMI,CAAW,IAAM,EACtC,CAYO,SAASC,GACdL,EACA5jB,EACAkkB,EACAC,EACgE,CAEhE,MAAMC,EAAelB,EAAQU,EAAOM,EAAQC,CAAS,EAGrD,GAAIA,IAAc,GAChB,MAAO,CAAE,MAAOC,EAAc,KAAApkB,EAAM,aAAc,IAAA,EAIpD,MAAMY,EAAUyjB,GAAoBH,CAAM,EAC1C,GAAI,CAACtjB,EACH,MAAO,CAAE,MAAOwjB,EAAc,KAAApkB,EAAM,aAAc,IAAA,EAIpD,MAAMskB,EAAgB7B,GAAaziB,EAAMY,CAAO,EAChD,OAAI0jB,EAAc,GACT,CAAE,MAAOF,EAAc,KAAME,EAAc,MAAO,aAAc1jB,CAAA,EAKlE,CAAE,MAAOwjB,EAAc,KAAApkB,EAAM,aAAc,IAAA,CACpD,CAYO,SAASukB,GACdX,EACAM,EACAC,EACAK,EAAuB,EAC4B,CAEnD,MAAMJ,EAAelB,EAAQU,EAAOM,EAAQC,CAAS,EAQ/CrP,EAAS2P,GAAmBP,CAAM,EACxC,GAAI,CAACpP,EACH,MAAO,CAAE,MAAOsP,EAAc,cAAe,IAAA,EAI/C,MAAMM,EAAUC,GAAiB7P,CAAM,EACvC,GAAI,CAAC4P,EACH,eAAQ,MAAM,mBAAmB5P,CAAM,YAAY,EAC5C,CAAE,MAAOsP,EAAc,cAAe,IAAA,EAI/C,MAAMQ,EAAgB3f,GAAWyf,EAASF,EAAc,CAAC,EAEzD,MAAO,CAAE,MAAOJ,EAAc,cAAAQ,CAAA,CAChC,CCtPA,MAAMC,GAA6C,CACjD,EAAG,EACH,EAAG,IACH,EAAG,IACH,EAAG,IACH,EAAG,KACH,EAAG,KACH,EAAG,KACH,EAAG,KACH,EAAG,KACH,GAAI,MACJ,GAAI,KACJ,GAAI,MACJ,GAAI,MACJ,GAAI,MACJ,GAAI,MACJ,GAAI,KACJ,GAAI,MACJ,GAAI,MACJ,GAAI,MACJ,GAAI,KACN,EAsBO,SAASC,GAAqBC,EAAoB,CACvD,GAAIA,EAAK,EAAG,MAAO,GAGnB,IAAIC,EAAM,EACNC,EAAO,GACPtX,EAAS,EAEb,KAAOqX,GAAOC,GAAM,CAClB,MAAMC,EAAM,KAAK,OAAOF,EAAMC,GAAQ,CAAC,EACjCE,EAAQN,GAASK,CAAG,EAE1B,GAAIC,IAAU,OAEZ,MAGEJ,GAAMI,GACRxX,EAASuX,EACTF,EAAME,EAAM,GAEZD,EAAOC,EAAM,CAEjB,CAEA,OAAOvX,CACT,CAMO,SAASyX,GACd/jB,EACAgkB,EAMA,CAEA,MAAMC,EAAQ,KAAK,IAAI,EAAGjkB,EAAK,GAAKgkB,CAAM,EACpCE,EAAWlkB,EAAK,MAChBmkB,EAAWV,GAAqBQ,CAAK,EACrCG,EAAYD,EAAWD,EAGvBG,EAAcF,EAAWD,EAGzBI,EAA8B,CAAA,EACpC,GAAIF,EACF,QAAStgB,EAAQogB,EAAW,EAAGpgB,GAASqgB,EAAUrgB,IAAS,CACzD,MAAMygB,EAAmBvkB,EAAK,UAAU,OACtCmJ,GAAKA,EAAE,cAAgBrF,CAAA,EAEzBwgB,EAAkB,KAAK,GAAGC,EAAiB,IAAIpb,GAAKA,EAAE,EAAE,CAAC,CAC3D,CAIF,IAAIqb,EAAyBxkB,EAAK,mBAClC,OAAIqkB,EAEFG,EAAyBxkB,EAAK,UAC3B,OAAOmJ,GAAKA,EAAE,aAAegb,CAAQ,EACrC,IAAIhb,GAAKA,EAAE,EAAE,EACPib,IAETI,EAAyB,CAAC,GAAGxkB,EAAK,mBAAoB,GAAGskB,CAAiB,GAUrE,CACL,KARwB,CACxB,GAAGtkB,EACH,GAAIikB,EACJ,MAAOE,EACP,mBAAoBK,CAAA,EAKpB,UAAAJ,EACA,SAAAD,EACA,kBAAAG,CAAA,CAEJ,CCzHO,SAASG,GACdtC,EACAuC,EACe,CACf,MAAMC,EAAYC,GAAWzC,CAAW,EACxC,GAAI,CAACwC,EACH,MAAM,IAAI,MAAM,aAAaxC,CAAW,YAAY,EAGtD,MAAM0C,EAAcH,IAAkB,EAChCI,EAAYJ,EAAgB,EAAI,KAAK,MAAMC,EAAU,OAAO,GAAKD,CAAa,EAAI,EAExF,MAAO,CACL,QAASC,EAAU,OAAO,GAC1B,UAAWA,EAAU,OAAO,KAC5B,UAAAG,EACA,cAAAJ,EACA,YAAAG,EACA,gBAAiBF,EAAU,QAAQ,OACnC,gBAAiBA,EAAU,OAAO,SAAA,CAEtC,CAaO,SAASI,GACd/kB,EACAkkB,EACAC,EACW,CAEX,MAAMa,EAAYb,EAAWD,EAE7B,MAAO,CACL,GAAIlkB,EAAK,YAAY,GAAKglB,EAC1B,GAAIhlB,EAAK,YAAY,GAAKglB,EAC1B,IAAKhlB,EAAK,YAAY,IAAMglB,EAC5B,IAAKhlB,EAAK,YAAY,IAAMglB,EAC5B,IAAKhlB,EAAK,YAAY,IAAMglB,EAC5B,IAAKhlB,EAAK,YAAY,IAAMglB,CAAA,CAEhC,CAeO,SAASC,GACdtmB,EACA0hB,EAC4C,CAC5C,MAAM6E,EAA2B,CAAA,EAC3BtX,EAAuB,CAAA,EAG7B,UAAW5N,KAAQrB,EAAK,MAAO,CAE7B,GAAIgF,EAAS3D,CAAI,EAAG,CAClB4N,EAAa,KAAK5N,CAAI,EACtB,QACF,CAGA,GAAIA,EAAK,OAAS,GAAI,CACpB4N,EAAa,KAAK5N,CAAI,EACtB,QACF,CAGA,MAAMkkB,EAAWlkB,EAAK,MAGhBmlB,EAAWpB,GAAM/jB,EAAMqgB,EAAQ,SAAS,EACxCtY,EAAcod,EAAS,KAI7B,GAHAvX,EAAa,KAAK7F,CAAW,EAGzBod,EAAS,UAAW,CAEtB,MAAMC,EAAYL,GAAmBhd,EAAamc,EAAUiB,EAAS,QAAQ,EAG7ED,EAAS,KAAK,CACZ,OAAQnd,EAAY,GACpB,SAAUA,EAAY,KACtB,SAAAmc,EACA,SAAUiB,EAAS,SACnB,UAAAC,EACA,qBAAsBD,EAAS,iBAAA,CAChC,CACH,CACF,CAGA,MAAMliB,EAAoB,CACxB,GAAGtE,EACH,MAAOiP,CAAA,EAGT,MAAO,CACL,QAAAyS,EACA,SAAA6E,EACA,WAAY7E,EAAQ,UACpB,YAAApd,CAAA,CAEJ,CC5HO,SAASoiB,GACd7hB,EACyD,CACzD,MAAM2e,EAAc5e,GAAeC,CAAM,EACzC,GAAI,CAAC2e,EACH,MAAM,IAAI,MAAM,6CAA6C,EAG/D,MAAMmD,EAAY9hB,EAAO,WAAW,MAAM,OAAOqF,GAAK,CAAClF,EAASkF,CAAC,CAAC,EAC5DwX,EAAUoE,GAAuBtC,EAAamD,EAAU,MAAM,EAE9DC,EAAeN,GAAkBzhB,EAAO,WAAY6c,CAAO,EAC3DmF,EAAsBC,GAAuBpF,EAAQ,eAAe,EAM1E,IAAIpd,EAAcsiB,EAAa,YAG/B,MAAMG,EAAqB,CAAE,GAAGziB,EAAY,aAAA,EAC5C,UAAW1D,KAAWmmB,EAAoB,CACxC,MAAMlQ,EAAUkQ,EAAmBnmB,CAAO,EACtCiW,IACFkQ,EAAmBnmB,CAAO,EAAI,CAC5B,QAASiW,EAAQ,QACjB,MAAO,MACP,kBAAmBA,EAAQ,iBAAA,EAGjC,CACA,OAAAvS,EAAc,CACZ,GAAGA,EACH,cAAeyiB,CAAA,EAaV,CACL,aAP+C,CAC/C,GAAGH,EACH,eAAgBC,EAAoB,OAAS,QAAUA,EAAoB,UAAY,OACvF,gBAAiBA,EAAoB,OAAS,SAAWA,EAAoB,QAAU,MAAA,EAKvF,YAAAviB,CAAA,CAGJ,CAEO,SAASwiB,GAAuBE,EAA8C,CACnF,OAAQA,EAAO,KAAA,CACb,IAAK,OACH,MAAO,CAAE,KAAM,MAAA,EACjB,IAAK,QAAS,CACZ,MAAM1gB,EAAY2gB,EAAUD,EAAO,MAAM,EACzC,GAAI,CAAC1gB,EACH,MAAM,IAAI,MAAM,aAAa0gB,EAAO,MAAM,YAAY,EAExD,MAAO,CAAE,KAAM,QAAS,UAAA1gB,CAAA,CAC1B,CACA,IAAK,SAQH,MAAO,CAAE,KAAM,SAAU,QAPT0gB,EAAO,QAAQ,IAAIpkB,GAAM,CACvC,MAAM0D,EAAY2gB,EAAUrkB,CAAE,EAC9B,GAAI,CAAC0D,EACH,MAAM,IAAI,MAAM,aAAa1D,CAAE,YAAY,EAE7C,OAAO0D,CACT,CAAC,CACwB,CAC3B,CAEJ,CC3EA,SAAS4gB,GAAsBxC,EAAyBvf,EAAsB,CAC5E,MAAMJ,EAAaI,EAAQ,EAE3B,MAAO,CACL,GAAIuf,EAAQ,UAAU,GAAM3f,EAAa2f,EAAQ,YAAY,GAC7D,GAAIA,EAAQ,UAAU,GAAM3f,EAAa2f,EAAQ,YAAY,GAC7D,IAAKA,EAAQ,UAAU,IAAO3f,EAAa2f,EAAQ,YAAY,IAC/D,IAAKA,EAAQ,UAAU,IAAO3f,EAAa2f,EAAQ,YAAY,IAC/D,IAAKA,EAAQ,UAAU,IAAO3f,EAAa2f,EAAQ,YAAY,IAC/D,IAAKA,EAAQ,UAAU,IAAO3f,EAAa2f,EAAQ,YAAY,GAAA,CAEnE,CAgBO,SAASyC,GACdzC,EACAvf,EAAgB,EAChBiiB,EAAiB,GACjBC,EAAmB,GACnBtG,EAA8B,GACvB,CAEP,MAAMuG,EAAeJ,GAAsBxC,EAASvf,CAAK,EAGnDoiB,EAAaxG,EAAQ,MACvB,CAAE,GAAGuG,EAAc,GAAGvG,EAAQ,KAAA,EAC9BuG,EAGE1B,EAAmBlB,EAAQ,UAAU,OACzCliB,GAAW2C,IAAU3C,EAAQ,aAAe,EAAA,EAIxCglB,EAAiB5B,EAAiB,OAAS,EAC7CA,EACA,CAAClB,EAAQ,UAAU,CAAC,CAAE,EAE1B,MAAO,CACL,GAAI3D,EAAQ,IAAM,GAAG2D,EAAQ,EAAE,SAC/B,KAAMA,EAAQ,KACd,MAAAvf,EACA,QAASuf,EAAQ,QACjB,MAAO6C,EACP,UAAWC,EACX,OAAAJ,EACA,SAAAC,CAAA,CAEJ,CCrEO,SAASI,GAAYzX,EAAc7K,EAA+C,CACvF,MAAMuf,EAA0B,CAC9B,GAAI1U,EAAM,GACV,KAAMA,EAAM,KACZ,QAASA,EAAM,QACf,KAAM,WACN,UAAWA,EAAM,MACjB,YAAa,CACX,GAAI,EACJ,GAAI,EACJ,IAAK,EACL,IAAK,EACL,IAAK,EACL,IAAK,CAAA,EAEP,UAAWA,EAAM,UACjB,iBAAkB,EAClB,YAAa,KAAKA,EAAM,IAAI,SAC5B,iBAAkB,WAAA,EAGpB,OAAO/K,GAAWyf,EAAkB1U,EAAM,MAAO,CAAC,CACpD,CCjBO,SAAS0X,GAAclE,EAAuC,CACnE,OAAOyC,GAAWzC,CAAW,GAAK,IACpC,CAMO,SAASmE,GACdnE,EACAtf,EACA8F,EACsD,CACtD,MAAMgc,EAAY0B,GAAclE,CAAW,EAC3C,GAAI,CAACwC,EACH,OAAO,KAIT,MAAMniB,EAAamiB,EAAU,QAC1B,IAAI,CAAC4B,EAAS9jB,IAAU,CACvB,MAAM+jB,EAAWC,GAAQF,CAAO,EAChC,GAAI,CAACC,EACH,eAAQ,MAAM,oBAAoBD,CAAO,EAAE,EACpC,KAET,MAAM5X,EAAQyX,GAAYI,CAAQ,EAElC,MAAO,CAAE,GAAG7X,EAAO,GAAI,GAAGA,EAAM,EAAE,IAAIlM,CAAK,EAAA,CAC7C,CAAC,EACA,OAAQoG,GAA2CA,IAAM,IAAI,EAEhE,GAAIrG,EAAW,SAAW,EACxB,eAAQ,MAAM,yCAAyC2f,CAAW,EAAE,EAC7D,KAIT,MAAMuE,EAAerb,GAAYxI,EAAYL,EAAYmG,CAAG,EAE5D,OAAK+d,EAAa,GAgBX,CAAE,OAV2B,CAClC,GAAGA,EAAa,MAChB,YAAa/B,EAAU,GACvB,KAAM,CACJ,YAAaA,EAAU,GACvB,WAAYA,EAAU,aAAe,OAAS,OAAS,QAAA,EAEzD,aAAcA,EAAU,aAAe,MAAA,EAGR,UAAAA,CAAA,GAf/B,QAAQ,MAAM,2BAA2B+B,EAAa,KAAK,EAAE,EACtD,KAeX,CCzEA,SAASC,GAAQC,EAAcC,EAAsC,CACnE,MAAMC,EAAUD,EAAS,GAAK,GAAKA,EAAS,EAAID,EAAI,MAC9CG,EAAUF,EAAS,GAAK,GAAKA,EAAS,EAAID,EAAI,OACpD,GAAI,CAACE,GAAW,CAACC,EAAS,OAC1B,MAAMC,EAAMJ,EAAI,MAAMC,EAAS,CAAC,EAChC,GAAKG,EACL,OAAOA,EAAIH,EAAS,CAAC,CACvB,CAEO,SAASI,GAAUL,EAAcC,EAA6B,CACnE,MAAMK,EAAOP,GAAQC,EAAKC,CAAQ,EAIlC,MAHI,GAACK,GACD,CAACA,EAAK,UACWN,EAAI,KAAK,QAAYO,EAAI,SAAS,IAAMN,EAAS,GAAKM,EAAI,SAAS,IAAMN,EAAS,CAAC,GAKlG,CAHkBD,EAAI,SAAS,KAAKQ,GACtCA,EAAQ,OAAS,OAASA,EAAQ,SAAS,IAAMP,EAAS,GAAKO,EAAQ,SAAS,IAAMP,EAAS,CAAA,EAOrG,CAEO,SAASQ,GAAaT,EAAcC,EAA4C,CACrF,OAAOD,EAAI,SAAS,KAAKQ,GAAWA,EAAQ,SAAS,IAAMP,EAAS,GAAKO,EAAQ,SAAS,IAAMP,EAAS,CAAC,CAC5G,CAEO,SAASS,GACdC,EACAC,EACAC,EAC8D,CAC9D,MAAMC,EAA4D,CAChE,GAAI,CAAE,EAAG,EAAG,EAAG,EAAA,EACf,KAAM,CAAE,EAAG,EAAG,EAAG,CAAA,EACjB,KAAM,CAAE,EAAG,GAAI,EAAG,CAAA,EAClB,MAAO,CAAE,EAAG,EAAG,EAAG,CAAA,CAAE,EAEhBC,EAAoB,CACxB,EAAGH,EAAW,EAAIE,EAAMD,CAAS,EAAE,EACnC,EAAGD,EAAW,EAAIE,EAAMD,CAAS,EAAE,CAAA,EAGrC,GAAI,CAACR,GAAUM,EAAYI,CAAO,EAChC,MAAO,CAAE,OAAQH,EAAY,QAAS,EAAA,EAGxC,MAAMJ,EAAUC,GAAaE,EAAYI,CAAO,EAChD,MAAO,CAAE,OAAQA,EAAS,QAAS,GAAO,QAAAP,CAAA,CAC5C,CC7CO,SAASQ,GAAcC,EAAmC,CAC/D,MAAO,CACL,OAAQA,EAAK,GACb,cAAeA,EAAK,YACpB,QAAS,CAACA,EAAK,WAAW,EAC1B,UAAW,CAAA,CAAC,CAEhB,CAEO,SAASC,GAAeD,EAAoBxkB,EAAgD,CACjG,OAAOwkB,EAAK,MAAM,QAAaE,EAAK,KAAO1kB,EAAM,aAAa,CAChE,CASO,SAAS2kB,GAAkBC,EAA8BtJ,EAAmC,CACjG,OAAQsJ,EAAU,KAAA,CAChB,IAAK,OACH,OAAOtJ,EAAQ,MAAMsJ,EAAU,GAAG,IAAMA,EAAU,MACpD,IAAK,OACH,OAAOtJ,EAAQ,UAAU,MAAM,SAASsJ,EAAU,GAAG,EACvD,IAAK,OACH,OAAIA,EAAU,WAAa,cAAsBtJ,EAAQ,KAAQsJ,EAAU,MACvEA,EAAU,WAAa,WAAmBtJ,EAAQ,KAAQsJ,EAAU,MACjEtJ,EAAQ,OAASsJ,EAAU,MACpC,IAAK,QACH,OAAIA,EAAU,WAAa,cAAsBtJ,EAAQ,MAASsJ,EAAU,MACxEA,EAAU,WAAa,WAAmBtJ,EAAQ,MAASsJ,EAAU,MAClEtJ,EAAQ,QAAUsJ,EAAU,MACrC,QACE,MAAO,EAAA,CAEb,CAEO,SAASC,GAAoBH,EAAoBpJ,EAA4C,CAClG,OAAKoJ,EAAK,QACHA,EAAK,QAAQ,OAAOI,GACpBA,EAAO,UACLH,GAAkBG,EAAO,UAAWxJ,CAAO,EADpB,EAE/B,EAJyB,CAAA,CAK5B,CAEO,SAASyJ,GAAaP,EAAoBxkB,EAAsBglB,EAAiC,CACtG,MAAMC,EAAcR,GAAeD,EAAMxkB,CAAK,EAC9C,GAAI,CAACilB,EAAa,OAAOjlB,EAEzB,MAAM8kB,EAASG,EAAY,SAAS,KAAKC,GAAKA,EAAE,KAAOF,CAAQ,EAC/D,OAAKF,EAEE,CACL,GAAG9kB,EACH,cAAe8kB,EAAO,WACtB,QAAS,CAAC,GAAG9kB,EAAM,QAAS8kB,EAAO,UAAU,EAC7C,UAAWA,EAAO,QAAU,CAAE,GAAG9kB,EAAM,UAAW,GAAG8kB,EAAO,OAAA,EAAY9kB,EAAM,SAAA,EAN5DA,CAQtB,CAEO,SAASmlB,GAAgBX,EAAoBxkB,EAA4C,CAC9F,MAAMilB,EAAcR,GAAeD,EAAMxkB,CAAK,EAE9C,MADI,CAACilB,GACDA,EAAY,SAAWA,EAAY,QAAQ,OAAS,EAAU,KAC9DA,EAAY,WACP,CACL,GAAGjlB,EACH,cAAeilB,EAAY,WAC3B,QAAS,CAAC,GAAGjlB,EAAM,QAASilB,EAAY,UAAU,EAElD,UAAWA,EAAY,QAAU,CAAE,GAAGjlB,EAAM,UAAW,GAAGilB,EAAY,OAAA,EAAYjlB,EAAM,SAAA,EAGrF,IACT,CC5EO,SAASolB,GAAazoB,EAAYiF,EAA+B,CACtE,OAAOA,EAAU,gBAAgB,SAASjF,EAAK,OAAO,CACxD,CCQO,SAAS0oB,GAAcC,EAAcC,EAAyB,CACnE,MAAMtkB,EAAOshB,EAAUgD,CAAM,EAC7B,OAAKtkB,EAGEqkB,GAAQrkB,EAAK,KAFX,EAGX,CAMO,SAASukB,GAAQF,EAAcC,EAAwF,CAC5H,MAAMtkB,EAAOshB,EAAUgD,CAAM,EAC7B,OAAKtkB,EAIDqkB,EAAOrkB,EAAK,KACPyG,EAAI,iBAAiBzG,EAAK,IAAI,UAAUA,EAAK,IAAI,WAAWqkB,CAAI,GAAG,EAGrE7d,EAAG,CACR,QAAS,GACT,QAAS6d,EAAOrkB,EAAK,KACrB,KAAAA,CAAA,CACD,EAXQyG,EAAI,QAAQ6d,CAAM,YAAY,CAYzC,CAMO,SAASE,GACd9oB,EACA+oB,EAC6D,CAC7D,MAAMC,EAAMC,GAAcjpB,CAAI,EAE9B,GAAI+oB,EAAcC,EAAI,KACpB,OAAOje,EAAI,2BAA2Bie,EAAI,IAAI,WAAWD,CAAW,GAAG,EAGzE,MAAMG,EAAe,OAAO,OAAOF,EAAI,SAAS,EAC1CG,EAA6B,CAAA,EACnC,UAAW5nB,KAAM2nB,EAAc,CAC7B,MAAM5kB,EAAOshB,EAAUrkB,CAAE,EACzB,GAAI,CAAC+C,EACH,OAAOyG,EAAI,aAAaxJ,CAAE,kBAAkBynB,EAAI,IAAI,EAAE,EAExDG,EAAc,KAAK7kB,CAAI,CACzB,CAEA,OAAOwG,EAAG,CACR,QAASie,EAAcC,EAAI,KAC3B,UAAWG,CAAA,CACZ,CACH,CAEO,SAASC,GACdppB,EACA2oB,EACAC,EACsD,CACtD,MAAMtkB,EAAOshB,EAAUgD,CAAM,EAC7B,OAAKtkB,EAIAmkB,GAAazoB,EAAMsE,CAAI,EAIxBqkB,EAAOrkB,EAAK,KACPyG,EAAI,iBAAiBzG,EAAK,IAAI,UAAUA,EAAK,IAAI,WAAWqkB,CAAI,GAAG,EAGrE7d,EAAG,CACR,QAAS6d,EAAOrkB,EAAK,KACrB,KAAAA,CAAA,CACD,EAVQyG,EAAI,GAAG/K,EAAK,IAAI,iBAAiBsE,EAAK,IAAI,EAAE,EAJ5CyG,EAAI,QAAQ6d,CAAM,YAAY,CAezC"}